<!DOCTYPE html>
<html>
  <head>
    <title>Centralized State Design Patterns | Lucas Reis' Blog</title>
    <link rel="stylesheet" href="../styles/reset.css" type="text/css">
    <link rel="stylesheet" href="../styles/style.css" type="text/css">
    <link rel="stylesheet" href="../styles/highlight.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='http://fonts.googleapis.com/css?family=Libre+Baskerville:400,700,400italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Lato:300,900' rel='stylesheet' type='text/css'>
    <link href="../rss.xml" rel="alternate" type="application/rss+xml" title="Lucas Reis' Blog">
  </head>
  <body>
    <div id="container">
      <header>
        <ul>
          <li class="active"><a href="../contents/">Blog</a></li>
          <li><a href="../">About</a></li>
        </ul>
      </header>
      <div id="main-text">
        <h1>Centralized State Design Patterns</h1>
        <div class="lead">Modern Front End Programming</div>
        <p>Front end programming is difficult. We are still figuring out how to best deal with it, and the quantity of frameworks and libraries that appear and disappear every week is one of the consequences.</p>
<p>At some point, Facebook launched the <a href="https://facebook.github.io/react/">React</a> framework, which seemed to have &quot;solved&quot; the rendering part of front end programming. We&#39;re all getting used to React&#39;s syntax and virtual DOM algorithm, and it seems like a good pattern, from both performance and productivity perspectives.</p>
<p>But we&#39;re still a little bit lost when it comes to managing the information being rendered. At first everyone was using React with the MV-something patterns available in Angular or Backbone. Then Facebook itself started talking about Flux and its unidirectional approach, and we started to see a lot of Flux-inspired frameworks being released.</p>
<p>At the same time, in the &quot;parallel world&quot; of <a href="https://github.com/clojure/clojurescript">ClojureScript</a>, something very interesting was happening. The first big React wrapper for ClojureScript was <a href="https://github.com/omcljs/om">Om</a>, and it featured an intriguing <em>centralized state</em> concept.</p>
<p>It was new for me, and the first thing I and a lot of people thought was, <em>but isn&#39;t anything global really bad? Especially global state???</em> Now, months later, the centralized state concept is proving itself very powerful and simple, especially with libraries such as <a href="https://github.com/Yomguithereal/baobab">Baobab</a>, and, in particluar, <a href="http://rackt.org/redux/">Redux</a> becoming the new standard. (<a href="https://github.com/moreartyjs/moreartyjs">Morearty</a> seems to have been the first, but didn&#39;t gain as much traction as the others).</p>
<p>In the last year I&#39;ve studied and implemented projects with some of these frameworks, and even implemented a centralized state from scratch a couple of times. In this post, I will talk about the two design patterns you&#39;ll probably come across when working with a centralized state.</p>
<h2 id="update-listeners">Update Listeners</h2>
<p>I call the first design pattern the <em>Update Listeners</em> pattern. This pattern is used by the <a href="https://reagent-project.github.io/">Reagent</a> framework, and by <a href="https://github.com/Yomguithereal/baobab">Baobab</a> in the javascript world. I&#39;ve <a href="http://lucasmreis.github.io/blog/a-more-functional-approach-to-angular/">written about this before</a>, and it&#39;s the pattern I use in my daily work.</p>
<p>The application state resides in a single tree object. Different UI components can <em>listen</em> to updates on different nodes of the tree, and the component is re-rendered every time that node is updated.</p>
<p><img src="../assets/update-listeners.jpg" alt="Update Listeners Illustration"></p>
<p><strong>PROS:</strong> The main benefit of this pattern is that once the listeners are setup, the components are rendered automatically when the state is updated. That means that the UI is always reflecting the current state.</p>
<p>In terms of architecture, it&#39;s also a very interesting pattern because it makes it very clear which information from the state is being used in each visual component of the application.</p>
<p>Another <em>pro</em> is that the parent component does not need to have all the information that the child component needs to be rendered. This means that if I have a &quot;post&quot; component with &quot;comments&quot; child components, I only need to pass the comments&#39; IDs to each component. They themselves will gather the necessary information to be rendered using the listeners.</p>
<p><strong>CONS:</strong> Because of the code for the listeners, the components make assumptions about the how the state object works, and how the information itself is structured.</p>
<p>The <a href="https://github.com/Yomguithereal/baobab-react">baobab-react</a> project illustrates some of the ways that components can properly listen to changes in the main tree, and you can see how the components become dependent on the implementation of the application state object.</p>
<p>Because of this, the code of the components is not very generic, nor is it reusable, and the code of the application as a whole gets very tied to the library or framework used to handle the state.</p>
<h2 id="manual-render">Manual Render</h2>
<p>This pattern is used by the <a href="https://github.com/levand/quiescent">Quiescent</a> framework, and I also used it when I wrote about <a href="http://lucasmreis.github.io/blog/using-csp-as-application-architecture/">CSP as an application architecture</a>.</p>
<p>The application state resides in a simple data structure, usually a javascript object. The whole UI is a function that accepts this state object as a parameter and renders it. The developer calls the function &quot;manually&quot;; in other words, the UI does <em>not</em> react to changes in the application state.</p>
<p><img src="../assets/manual-render.jpg" alt="Manual Render Illustration"></p>
<p><strong>PROS:</strong> The first immediate benefit is that the majority of your components will be <em>stateless</em>. That means they will be easier to reason about, and it&#39;s going to be easier to reuse them in different contexts and even different applications.</p>
<p>Also, having more control over when rendering takes place can make rendering itself more effective and performant. A common way of dealing with this is taking advantage of <code>requestAnimationFrame</code> so there are no unecessary calls to <code>React.render</code> (as I have done <a href="http://lucasmreis.github.io/blog/using-csp-as-application-architecture/">here</a>).</p>
<p><strong>CONS:</strong> One con of working with stateless components is that you have to pass every single piece of information and every callback to the components, every time you use them. This can lead to more confusing code than simple <code>&lt;UserProfile id={userId} /&gt;</code>.</p>
<p>Not only that, if a stateless component needs a different piece of data, let&#39;s say the user&#39;s profile picture url, <em>the container component will have to pass this new piece of data</em>. Sometimes this can lead to multiple components needing to change because of one small change in a child component.</p>
<p>Another common and important problem is, now that rendering is manual, we could forget to fire the render function, which would put our UI out of sync with the application state.</p>
<h2 id="conclusions">Conclusions</h2>
<p>First question is: which one is better? From my personal experience, the <em>Update Listeners</em> pattern really saved our lives once :) We had a big Angular application, with state distributed all over the code, and every new feature added a lot of complexity to it. Now it&#39;s much simpler and easier to both add new features and debug the code.</p>
<p>On the other hand, we&#39;re thinking of rewriting/refactoring four other applications. React is being considered as the view framework, and we want components to be as shareable as possible. So, all the components receive data and callbacks as props, and make no assumptions on how the application is handling state. For this situation, the <em>Manual Render</em> seems like a better approach.</p>
<p>It&#39;s the usual but true conclusion: both design patterns have strengths and weaknesses, and each will work well depending on the situation.</p>
<h2 id="last-thoughts">Last Thoughts</h2>
<p>Not all state may belong to the centralized state tree. Animation state, for instance, seems to be better stored locally, in a React component&#39;s <code>state</code>. I&#39;m still trying to figure out how to better deal with these situations, and where they would fit in these patterns.</p>
<p>This categorization is a work in progress. If you have seen centralized state being used in a different way, or have any other &quot;pros&quot; and &quot;cons&quot;, please feel free to share! Any disagreement with the &quot;pros&quot; and &quot;cons&quot; listed here? I would love to hear from you! :)</p>

        <div class="signature">January 12, 2016.</div>
      </div>

      <!-- DISQUS -->
      <div id="disqus_thread"></div>
      <script type="text/javascript">
          /* * * CONFIGURATION VARIABLES * * */
          var disqus_shortname = 'lucasmreis';
          var disqus_identifier = 'centralized-state-design-patterns';
          var disqus_title = 'Centralized State Design Patterns';

          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

      <footer>
        by Lucas Reis | <a href="https://twitter.com/iamlucasmreis">Twitter</a> | <a href="https://github.com/lucasmreis">GitHub</a> | <a href="https://www.linkedin.com/profile/view?id=133974663">LinkedIn</a>
      </footer>
    </div>

    <!-- GOOGLE ANALYTICS -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-60280937-1', 'auto');
      ga('send', 'pageview');
    </script>

  </body>
</html>