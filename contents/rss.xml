<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[Lucas Reis' Blog]]></title>
        <description><![CDATA[In this blog, I'll write about some of the things that I have found useful and helpful to my programming.]]></description>
        <link>http://lucasmreis.github.io/blog/</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Sat, 29 Dec 2018 16:09:19 GMT</lastBuildDate>
        <atom:link href="http://lucasmreis.github.io/blog/rss.xml" rel="self" type="application/rss+xml"/>
        <language><![CDATA[English]]></language>
        <managingEditor><![CDATA[Lucas Reis]]></managingEditor>
        <webMaster><![CDATA[Lucas Reis]]></webMaster>
        <item>
            <title><![CDATA[Better UIs With State Machines Talk]]></title>
            <description><![CDATA[<p>In my <a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">quest</a> for <a href="http://lucasmreis.github.io/blog/from-elm-to-fable/">correctness</a>, <a href="http://lucasmreis.github.io/blog/learning-reasonml-part-1/">reliability</a>, and <a href="http://lucasmreis.github.io/blog/the-single-most-important-driver-of-software-quality/">safety</a> in software design, I&#39;ve recently come accross State Machines, more specifically Statecharts. In this talk I explain benefits of planning your code, using Statecharts as a tool, and integrating them with your React code.</p>
<div style="text-align: center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/p_md9SZEKV8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>]]></description>
            <guid isPermaLink="false">Better UIs With State Machines Talk</guid>
            <pubDate>Tue, 04 Sep 2018 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Simple React Patterns Talk]]></title>
            <description><![CDATA[<p>This talk is based on the <a href="https://news.ycombinator.com/item?id=15667778">popular</a> <a href="http://lucasmreis.github.io/blog/simple-react-patterns/">blog post</a> on React patterns. </p>
<p>Fun fact: it&#39;s also my first talk in English :)</p>
<p><strong>UPDATE December, 2018</strong>: React is changing a lot, with interesting features like the new Context and Hooks. I plan to update on those patterns in 2019, but not before some production use, so I can <em>really</em> understand what is useful and what is not!</p>
<div style="text-align: center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/N1yqq9Az_XY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>]]></description>
            <guid isPermaLink="false">Simple React Patterns Talk</guid>
            <pubDate>Sun, 17 Jun 2018 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Simple React Patterns Episode]]></title>
            <description><![CDATA[<p>After the <a href="http://lucasmreis.github.io/blog/simple-react-patterns/">React patterns blog post</a> got a lot of attention, I was invited to React Round Up podcast as a guest. It&#39;s a very interesting conversation, and we go through all the patterns listed in the post!</p>
<p>Fun fact: Charles Max Wood, the podcast presenter, invited me to be a panelist after this episode :) </p>
<p>Link to the podcast: <a href="https://devchat.tv/react-round-up/rru-011-simple-react-patterns-with-lucas-reis/">https://devchat.tv/react-round-up/rru-011-simple-react-patterns-with-lucas-reis/</a></p>
]]></description>
            <guid isPermaLink="false">Simple React Patterns Episode</guid>
            <pubDate>Tue, 15 May 2018 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Learning ReasonML, part 3]]></title>
            <description><![CDATA[<p>In the <a href="http://lucasmreis.github.io/blog/learning-reasonml-part-2/">last part of this series,</a> we wrote some simple React components with ReasonML. In this third part, we&#39;re going to write a component that not only has state, but also <em>generates side effects</em> through fetching an external API.</p>
<h2 id="modelling-user-actions">Modelling User Actions</h2>
<p>This is the <a href="https://github.com/lucasmreis/learning-reasonml/blob/master/part-2/src/App.js">application&#39;s main module</a>, which contains the side effects:</p>
<pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  componentDidMount() {
    <span class="hljs-comment">// fetch API to create deck</span>
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"App"</span>&gt;</span>
        {this.renderMainAction()}
        {this.renderCards()}
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }

  renderMainAction() {
    <span class="hljs-comment">// render button</span>
    <span class="hljs-comment">// disable it depending on current state</span>
  }

  renderCards() {
    <span class="hljs-comment">// render list of cards</span>
  }

  draw = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// fetch API do draw cards</span>
    <span class="hljs-comment">// pass as a callback to the main action button</span>
}</code></pre>

<p>We can see that there are two main actions that trigger side effects: creating a deck on mounting, and drawing new cards on button click. Remember that side effects of this nature - fetching something from a network - have to take into account that things can get <em>slow</em> and they can <em>fail</em>. Having said that, we usually model actions with side effects as <em>three different</em> actions:</p>
<pre><code class="hljs js">type action =
  <span class="hljs-comment">/* Create Deck */</span>
  | CreateDeck
  | DeckCreated(deck)
  | CreateDeckFailed
  <span class="hljs-comment">/* Draw Cards */</span>
  | DrawCards(deck)
  | CardsDrawn(deck)
  | DrawCardsFailed
  | DeckFinished(list(card));</code></pre>

<p>I added a <code>DeckFinished</code> action so our application can transition to a finished state that only shows the cards, and do not show the action button anymore.</p>
<p>Some actions have data related to them: <code>deck</code> and <code>list(cards)</code>. These types are related to the action state, and are inspired by the API response:</p>
<pre><code class="hljs js">type card = {
  image: string,
  code: string
};

type deck = {
  deckId: string,
  remaining: int,
  cards: list(card)
};</code></pre>

<p>The <code>deckId</code> info is used to draw cards from the same deck that was created in the beginning of the application lifecycle. <code>remaining</code> is the information we use to decide if we already drew all the cards. For instance, we check <code>remaining</code> to decide if we issue a <code>CardsDrawn</code> action or <code>DeckFinished</code>.</p>
<p><strong>Note:</strong> I like to follow this <code>CQRS</code> convention of <a href="http://cqrs.nu/Faq">writing events in the past tense, and commands in the imperative</a>. In summary, it means that an action that&#39;s written in the imperative will <em>trigger</em> a side effect, and its results are unknown. And actions that are written in the past tense are actions that will trigger a deterministic state change when they happen - there are no unknowns regarding events.</p>
<p><strong>Note 2:</strong> The <code>*Failed</code> actions are not carrying any data with them - that&#39;s because this simple app is just showing a generic message when an error occurs. This isn&#39;t what we would do in a large scale app!</p>
<h2 id="modelling-the-application-state">Modelling The Application State</h2>
<p>Depending on the actions issued, our application will be in a different state:</p>
<p><img src="../assets/learning-reasonml-state-chart.png" alt="State Chart"></p>
<p>The states can then be represented by:</p>
<pre><code class="hljs js">type state =
  | CreatingDeck
  | WaitingForUser(deck)
  | DrawingCards(deck)
  | NoMoreCardsToDraw(list(card))
  | <span class="hljs-built_in">Error</span>;</code></pre>

<p>Now let&#39;s write the function that, given an action and the previous state, returns a data structure of the type <code>ReasonReact.update</code>. You can think of the update type as either a &quot;new state&quot; or &quot;new state + function that perform side effects&quot;. This function will be used as the <code>reducer</code> field in our component:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> reducer = (action, _state) =&gt;
  <span class="hljs-keyword">switch</span> action {
  | CreateDeck =&gt;
    ReasonReact.UpdateWithSideEffects(CreatingDeck, createDeckSideEffects)
  | DeckCreated(deck) =&gt; ReasonReact.Update(WaitingForUser(deck))
  | CreateDeckFailed =&gt; ReasonReact.Update(<span class="hljs-built_in">Error</span>)
  | DrawCards(stateDeck) =&gt;
    ReasonReact.UpdateWithSideEffects(
      DrawingCards(stateDeck),
      drawCardsSideEffects(stateDeck)
    )
  | CardsDrawn(deck) =&gt; ReasonReact.Update(WaitingForUser(deck))
  | DrawCardsFailed =&gt; ReasonReact.Update(<span class="hljs-built_in">Error</span>)
  | DeckFinished(cards) =&gt; ReasonReact.Update(NoMoreCardsToDraw(cards))
  };</code></pre>

<p>This function is simple. You can see that every event returned a <code>ReasonReact.Update</code> with a new state, and every command returned a <code>ReasonReact.UpdateWithSideEffects</code> with a new state and another function that will trigger side effects. Let&#39;s have a look at those functions now.</p>
<h2 id="side-effects">Side Effects</h2>
<p>Let&#39;s start writing the <code>createDeckSideEffects</code> function. ReasonReact&#39;s side-effect functions receive the components <code>self</code> as the parameter, and need to return <code>unit</code>. This is what the function should do:</p>
<ul>
<li>Fetch the API to create a deck</li>
<li>Decode the API response to a <code>deck</code> type</li>
<li>Dispatch a <code>DeckCreated(deck)</code> action with the decoded deck</li>
<li>If there is an error, dispatch a <code>CreateDeckFailed</code> action</li>
</ul>
<p>We&#39;re going to use the <code>bs-fetch</code> <a href="https://github.com/reasonml-community/bs-fetch">package</a>. After installing it, let&#39;s use it to fetch the API:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> createDeckSideEffects = () =&gt;
  Fetch.fetch(<span class="hljs-string">"https://deckofcardsapi.com/api/deck/new/shuffle/"</span>);</code></pre>

<p>The <code>fetch</code> function returns a Promise. We can use the native <code>Js.Promise</code> module to deal with the response:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> createDeckSideEffects = () =&gt;
  Fetch.fetch(<span class="hljs-string">"https://deckofcardsapi.com/api/deck/new/shuffle/"</span>)
  |&gt; Js.Promise.then_(Fetch.Response.json);</code></pre>

<p>Ok, now the function has the signature <code>unit =&gt; Js.Promise.t(Js.Json.t)</code>. We&#39;re almost there - we just need to decode the json object to a <code>deck</code> record. Let&#39;s use the <code>@glennsl/bs-json</code> <a href="https://github.com/glennsl/bs-json">package</a>:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> decodeCreatedDeck = json =&gt; {
  deckId: json |&gt; Json.Decode.field(<span class="hljs-string">"deck_id"</span>, Json.Decode.string),
  remaining: json |&gt; Json.Decode.field(<span class="hljs-string">"remaining"</span>, Json.Decode.int),
  cards: []
};

<span class="hljs-keyword">let</span> createDeckSideEffects = () =&gt;
  Fetch.fetch(<span class="hljs-string">"https://deckofcardsapi.com/api/deck/new/shuffle/"</span>)
  |&gt; Js.Promise.then_(Fetch.Response.json)
  |&gt; Js.Promise.then_(json =&gt; decodeCreatedDeck(json) |&gt; Js.Promise.resolve);</code></pre>

<p>The <code>Json.Decode</code> functions are straightforward: they try to find the property in the json input object, and then try to convert it to the given type. If they fail, they raise an exception. We&#39;re hard coding cards as <code>[]</code> because we know that no cards are drawn when the deck is created.</p>
<p><strong>Note:</strong> If you&#39;re used to Elm, that sounds weird - we would use <a href="https://reasonml.github.io/docs/en/variant.html#option">option types</a> everywhere, and take care of the errors explicitly, near the functions calls. That is probably the safest, most explicit choice. If we&#39;re dealing with exceptions, be careful, since they are implicit, and it&#39;s easy to forget to deal with them properly. In a React application, that usually means you should at least have an <a href="https://reactjs.org/docs/error-boundaries.html">error boundary component</a> catching them.</p>
<p>Back to our functions, they are too verbose. Let&#39;s solve this. We can actually say &quot;I&#39;m going to use functions from this module in this piece of code&quot; in ReasonML, in a couple of ways, and this makes our code less verbose. One good technique is using the <code>open</code> keyword, and letting the formatter do its work. For example, rewrite the <code>decodeCreateDeck</code> as:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> decodeCreatedDeck = json =&gt; {
  open Json.Decode;
  {
    deckId: json |&gt; field(<span class="hljs-string">"deck_id"</span>, string),
    remaining: json |&gt; field(<span class="hljs-string">"remaining"</span>, int),
    cards: []
  };
};</code></pre>

<p>We&#39;re telling the compiler that, in the scope, we&#39;re going to call functions inside the <code>Json.Decode</code> module. We can now call <code>field</code>, <code>string</code>, and <code>int</code> directly. That&#39;s the <a href="https://en.wikibooks.org/wiki/F_Sharp_Programming/Modules_and_Namespaces">standard way to use a module in F#</a>. After saving the file, the formatter changes it to:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> decodeCreatedDeck = json =&gt;
  Json.Decode.{
    deckId: json |&gt; field(<span class="hljs-string">"deck_id"</span>, string),
    remaining: json |&gt; field(<span class="hljs-string">"remaining"</span>, int),
    cards: []
  };</code></pre>

<p>This means &quot;you can use functions from this module when defining this record&quot;. I don&#39;t believe this syntax is better all the time, but fortunately there&#39;s a <a href="https://github.com/facebook/reason/pull/1826">PR open to not reformat &quot;open&quot; statements</a>.</p>
<p>We can also open the Js.Promise module in <code>createDeckSideEffects</code>:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> createDeckSideEffects = () =&gt;
  Js.Promise.(
    Fetch.fetch(<span class="hljs-string">"https://deckofcardsapi.com/api/deck/new/shuffle/"</span>)
    |&gt; then_(Fetch.Response.json)
    |&gt; then_(json =&gt; decodeCreatedDeck(json) |&gt; resolve)
  );</code></pre>

<p>We&#39;re doing good now. Our function is almost there, now we need to wrap <code>deck</code> into a <code>DeckCreated</code> action, and <code>self.send</code> it:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> createDeckSideEffects = self =&gt;
  Js.Promise.(
    Fetch.fetch(<span class="hljs-string">"https://deckofcardsapi.com/api/deck/new/shuffle/"</span>)
    |&gt; then_(Fetch.Response.json)
    |&gt; then_(json =&gt; decodeCreatedDeck(json) |&gt; resolve)
    |&gt; then_(deck =&gt; DeckCreated(deck) |&gt; self.send |&gt; resolve)
  );</code></pre>

<p>There&#39;s a problem here - the compiler is complaining that there&#39;s no <code>send</code> field defined in <code>self</code>. We need to open the ReasonReact module here too, so the compiler understands this function is going to be used in a React component:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> createDeckSideEffects = self =&gt;
  ReasonReact.(
    Js.Promise.(
      Fetch.fetch(<span class="hljs-string">"https://deckofcardsapi.com/api/deck/new/shuffle/"</span>)
      |&gt; then_(Fetch.Response.json)
      |&gt; then_(json =&gt; decodeCreatedDeck(json) |&gt; resolve)
      |&gt; then_(deck =&gt; DeckCreated(deck) |&gt; self.send |&gt; resolve)
    )
  );</code></pre>

<p>Now our code is compiling (as an observation: this is a situation where I think the &quot;open&quot; keyword would lead to better code). One interesting observation is that the functions inside <code>then_</code> need to return a Promise, so that&#39;s why there&#39;s a <code>|&gt; resolve</code> in every callback. Javascript&#39;s <code>.then</code> does some extra work, so you don&#39;t need to do that, but I believe that in a strongly typed situation it&#39;s best to stick to simpler constraints.</p>
<p>We&#39;re fetching the API, decoding the response, and sending an action as a result. We only need to deal with a possible error, and make sure our function returns <code>unit</code> so it&#39;s accepted in the <code>reducer</code> function we wrote before:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> createDeckSideEffects = self =&gt;
  ReasonReact.(
    Js.Promise.(
      Fetch.fetch(<span class="hljs-string">"https://deckofcardsapi.com/api/deck/new/shuffle/"</span>)
      |&gt; then_(Fetch.Response.json)
      |&gt; then_(json =&gt; decodeCreatedDeck(json) |&gt; resolve)
      |&gt; then_(deck =&gt; DeckCreated(deck) |&gt; self.send |&gt; resolve)
      |&gt; <span class="hljs-keyword">catch</span>(_error =&gt; self.send(CreateDeckFailed) |&gt; resolve)
      |&gt; ignore
    )
  );</code></pre>

<p>And we&#39;re done! The next side-effects function is more complicated, but we have the knowledge to understand it now:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> decodeCard = json =&gt;
  Json.Decode.{
    code: json |&gt; field(<span class="hljs-string">"code"</span>, string),
    image: json |&gt; field(<span class="hljs-string">"image"</span>, string)
  };

<span class="hljs-comment">/* the decodeCard decoder can be used in another
   decoder to deal with nested objects: */</span>
<span class="hljs-keyword">let</span> decodeDeck = json =&gt;
  Json.Decode.{
    deckId: json |&gt; field(<span class="hljs-string">"deck_id"</span>, string),
    remaining: json |&gt; field(<span class="hljs-string">"remaining"</span>, int),
    cards: json |&gt; field(<span class="hljs-string">"cards"</span>, list(decodeCard))
  };

<span class="hljs-comment">/* helper function to decide whether we should dispatch
   a CardsDrawn or a DeckFinished action: */</span>
<span class="hljs-keyword">let</span> drawnOrFinished = (current, received) =&gt;
  <span class="hljs-keyword">if</span> (received.remaining &gt; <span class="hljs-number">0</span>) {
    CardsDrawn({...received, cards: current.cards @ received.cards});
  } <span class="hljs-keyword">else</span> {
    DeckFinished(current.cards);
  };

<span class="hljs-comment">/* the Pervasives module contains the min function. If we
   have less than 3 remaining cards, only draw the
   remaining quantity from the API:   */</span>
<span class="hljs-keyword">let</span> number_of_cards_per_draw = <span class="hljs-number">3</span>;

<span class="hljs-keyword">let</span> drawQuantity = deck =&gt;
  Pervasives.min(deck.remaining, number_of_cards_per_draw) |&gt; Js.Int.toString;

<span class="hljs-keyword">let</span> drawCardsSideEffects = (currentDeck, self) =&gt;
  ReasonReact.(
    Js.Promise.(
      Fetch.fetch(
        <span class="hljs-string">"https://deckofcardsapi.com/api/deck/"</span>
        ++ currentDeck.deckId
        ++ <span class="hljs-string">"/draw/?count="</span>
        ++ drawQuantity(currentDeck)
      )
      |&gt; then_(Fetch.Response.json)
      |&gt; then_(json =&gt; decodeDeck(json) |&gt; resolve)
      |&gt; then_(receivedDeck =&gt;
           drawnOrFinished(currentDeck, receivedDeck) |&gt; self.send |&gt; resolve
         )
      |&gt; ignore
    )
  );</code></pre>

<p>That&#39;s it, now our <code>reducer</code> function compiles! All our side effects are there, now let&#39;s implement the rendering of our main component.</p>
<h2 id="rendering-the-different-states">Rendering The Different States</h2>
<p>Let&#39;s start by defining the render functions for the different states. For example, the loading state:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> renderParagraph = () =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span> (ReasonReact.stringToElement("Loading...")) <span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
)</span>;</code></pre>

<p>As we saw before, we need the <code>stringToElement</code> function to render strings in the DOM. Since our error state is also a simple paragraph, we can reuse some logic:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> renderParagraph = text =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span> (ReasonReact.stringToElement(text)) <span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>;</span>

<span class="hljs-keyword">let</span> renderLoading = () =&gt; renderParagraph(<span class="hljs-string">"Loading..."</span>);

<span class="hljs-keyword">let</span> renderError = () =&gt;
  renderParagraph(<span class="hljs-string">"There was an error. Please refresh and try again!"</span>);</code></pre>

<p>In the <code>NoMoreCardsToDraw(cards)</code> state, we only want to render a given list of cards:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> renderCards = cards =&gt; {
  <span class="hljs-keyword">let</span> cardElements =
    List.map(c =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">CardContainer</span> <span class="hljs-attribute">code</span>=<span class="hljs-value">c.code</span> <span class="hljs-attribute">imageSource</span>=<span class="hljs-value">c.image</span> /&gt;</span>, cards)
    |&gt; Array.of_list
    |&gt; ReasonReact.arrayToElement;
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"App card-list"</span>&gt;</span> cardElements <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span>
};</code></pre>

<p>There&#39;s no &quot;listToElement&quot; function in ReasonReact, so we have to manually convert the list to array with the <code>Array.of_list</code> function.</p>
<p>Up until now we&#39;re good: all the rendering functions only receive a piece of data and render it. The next views are a little bit more complicated: in both <code>WaitingForUser(deck)</code> and <code>DrawingCards(deck)</code> we want to show the cards and the main action button, either in a disabled or enabled state. So let&#39;s build a function that takes a <code>deck</code> record, a <code>send</code> function and a <code>disabledButton</code> boolean as parameters:</p>
<pre><code class="hljs js"><span class="hljs-comment">/* the disableButton parameter is labelled for no
   particular reason, just style */</span>
<span class="hljs-keyword">let</span> renderButtonAndCards = (deck, send, ~disabledButton) =&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"App"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">button</span>
      <span class="hljs-attribute">className</span>=<span class="hljs-value">"App main-action"</span>
      <span class="hljs-attribute">disabled</span>=<span class="hljs-value">(Js.Boolean.to_js_boolean(disabledButton))</span>
      <span class="hljs-attribute">onClick</span>=<span class="hljs-value">(_ev</span> =&gt;</span> send(DrawCards(deck)))&gt;
      (ReasonReact.stringToElement("Draw " ++ drawQuantity(deck)))
    <span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
    (renderCards(deck.cards))
  <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span></code></pre>

<p>Let&#39;s see what&#39;s happening here. First, we need to call <code>Js.Boolean.to_js_boolean</code> for the disabled attribute. Remember, ReasonML represents booleans as numbers, and whenever we interop with JS or the DOM, we need to convert them to proper JS booleans. We&#39;re calling the <code>send</code> function on the button click, with the <code>DrawCards(deck)</code> action, and also reusing our <code>renderCards</code> function we just defined.</p>
<p>Now we can write our main render function:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> render = self =&gt;
  ReasonReact.(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"App"</span>&gt;</span>
      (
        switch self.state {
        | CreatingDeck =&gt; renderLoading()
        | WaitingForUser(deck) =&gt;
          renderButtonAndCards(deck, self.send, ~disabledButton=false)
        | DrawingCards(deck) =&gt;
          renderButtonAndCards(deck, self.send, ~disabledButton=true)
        | NoMoreCardsToDraw(cards) =&gt; renderCards(cards)
        | Error =&gt; renderError()
        }
      )
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  )</span>;</code></pre>

<p>Simple, right? We open the ReasonReact module, so the compiler understands both <code>self.state</code> and <code>self.send</code>. We render a container div, and then we pattern match on the state and call the desired render function.</p>
<h2 id="glueing-the-pieces-together">Glueing The Pieces Together</h2>
<p>It&#39;s simple to construct our component now:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> component = ReasonReact.reducerComponent(<span class="hljs-string">"App"</span>);

<span class="hljs-keyword">let</span> make = _self =&gt; {
  ...component,
  reducer,
  render,
  initialState: () =&gt; CreatingDeck,
  didMount: self =&gt; {
    self.send(CreateDeck);
    ReasonReact.NoUpdate;
  }
};

<span class="hljs-comment">/* wrap it so we don't need to change index.js: */</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword">default</span> = ReasonReact.wrapReasonForJs(~component, _jsProps =&gt; make([||]));</code></pre>

<p>And we&#39;re done! The application is compiling and running. You can see the <a href="https://github.com/lucasmreis/learning-reasonml/blob/integrating_side_effects/part-2/src/App.re">final file here</a>.</p>
<h2 id="conclusions">Conclusions</h2>
<p>Rewriting a React application in ReasonML is an interesting experience. The types and the compiler make you think harder about both the application state and the user actions. <em>You are forced to think better about your design</em>. And this is definitely a good thing; most of the problems we find in software today can be traced to issues not raised properly in <em>design time</em>.</p>
<p>Another interesting (<a href="http://lucasmreis.github.io/blog/learning-elm-part-1/#first-impressions-of-elm">and predictable</a>) effect is how much more <em>reliable</em> the applications seem to be. Even though it still doesn&#39;t have tests, I feel I need <em>fewer</em> tests than if it was only the JS version! A lot of the unit tests in every JS project are actually trying to protect the application from type errors, since <a href="https://rollbar.com/blog/top-10-javascript-errors/">they seem to be the main source of error</a>. So, by using a strong typed language, that&#39;s a whole category of errors that we can be much more confident about.</p>
<p>I&#39;ll definitely continue to look into ReasonML. It gives me the benefits of Elm and F#, and seems closer to the React world that I use in my in my day to day work. Not only do I think it&#39;s easier to integrate with the current mainstream front-end ecossystem, I also believe it presents a greater chance to convince your company to use a different language than JS :)</p>
]]></description>
            <guid isPermaLink="false">Learning ReasonML, part 3</guid>
            <pubDate>Sat, 17 Mar 2018 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Learning ReasonML, part 2]]></title>
            <description><![CDATA[<p>When learning a new language, it&#39;s great to have the opportunity to write a small module and be able to integrate it with a real world application. Fortunately, one of the main objectives of the ReasonML team is smooth JS integration, so let&#39;s see if it delivers!</p>
<h2 id="the-project">The Project</h2>
<p>Let&#39;s start with an existing React application. <a href="https://github.com/lucasmreis/learning-reasonml/tree/master/part-2">Here&#39;s the code</a>, and <a href="https://simple-deck-example.netlify.com/">here&#39;s the working app</a>. The app &quot;creates&quot; a deck of cards using <a href="http://deckofcardsapi.com/">this great open API</a>, and then, the user can draw three cards at a time using a button. The cards are drawn face down, and turn face up when clicked.</p>
<p>This project is interesting because it has some key real world features: global and local state handling, and remote data fetching both on startup and user interaction. In this post I&#39;ll integrate ReasonML code in three different ways: first with a function (the one we <a href="http://lucasmreis.github.io/blog/learning-reasonml-part-1/">wrote in the first part of this series</a>), then with a stateless React component, and finally with a stateful React component.</p>
<h2 id="having-reasonml-files-in-a-js-project">Having ReasonML Files In A JS Project</h2>
<p>We want our workflow to be as simple as possible. I like the idea of creating <code>.re</code> files throughout the project where I need them, and automatically compiling them to <code>.bs.js</code> files in the same location. To achieve that, let&#39;s first install <code>bs-platform</code> to <a href="https://github.com/lucasmreis/learning-reasonml/tree/master/part-2">our react application</a> with npm:</p>
<pre><code class="hljs">$ npm install --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> bs-platform</code></pre>

<p>Then we create <code>bsconfig.json</code> in the root folder:</p>
<pre><code class="hljs json">{
  "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">"simple-deck"</span></span>,
  "<span class="hljs-attribute">version</span>": <span class="hljs-value"><span class="hljs-string">"0.1.0"</span></span>,
  "<span class="hljs-attribute">sources</span>": <span class="hljs-value">[
    {
      "<span class="hljs-attribute">dir</span>": <span class="hljs-value"><span class="hljs-string">"src"</span></span>,
      "<span class="hljs-attribute">subdirs</span>": <span class="hljs-value"><span class="hljs-literal">true</span>
    </span>}
  ]</span>,
  "<span class="hljs-attribute">package-specs</span>": <span class="hljs-value">{
    "<span class="hljs-attribute">module</span>": <span class="hljs-value"><span class="hljs-string">"es6"</span></span>,
    "<span class="hljs-attribute">in-source</span>": <span class="hljs-value"><span class="hljs-literal">true</span>
  </span>}</span>,
  "<span class="hljs-attribute">suffix</span>": <span class="hljs-value"><span class="hljs-string">".bs.js"</span></span>,
  "<span class="hljs-attribute">bs-dependencies</span>": <span class="hljs-value">[]</span>,
  "<span class="hljs-attribute">namespace</span>": <span class="hljs-value"><span class="hljs-literal">true</span></span>,
  "<span class="hljs-attribute">refmt</span>": <span class="hljs-value"><span class="hljs-number">3</span>
</span>}</code></pre>

<p>In this file we&#39;re saying that we should compile every file in the <code>src</code> folder and subfolders. Also, since our project is a <a href="https://github.com/facebook/create-react-app">Create React App</a> project that uses webpack for bundling, we&#39;re compiling to ES6 modules. I found that the official documentation <a href="https://bucklescript.github.io/docs/en/build-configuration.html">has a good section on the config file</a>.</p>
<p>Now we only need to update the npm scripts to take ReasonML into account:</p>
<pre><code class="hljs js">(...)

<span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"start:reason"</span>: <span class="hljs-string">"bsb -make-world -w"</span>,
    <span class="hljs-string">"build"</span>: <span class="hljs-string">"bsb -make-world &amp;&amp; react-scripts build"</span>,

(...)</code></pre>

<p>Open two terminals, run <code>npm start</code> in one of them and <code>npm run start:reason</code> in the other one, and we&#39;re ready to start writing ReasonML in our React project!</p>
<h2 id="integrating-a-function">Integrating A Function</h2>
<p>First, let&#39;s look at the structure of the application:</p>
<ul>
<li>The app follows CRA initial structure: all application code is inside the <code>src</code> folder, and the React setup is in the <code>index.js</code> file.</li>
<li><code>App.js</code> is the main container; it fetches data from the deck API, stores it, and exposes a <code>draw</code> action that fetches three new cards:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// State shape:</span>
<span class="hljs-comment">// { status: 'CREATING_DECK' }</span>
<span class="hljs-comment">// { status: 'WAITING_FOR_USER', deckId, cards: [{ image, code }], remaining }</span>
<span class="hljs-comment">// { status: 'DRAWING_CARDS', deckId, cards, remaining }</span>
<span class="hljs-comment">// { status: 'FINISHED', cards }</span>
<span class="hljs-comment">// { status: 'ERROR' }</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  state = { status: <span class="hljs-string">"CREATING_DECK"</span> };

  componentDidMount() {
    <span class="hljs-comment">// fetch a new deck of cards</span>
    <span class="hljs-comment">// if success, set state to WAITING_FOR_USER</span>
    <span class="hljs-comment">// else set state to ERROR</span>
  }

  draw = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// set state to DRAWING_CARDS</span>
    <span class="hljs-comment">// fetch three new cards</span>
    <span class="hljs-comment">// if success, set state to:</span>
    <span class="hljs-comment">// - WAITING_FOR_USER if there are still remaining cards in the deck</span>
    <span class="hljs-comment">// - FINISHED if there are not</span>
    <span class="hljs-comment">// else set state to ERROR</span>
  };

  render() {
    <span class="hljs-comment">// render action button that triggers the draw action on click</span>
    <span class="hljs-comment">// render collection of Card components</span>
  }
}</code></pre>

<ul>
<li>The Card component is defined in the <code>components/Card/index.js</code> file:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"./Card.css"</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Card</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    flipped: <span class="hljs-literal">true</span>
  };

  flip = () =&gt; {
    <span class="hljs-keyword">this</span>.setState({ flipped: !<span class="hljs-keyword">this</span>.state.flipped });
  };

  render() {
    <span class="hljs-keyword">const</span> { code, imageSource } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">const</span> flippedClass = <span class="hljs-keyword">this</span>.state.flipped ? <span class="hljs-string">"Card flipped"</span> : <span class="hljs-string">"Card"</span>;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">{flippedClass}</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.flip}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"Card front"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">{code}</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">{imageSource}</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"Card back"</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }
}

<span class="hljs-keyword">export</span> { Card };</code></pre>

<p>Each card has a <code>flipped</code> boolean state that is initialized as true. The card is rendered either in a flipped state or normal state using CSS classes. <code>flipped</code> changes when the user clicks the card. Simple, direct React code.</p>
<p>An initial, super low risk place to integrate ReasonML could be the image&#39;s alt attribute. <code>code</code> is a value returned from the Deck API, that looks like &quot;6C&quot;, &quot;QH&quot; or &quot;AD&quot;. In <a href="http://lucasmreis.github.io/blog/learning-reasonml-part-1/">part 1 of our series</a> we implemented a function that transforms a string like this into a complete &quot;Six of Clubs&quot; or &quot;Queen of Hearts&quot;, so let&#39;s use it!</p>
<p>Create a <code>ParseAndRenderCard.re</code> file in the same folder as the Card component, and copy and paste the code into it. If Bucklescript is setup correctly and running, you should already be seeing a <code>ParseAndRenderCard.bs.js</code> file in the same folder (I&#39;m a little bit scared with how fast this compiler is, hehe). I added this to the end of the file to be able to export the function:</p>
<pre><code class="hljs js">(...)

<span class="hljs-keyword">let</span> parseAndRender = cardStr =&gt;
  cardStr
  |&gt; Parser.parseCard
  |&gt; Option.map(RenderToString.renderCard)
  |&gt; Option.withDefault(RenderToString.defaultErrorCard);</code></pre>

<p>And we can see that the end of the compiled file looks something like this:</p>
<pre><code class="hljs js">(...)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseAndRender</span>(<span class="hljs-params">cardStr</span>) </span>{
  <span class="hljs-keyword">return</span> withDefault(defaultErrorCard, map(renderCard, parseCard(cardStr)));
}

<span class="hljs-keyword">export</span> {
  Parser         ,
  RenderToString ,
  Option         ,
  parseAndRender ,
}</code></pre>

<p><code>parseAndRender</code> was exactly what we needed. Now, on the <code>Card/index.js</code> file, import the function and use it:</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> { parseAndRender } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ParseAndRenderCard.bs"</span>;

(...)

render() {
  (...)

    &lt;img alt={parseAndRender(code)} src={imageSource} /&gt;

  (...)
}</code></pre>

<p>And we&#39;re done! That&#39;s it, we added a ReasonML function to our JS app, in three simple steps:</p>
<ol>
<li>Install and setup the Bucklescript/ReasonML compiler</li>
<li>Write a ReasonML function in <code>.re</code> files alongside your js files, and let the compiler generate the <code>.js</code> files</li>
<li>Import the generated JS function into your code</li>
</ol>
<p>ML languages like ReasonML are great for writing intricate logic, so I think that writing functions in them and importing to your React project can already bring benefits. But let&#39;s take it a step further and write a whole stateless component in ReasonML.</p>
<p>The final code for the project with a ReasonML function integration <a href="https://github.com/lucasmreis/learning-reasonml/tree/integrating_function/part-2">can be found here</a>.</p>
<h2 id="integrating-a-stateless-component">Integrating A Stateless Component</h2>
<p>Now let&#39;s create a React component using ReasonML. As always, let&#39;s start simple - I think a stateless component is a good opportunity for that. First of all, we need to refactor our Card component - let&#39;s use the Container / View pattern <a href="http://lucasmreis.github.io/blog/simple-react-patterns/">described in this blog post</a>. Remember the card component:</p>
<pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Card</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    flipped: <span class="hljs-literal">true</span>
  };

  flip = () =&gt; {
    <span class="hljs-keyword">this</span>.setState({ flipped: !<span class="hljs-keyword">this</span>.state.flipped });
  };

  render() {
    <span class="hljs-keyword">const</span> { code, imageSource } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">const</span> flippedClass = <span class="hljs-keyword">this</span>.state.flipped ? <span class="hljs-string">"Card flipped"</span> : <span class="hljs-string">"Card"</span>;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">{flippedClass}</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.flip}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"Card front"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">{parseAndRender(code)}</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">{imageSource}</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"Card back"</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }
}</code></pre> 

<p>The refactor is straightforward:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> CardView = ({ code, imageSource, flipped, onClick }) =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">{flipped</span> ? "<span class="hljs-attribute">Card</span> <span class="hljs-attribute">flipped</span>" <span class="hljs-attribute">:</span> "<span class="hljs-attribute">Card</span>"} <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{onClick}</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"Card front"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">{parseAndRender(code)}</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">{imageSource}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"Card back"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
)</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Card</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    flipped: <span class="hljs-literal">true</span>
  };

  flip = () =&gt; {
    <span class="hljs-keyword">this</span>.setState({ flipped: !<span class="hljs-keyword">this</span>.state.flipped });
  };

  render() {
    <span class="hljs-keyword">const</span> { code, imageSource } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">CardView</span>
        <span class="hljs-attribute">code</span>=<span class="hljs-value">{code}</span>
        <span class="hljs-attribute">imageSource</span>=<span class="hljs-value">{imageSource}</span>
        <span class="hljs-attribute">flipped</span>=<span class="hljs-value">{this.state.flipped}</span>
        <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.flip}</span>
      /&gt;</span>
    )</span>;
  }
}</code></pre>

<p>We&#39;re going to rewrite the CardView component. We&#39;re going to use the <a href="https://reasonml.github.io/reason-react/">ReasonReact</a> wrapper from React, which is the current standard way of writing React in ReasonML. After <code>npm install --save reason-react</code>, change the <code>bsconfig.json</code> file to include these two properties:</p>
<pre><code class="hljs js">{
  (...) 

  <span class="hljs-string">"reason"</span>: { <span class="hljs-string">"react-jsx"</span>: <span class="hljs-number">2</span> },
  <span class="hljs-string">"bs-dependencies"</span>: [<span class="hljs-string">"reason-react"</span>],

  (...)
}</code></pre>

<p>Now we&#39;re ready to start coding. Create a <code>CardView.re</code> file in the Card folder, and copy this code into it:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> component = ReasonReact.statelessComponent(<span class="hljs-string">"CardView"</span>);

<span class="hljs-keyword">let</span> make = (~code, ~imageSource, ~flipped, ~onClick, _children) =&gt; {
  ...component,
  render: _self =&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">(flipped</span> ? "<span class="hljs-attribute">Card</span> <span class="hljs-attribute">flipped</span>" <span class="hljs-attribute">:</span> "<span class="hljs-attribute">Card</span>") <span class="hljs-attribute">onClick</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"Card front"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">(ParseAndRenderCard.parseAndRender(code))</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">imageSource</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"Card back"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
};</span></code></pre>

<p>Let me explain what&#39;s going on here. Every component in ReasonReact is defined by a <code>make</code> function. This function receives props and children as input, and returns a record. In our case, we created a &quot;base&quot; stateless record with the <code>statelessComponent</code> function, and our <code>make</code> function returns it with the <code>render</code> field being overriden.</p>
<p>It feels a little bit like a regular javascript React component, with some interesting differences:</p>
<ul>
<li>The components props are defined as <a href="https://reasonml.github.io/docs/en/function.html">labeled parameters</a></li>
<li>The <code>_</code> prefix was used as a convention for unused parameters</li>
<li>We don&#39;t need to enclose the passed props in <code>{</code> and <code>}</code>. Example: <code>src=imageSource</code></li>
<li>We can use shorthand names for props. Example: <code>onClick</code> in the first <code>div</code></li>
</ul>
<p>The rest feels pretty similar to Javascript, with the benefits of Ocaml&#39;s strong type. Sweet!</p>
<p>This is all we would need if we were using this component inside ReasonML. But since we&#39;re going to call it inside a regular javascript React component, we need to have an extra step. ReasonReact has a <code>wrapReasonForJs</code> function that serves this purpose:</p>
<pre><code class="hljs js">let default =
  ReasonReact.wrapReasonForJs(~component, jsProps =&gt;
    make(
      ~code=jsProps##code,
      ~imageSource=jsProps##imageSource,
      ~flipped=Js.to_bool(jsProps##flipped),
      ~onClick=jsProps##onClick,
      [||]
    )
);</code></pre> 

<p>The <code>wrapReasonForJs</code> function receives a component as a parameter, and a function that maps those dynamic js props to ReasonML typed props. The component should be the base one we used in our make function. The function should call make itself, with the transformed props that were passed to the component in JS. Some comments on it:</p>
<ul>
<li><code>~component</code> is a shorthand for <code>~component=component</code></li>
<li><code>##</code> is the way to get the value of a property in a regular JS object. So <code>jsProps##code</code> is compiled to <code>jsProps.code</code></li>
<li>Boolean ReasonML types are <em>not</em> represented as <code>true</code> or <code>false</code> in Javascript! That&#39;s why we need to use <code>Js.to_bool</code> to convert <code>jsProps##flipped</code></li>
<li>Arrays are represented by <code>[|</code> and <code>|]</code> in ReasonML. If we use <code>[</code> and <code>]</code>, we&#39;re actually creating a <em>list</em>. The <a href="https://reasonml.github.io/docs/en/list-and-array.html">docs explain the difference well</a>, and I suggest you play a little with both in <a href="https://reasonml.github.io/en/try.html">Try Reason</a> to see the differences in the compiled code!</li>
</ul>
<p>Now we can go to our <code>Card/index.html</code> file, erase the previous CardView component, and use our brand new ReasonML one:</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"./Card.css"</span>;
<span class="hljs-keyword">import</span> CardView <span class="hljs-keyword">from</span> <span class="hljs-string">"./CardView.bs"</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Card</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    flipped: <span class="hljs-literal">true</span>
  };

  flip = () =&gt; {
    <span class="hljs-keyword">this</span>.setState({ flipped: !<span class="hljs-keyword">this</span>.state.flipped });
  };

  render() {
    <span class="hljs-keyword">const</span> { code, imageSource } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">CardView</span>
        <span class="hljs-attribute">code</span>=<span class="hljs-value">{code}</span>
        <span class="hljs-attribute">imageSource</span>=<span class="hljs-value">{imageSource}</span>
        <span class="hljs-attribute">flipped</span>=<span class="hljs-value">{this.state.flipped}</span>
        <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.flip}</span>
      /&gt;</span>
    )</span>;
  }
}

<span class="hljs-keyword">export</span> { Card };</code></pre>

<p>And that&#39;s it - our application should be running flawlessly with the new code!</p>
<h2 id="integrating-a-stateful-component">Integrating A Stateful Component</h2>
<p>Stateful components in ReasonReact are interesting - we define the way state is updated by defining actions and a reducer. Sounds familiar, right? Yes, there&#39;s a mini-redux in every component :) It&#39;s a great pattern, and feels even better with the compiler help from the strong types.</p>
<p>Our stateful component is simple: our cards start out face down, and if a user clicks one of them, they&#39;re flipped over. So let&#39;s start by creating a <code>CardContainer.re</code> file alongside <code>CardView.re</code>, and describe our action and our state:</p>
<pre><code class="hljs js">type action =
  | Flip;

type state = {flipped: bool};</code></pre>

<p>Our action is usually defined as a <a href="https://reasonml.github.io/docs/en/variant.html">Variant</a>. In our case, the only action the user can take is flipping a card, so we only have the one case <code>Flip</code>. Our state is going to be a record with a single boolean field, that represents a card being flipped or not. </p>
<p>Now we can define our component. Remember, first we create a base component record, and then a make function. For stateful components we use <code>ReasonReact.reducerComponent</code> base and we need to override not only <code>render</code>, but also <code>initialState</code> and <code>reducer</code>:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> component = ReasonReact.reducerComponent(<span class="hljs-string">"CardContainer"</span>);

<span class="hljs-keyword">let</span> make = (~code, ~imageSource, _self) =&gt; {
  ...component,
  initialState: () =&gt; {flipped: <span class="hljs-literal">true</span>},
  reducer: (_action, state) =&gt; ReasonReact.Update({flipped: ! state.flipped}),
  render: self =&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">CardView</span>
      <span class="hljs-attribute">code</span>
      <span class="hljs-attribute">imageSource</span>
      <span class="hljs-attribute">flipped</span>=<span class="hljs-value">self.state.flipped</span>
      <span class="hljs-attribute">onClick</span>=<span class="hljs-value">(_event</span> =&gt;</span> self.send(Flip))
    /&gt;
};</span></code></pre>

<p><code>initialState</code> is a simple function that returns a record of the type <code>state</code>. In our case, our cards start flipped. </p>
<p><code>reducer</code> is a function that takes an action and the current state, and returns a value of the <code>ReasonReact.update</code> variant type. We&#39;re returning the <code>ReasonReact.Update(state)</code> case, which results in a simple state update without side effects, which is what we want to happen when the user flips a card. We&#39;ll talk more about the <code>ReasonReact.update</code> type in the next part of this series!</p>
<p>The last part of this component is the callback defined for <code>onClick</code>. We&#39;re using <code>self.send</code>, which in fact &quot;sends&quot; the <code>Flip</code> action to the reducer. And our component is complete!</p>
<p>See that our render function is making reference to <code>CardView</code>. Since we&#39;re in ReasonML land, we do not need a wrapper for the card view anymore, so we can delete it from the <code>CardView</code> file. But since the card container will be imported in JS, we need to wrap it instead:</p>
<pre><code class="hljs js">let default =
  ReasonReact.wrapReasonForJs(~component, jsProps =&gt;
    make(~code=jsProps##code, ~imageSource=jsProps##imageSource, [||])
  );</code></pre>

<p>That&#39;s all we need. The whole file should look like this now:</p>
<pre><code class="hljs js">type action =
  | Flip;

type state = {flipped: bool};

<span class="hljs-keyword">let</span> component = ReasonReact.reducerComponent(<span class="hljs-string">"CardContainer"</span>);

<span class="hljs-keyword">let</span> make = (~code, ~imageSource, _self) =&gt; {
  ...component,
  initialState: () =&gt; {flipped: <span class="hljs-literal">true</span>},
  reducer: (_action, state) =&gt; ReasonReact.Update({flipped: ! state.flipped}),
  render: self =&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">CardView</span>
      <span class="hljs-attribute">code</span>
      <span class="hljs-attribute">imageSource</span>
      <span class="hljs-attribute">flipped</span>=<span class="hljs-value">self.state.flipped</span>
      <span class="hljs-attribute">onClick</span>=<span class="hljs-value">(_event</span> =&gt;</span> self.send(Flip))
    /&gt;
};

let default =
  ReasonReact.wrapReasonForJs(~component, jsProps =&gt;
    make(~code=jsProps##code, ~imageSource=jsProps##imageSource, [||])
  );</span></code></pre>

<p>Now we can import this component directly into our <code>Card/index.js</code> file:</p>
<pre><code class="hljs js"><span class="hljs-comment">// Card/index.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">"./Card.css"</span>;
<span class="hljs-keyword">import</span> CardContainer <span class="hljs-keyword">from</span> <span class="hljs-string">"./CardContainer.bs"</span>;

<span class="hljs-keyword">export</span> { CardContainer <span class="hljs-keyword">as</span> Card };</code></pre>

<p>If you prefer, instead of importing the CSS file here, you could add a <code>[%%raw &quot;import &#39;./Card.css&#39;&quot;];</code> line at the beginning of the <code>CardView.re</code> file, with the same effect.</p>
<p>The final code for the integration with the stateful component <a href="https://github.com/lucasmreis/learning-reasonml/tree/integrating_stateful_2/part-2">can be found here</a>.</p>
<h2 id="conclusions">Conclusions</h2>
<p>That&#39;s the third strong typed language I&#39;ve used for front end programming, after Elm and F#. First of all, it confirms my feeling that <em>this is the way to go</em>. Javascript&#39;s dynamic nature gives you a lot of power, but when we&#39;re writing larger and larger applications, these types give you a much saner environment. Refactoring does not feel so scary, tooling helps you much more, things are better documented, and so on.</p>
<p>Now, comparing ReasonML to the other two languages. Elm&#39;s architecture (shared by F# within the <a href="https://fable-elmish.github.io/elmish/">Fable-Elmish framework</a>) is really simple and powerful. It has influenced the entire front end world, and ReasonReact&#39;s reducer components were definitely inspired by it. In Elm, state and action handling is done separately from the visual components, in kind of a &quot;global&quot; way. In contrast, ReasonReact embraces the React way of doing things, which is the &quot;everything is a component&quot; mentality. The interesting part is: the reducer components feel a lot like Elm, so in practice, a ReasonReact application feels like composing small Elm applications! By doing that, it&#39;s also pretty easy to not only integrate your ReasonML code into your React application, but it&#39;s also relatively easy to get all the benefits from modern tooling, like code splitting and dynamically importing components. This and the fact that the generated JS code is really well optimized are the great benefits of ReasonML over the other two.</p>
<p>Where do Elm and F# perform better than ReasonML? Elm is still the safer option out there, due to the stricter JS integration. It&#39;s much, much easier to avoid runtime errors with Elm. Also, it has great docs and well thought out standard libraries. F# has the benefit that it can be used both on the frontend and backend of your application, and you can have access to a lot of the .Net features with it. And, as a personal note, I understand the decision to make ReasonML&#39;s syntax more &quot;javascript-like&quot;, but I feel both Elm&#39;s and F#&#39;s syntax are way better and more pleasurable to work with.</p>
<h2 id="next-steps">Next Steps</h2>
<p>In the third part of this series I&#39;ll try to <a href="https://github.com/lucasmreis/learning-reasonml/blob/master/part-2/src/App.js">rewrite <code>App.js</code> with ReasonReact</a>! Let&#39;s see how the language feels when we need to perform side effects, work with JSON data, and do some async work. See you there!</p>
]]></description>
            <guid isPermaLink="false">Learning ReasonML, part 2</guid>
            <pubDate>Thu, 18 Jan 2018 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Learning ReasonML, part 1]]></title>
            <description><![CDATA[<p>Throughout my professional life, I&#39;ve worked on a lot of large applications that were in production for years. There was one thing in common with all of them: a lot of the code was overly complex, and it was difficult to fix bugs and add new features.</p>
<p>While searching for solutions to these problems, I found out that different programming languages&#39; patterns and practices are terrific sources of inspiration. Learning Clojure helped me understand the benefits of immutability. Learning Elm helped me understand the benefits of strong typing. Not only that, a lot of the javascript ecosystem itself is <a href="https://redux.js.org/docs/introduction/PriorArt.html">based on other languages&#39; patterns and practices</a>. All of that knowledge made my javascript code better and helped me to be a better developer.</p>
<p>And that brings me to ReasonML. My path to ReasonML was paved this way:</p>
<p>First, I turned to ClojureScript because of the immutability / pragmatic philosophy / simplicity it has as it&#39;s core. But, some problems related to reliability and safety were still present, and I thought that strong typing could help.</p>
<p>Second, came Elm. Yes, strong typing does help and working with such a powerful compiler feels great, but I missed the pragmatic nature of Clojure.</p>
<p>Thirdly, I turned to F# / Fable, which feels like a sweet spot. A pragmatic Elm for the front end, and a complete ecosystem with a mature runtime for everything else. But, Fable is a tool seems to be made for people with a F# / .Net background, not a javascript background.</p>
<p>And that&#39;s how I got to ReasonML. It&#39;s a new syntax for Ocaml, which F# is heavily based on. They are from a family of languages called &quot;ML&quot;, which provide a nice developing experience resulting from its type system and compiler features. Also, the language creators are heavily targeting javascript developers, so they are working hard to make the language easily adoptable by current javascript teams.</p>
<p><em>Note:</em> I&#39;m a curious person and an avid learner. I&#39;m always looking for a new way to look at the problems I face in my day to day life, so I don&#39;t mean to imply that I did not find the languages listed above useful! Clojure is great, Elm is great, F# is great, and - why not - javascript is great! :)</p>
<p>I like to start learning a language with a very simple and well-defined spec, usually a function. Trying to implement a UI, or anything involving a lot of side effects is often counterproductive for me. And by writing a simple function, we already can learn a lot about the development workflow, the tooling, and the ecosystem, which are very important and deserve special attention.</p>
<h2 id="the-spec">The Spec</h2>
<p>I&#39;ll implement the same algorithm I implemented in <a href="https://lucasmreis.github.io/blog/learning-elm-part-1/">Learning Elm, part 1</a>. Recapping:</p>
<pre><code class="hljs"><span class="hljs-string">"3S"</span> -&gt; <span class="hljs-string">"Three of Spades"</span>
<span class="hljs-string">"10H"</span> -&gt; <span class="hljs-string">"Ten of Hearts"</span>
<span class="hljs-string">"QC"</span> -&gt; <span class="hljs-string">"Queen of Clubs"</span>
<span class="hljs-string">"AD"</span> -&gt; <span class="hljs-string">"Ace of Diamonds"</span>
<span class="hljs-string">"3T"</span> -&gt; <span class="hljs-string">"-- unknown card --"</span></code></pre>

<h2 id="the-strategy">The Strategy</h2>
<p>When learning Elm, I immediately jumped to a &quot;type-driven&quot; solution. Even though I think type driven development leads to more reliable / elegant code, I believe starting with a more JS-style approach is more compatible with the Reason philosophy.</p>
<p>Let&#39;s start by installing ReasonML&#39;s CLI <code>bsb</code> and create a new project (as described <a href="https://reasonml.github.io/">on the official website</a>):</p>
<pre><code class="hljs">$ npm <span class="hljs-operator"><span class="hljs-keyword">install</span> -<span class="hljs-keyword">g</span> bs-platform
$ bsb -init my-<span class="hljs-keyword">first</span>-app -theme basic-reason</span></code></pre>

<p>I&#39;m using VS Code with the ReasonML extension installed (<a href="https://reasonml.github.io/docs/en/global-installation.html">the instructions can be found here</a>). It&#39;s a great dev environment, with auto-complete, auto-formatting, and other niceties. A note on auto-formatting: we want to focus on actually solving a problem, so it&#39;s a good thing that problems like indentation are not getting in our way. This is something ReasonML has in common with Elm, and projects like Prettier are trying to do with javascript. I strongly recommend auto-formatting all the things!</p>
<p>In a real-world application when performance is a key requirement, we always need to be aware of bundle size and be careful with the amount and complexity of the code generated. So I always keep an eye on the compilation result: if we are writing a <code>demo.re</code> file, Bucklescript will generate a <code>demo.bs.js</code> file in the same folder. Also, for small functions, I recommend copy and pasting to the <a href="https://reasonml.github.io/try/">Try Reason</a> website, and see both the generated JS and equivalent Ocaml code in real time!</p>
<p><strong>A tip</strong>: when googling for help, we can usually find some Ocaml code that can help us. Use the Try ReasonML to convert it to ReasonML syntax!</p>
<h2 id="first-approach">First Approach</h2>
<p>Let&#39;s start by editing the <code>demo.re</code> and keep <code>npm start</code> running in the terminal:</p>
<pre><code class="hljs js"><span class="hljs-comment">/* it still does not do anything! */</span>
<span class="hljs-keyword">let</span> parseAndRenderCard = cardStr =&gt; cardStr;</code></pre>

<p>If we open the generated js file:</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseAndRenderCard</span>(<span class="hljs-params">cardStr</span>) </span>{
  <span class="hljs-keyword">return</span> cardStr;
}

exports.parseAndRenderCard = parseAndRenderCard;
<span class="hljs-comment">/* No side effect */</span></code></pre>

<p>It is treating the file as a module! And every variable and function we define in the file will be exported. If we change the value of <code>package-specs.module</code> in the <code>bs-config.json</code> file from <code>commonjs</code> to <code>es6</code>, we&#39;ll have:</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseAndRenderCard</span>(<span class="hljs-params">cardStr</span>) </span>{
  <span class="hljs-keyword">return</span> cardStr;
}

<span class="hljs-keyword">export</span> { parseAndRenderCard };
<span class="hljs-comment">/* No side effect */</span></code></pre>

<p>This is great to integrate your generated files into a webpack bundled project.</p>
<p>Have you noticed the &quot;No side effect&quot; comment? Bucklescript knows if your code is pure or not! I love this feature, and it helps with the practice of having as much of your code as pure as possible. If we add a log <code>Js.log(parseAndRenderCard(&quot;3C&quot;));</code>, we can see that the comment changes:</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseAndRenderCard</span>(<span class="hljs-params">cardStr</span>) </span>{
  <span class="hljs-keyword">return</span> cardStr;
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"3C"</span>);

<span class="hljs-keyword">export</span> { parseAndRenderCard };
<span class="hljs-comment">/*  Not a pure module */</span></code></pre>

<p>&quot;Not a pure module&quot;, great. But now that the side effect has been added, we can see an unexpected (at least for me!) behavior: the compiler understood that <code>parseAndRenderCard</code> is the identity function, and generated <code>console.log(&quot;3C&quot;);</code>, and not <code>console.log(parseAndRenderCard(&quot;3C&quot;));</code>! Even with such a simple piece of code, we can already see some cool optimizations.</p>
<p>But, you may ask, why does it still generate the function, if it is not being used? It&#39;s only because it&#39;s being exported. We can make sure the function is not exported if we put it in a block inside the module, like this:</p>
<pre><code class="hljs js">{
  <span class="hljs-keyword">let</span> parseAndRenderCard = cardStr =&gt; cardStr;
  Js.log(parseAndRenderCard(<span class="hljs-string">"3C"</span>));
}</code></pre>

<p>It will generate:</p>
<pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"3C"</span>);

<span class="hljs-keyword">export</span> {};
<span class="hljs-comment">/*  Not a pure module */</span></code></pre>

<p>Which is amazing: less code to parse, quicker page load :)</p>
<p>I want to talk about one more cool feature also present in Elm and F# before going to our function: the pipe operator <code>|&gt;</code>. It makes the code much cleaner most of the time, and gets rid of the ugly parentheses. As an example, these two lines of code are equivalent:</p>
<pre><code class="hljs js">Js.log(parseAndRenderCard(<span class="hljs-string">"3C"</span>));</code></pre>

<pre><code class="hljs js"><span class="hljs-string">"3C"</span> |&gt; parseAndRenderCard |&gt; Js.log;</code></pre>

<p>Ok! Enough talk, let&#39;s implement our function by breaking the problem into smaller ones, and start with a parser for a suit:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> parseAndRenderSuit = suitStr =&gt;
  <span class="hljs-keyword">switch</span> suitStr {
  | <span class="hljs-string">"H"</span> =&gt; <span class="hljs-string">"Hearts"</span>
  | <span class="hljs-string">"D"</span> =&gt; <span class="hljs-string">"Diamonds"</span>
  | <span class="hljs-string">"C"</span> =&gt; <span class="hljs-string">"Clubs"</span>
  | <span class="hljs-string">"S"</span> =&gt; <span class="hljs-string">"Spades"</span>
  };

<span class="hljs-comment">/* example */</span>
<span class="hljs-string">"C"</span> |&gt; parseAndRenderSuit |&gt; Js.log;</code></pre>

<p><code>switch</code> is the syntax for pattern matching in ReasonML. It works somewhat like a switch statement in JS, but it&#39;s more powerful: among other features, the compiler will tell you if you took care of all the possible values for the input. That&#39;s one of the key features of ML languages that makes the code more reliable. For the above function, we get the following compiler warning:</p>
<pre><code class="hljs">You forgot <span class="hljs-built_in">to</span> handle <span class="hljs-operator">a</span> possible <span class="hljs-built_in">value</span> here, <span class="hljs-keyword">for</span> example: <span class="hljs-string">""</span></code></pre>

<p>The compiler is right! And we can see that the generated JS code will raise an exception if the input is not one of the four cases. Let&#39;s try to fix this by defining a &quot;default&quot; pattern:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> parseAndRenderSuit = suitStr =&gt;
  <span class="hljs-keyword">switch</span> suitStr {
  | <span class="hljs-string">"H"</span> =&gt; <span class="hljs-string">"Hearts"</span>
  | <span class="hljs-string">"D"</span> =&gt; <span class="hljs-string">"Diamonds"</span>
  | <span class="hljs-string">"C"</span> =&gt; <span class="hljs-string">"Clubs"</span>
  | <span class="hljs-string">"S"</span> =&gt; <span class="hljs-string">"Spades"</span>
  | _ =&gt; <span class="hljs-string">"-- unknown suit --"</span>
  };

<span class="hljs-comment">/* example */</span>
<span class="hljs-string">"C"</span> |&gt; parseAndRenderSuit |&gt; Js.log;</code></pre>

<pre><code class="hljs"> <span class="hljs-keyword">node</span><span class="hljs-identifier"> </span><span class="hljs-title">src</span>/demo.bs.js
Clubs</code></pre>

<p>Great! That&#39;s a good start. We have a function that correctly spells the intended suit, and will have a valid output for <em>every possible string input</em>. Let&#39;s do the same for the card value:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> parseAndRenderValue = valueStr =&gt;
  <span class="hljs-keyword">switch</span> valueStr {
  | <span class="hljs-string">"2"</span> =&gt; <span class="hljs-string">"Two"</span>
  | <span class="hljs-string">"3"</span> =&gt; <span class="hljs-string">"Three"</span>
  | <span class="hljs-string">"4"</span> =&gt; <span class="hljs-string">"Four"</span>
  | <span class="hljs-string">"5"</span> =&gt; <span class="hljs-string">"Five"</span>
  | <span class="hljs-string">"6"</span> =&gt; <span class="hljs-string">"Six"</span>
  | <span class="hljs-string">"7"</span> =&gt; <span class="hljs-string">"Seven"</span>
  | <span class="hljs-string">"8"</span> =&gt; <span class="hljs-string">"Eight"</span>
  | <span class="hljs-string">"9"</span> =&gt; <span class="hljs-string">"Nine"</span>
  | <span class="hljs-string">"10"</span> =&gt; <span class="hljs-string">"Ten"</span>
  | <span class="hljs-string">"J"</span> =&gt; <span class="hljs-string">"Jack"</span>
  | <span class="hljs-string">"Q"</span> =&gt; <span class="hljs-string">"Queen"</span>
  | <span class="hljs-string">"K"</span> =&gt; <span class="hljs-string">"King"</span>
  | <span class="hljs-string">"A"</span> =&gt; <span class="hljs-string">"Ace"</span>
  | _ =&gt; <span class="hljs-string">"-- unknown value --"</span>
  };

<span class="hljs-comment">/* example */</span>
<span class="hljs-string">"7"</span> |&gt; parseAndRenderValue |&gt; Js.log;</code></pre>

<p>Boring but effective. Now we just need to implement the function that separates the input string and calls these two functions to print the full card. The suit is represented by the last character of the string, and the rest represents the value:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> parseAndRenderCard = cardStr =&gt; {
  <span class="hljs-comment">/* Separating the input string: */</span>
  <span class="hljs-keyword">let</span> length = Js.String.length(cardStr);
  <span class="hljs-keyword">let</span> suitStr = Js.String.sliceToEnd(~from=length - <span class="hljs-number">1</span>, cardStr);
  <span class="hljs-keyword">let</span> valueStr = Js.String.slice(~from=<span class="hljs-number">0</span>, ~to_=length - <span class="hljs-number">1</span>, cardStr);

  <span class="hljs-comment">/* Parsing and rendering the strings with our functions: */</span>
  <span class="hljs-keyword">let</span> renderedSuit = parseAndRenderSuit(suitStr);
  <span class="hljs-keyword">let</span> renderedValue = parseAndRenderValue(valueStr);

  <span class="hljs-comment">/* If inputs were valid, print the card: */</span>
  <span class="hljs-keyword">if</span> (renderedSuit !== <span class="hljs-string">"-- unknown suit --"</span>
      &amp;&amp; renderedValue !== <span class="hljs-string">"-- unknown value --"</span>) {
    renderedValue ++ <span class="hljs-string">" of "</span> ++ renderedSuit;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-string">"-- unknown card --"</span>;
  };
};

<span class="hljs-comment">/* example */</span>
<span class="hljs-string">"AD"</span> |&gt; parseAndRenderCard |&gt; Js.log;
<span class="hljs-comment">/* "Ace of Diamonds" */</span></code></pre>

<p>A lot is happening here; let me go step by step:</p>
<pre><code class="hljs">let <span class="hljs-property">length</span> = Js.String.<span class="hljs-property">length</span>(cardStr);</code></pre>

<p><code>Js.String.length</code> is a function that transforms a string into an integer that represents that string length. That&#39;s a part of the &quot;functional&quot; way of thinking: every piece of data we need is gathered from data transformations. For instance, if we want an upper case version of a string, instead of calling <code>str.toUpperCase()</code> we would call <code>Js.String.toUpperCase(str)</code>.</p>
<p>Next we have:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> suitStr = Js.<span class="hljs-built_in">String</span>.sliceToEnd(~<span class="hljs-keyword">from</span>=length - <span class="hljs-number">1</span>, cardStr);
<span class="hljs-keyword">let</span> valueStr = Js.<span class="hljs-built_in">String</span>.slice(~<span class="hljs-keyword">from</span>=<span class="hljs-number">0</span>, ~to_=length - <span class="hljs-number">1</span>, cardStr);</code></pre>

<p>The <code>~</code> character is used to denote &quot;labeled parameters&quot;. They are simply parameters that need to be named, and it means we can call them in whatever order we prefer. Calling <code>Js.String.sliceToEnd(cardStr, ~from=length - 1);</code> would yield the same result.</p>
<p><code>Js.String</code> is the name of the module where the functions are located. We could also open the module at the beginning of the file, and use the functions directly:</p>
<pre><code class="hljs js">open Js.String;

(...)

<span class="hljs-keyword">let</span> length = length(cardStr);
<span class="hljs-keyword">let</span> suitStr = sliceToEnd(~from=length - <span class="hljs-number">1</span>, cardStr);
<span class="hljs-keyword">let</span> valueStr = slice(~from=<span class="hljs-number">0</span>, ~to_=length - <span class="hljs-number">1</span>, cardStr);</code></pre>

<p>This could be cleaner, but keep in mind that it also &quot;pollutes&quot; the global context, making all functions inside <code>Js.String</code> available.</p>
<p><strong>A tip</strong>: make sure to take advantage of VS Code&#39;s auto-complete to explore all the modules and functions available to us! I found those three functions without googling, and it was a really nice workflow. It&#39;s good to learn things while staying in the same environment, which is another interesting side effect of working with a typed language.</p>
<p>Back to our function, we have:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> renderedSuit = parseAndRenderSuit(suitStr);
<span class="hljs-keyword">let</span> renderedValue = parseAndRenderValue(valueStr);</code></pre>

<p>Which is straightforward. And to finish:</p>
<pre><code class="hljs js"><span class="hljs-keyword">if</span> (renderedSuit !== <span class="hljs-string">"-- unknown suit --"</span>
    &amp;&amp; renderedValue !== <span class="hljs-string">"-- unknown value --"</span>) {
  renderedValue ++ <span class="hljs-string">" of "</span> ++ renderedSuit;
} <span class="hljs-keyword">else</span> {
  <span class="hljs-string">"-- unknown card --"</span>;
};</code></pre>

<p>Notice how we don&#39;t need a <code>return</code> keyword: the last line of a function expresses the return value. So we are simply checking if the values generated were the ones that represent unknown values. If that&#39;s not the case for both the value and the suit, we build the final string in <code>renderedValue ++ &quot; of &quot; ++ renderedSuit</code> (<code>++</code> is the operator for string concatenation).</p>
<p>That&#39;s it, a working implementation of the spec! This function is already more reliable than the average javascript function, and we can have full confidence all string inputs are going to generate a valid output, no exceptions will be raised, and all the invalid cases are covered.</p>
<p>But this implementation can improve.</p>
<h2 id="a-second-approach-option">A Second Approach: Option</h2>
<p>My main issue with the previous implementation is the two <code>&quot;-- unknown somethings --&quot;</code> possible values for the value and suit parsers. There&#39;s an interesting way of dealing with cases like this in ReasonML: the Option type. It represents values that may or may not be present, and that&#39;s exactly what the output of the function should be: we may or may not have a valid suit:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> parseAndRenderSuit = suitStr =&gt;
  <span class="hljs-keyword">switch</span> suitStr {
  | <span class="hljs-string">"H"</span> =&gt; Some(<span class="hljs-string">"Hearts"</span>)
  | <span class="hljs-string">"D"</span> =&gt; Some(<span class="hljs-string">"Diamonds"</span>)
  | <span class="hljs-string">"C"</span> =&gt; Some(<span class="hljs-string">"Clubs"</span>)
  | <span class="hljs-string">"S"</span> =&gt; Some(<span class="hljs-string">"Spades"</span>)
  | _ =&gt; None
  };</code></pre>

<p>VS Code shows us that now the function is of type <code>(string) =&gt; option(string)</code>, which is much more descriptive of what it does. It makes the code more <em>expressive</em>.</p>
<p>Option is a safe way of dealing with data that may not be present, instead of having the null and undefined checks in javascript. This is how we can work with an option in ReasonML:</p>
<pre><code class="hljs js"><span class="hljs-comment">/* Let's say we want to log a string from a string option: */</span>
<span class="hljs-keyword">let</span> printSuitExample = suitOption =&gt;
  <span class="hljs-keyword">switch</span> suitOption {
  | Some(suit) =&gt; Js.log(<span class="hljs-string">"Suit: "</span> ++ suit ++ <span class="hljs-string">"."</span>)
  | None =&gt; Js.log(<span class="hljs-string">"Input was not a valid suit."</span>)
  };</code></pre>

<p>Alright, so let&#39;s also rewrite <code>parseAndRenderValue</code> using option:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> parseAndRenderValue = valueStr =&gt;
  <span class="hljs-keyword">switch</span> valueStr {
  | <span class="hljs-string">"2"</span> =&gt; Some(<span class="hljs-string">"Two"</span>)
  | <span class="hljs-string">"3"</span> =&gt; Some(<span class="hljs-string">"Three"</span>)
  | <span class="hljs-string">"4"</span> =&gt; Some(<span class="hljs-string">"Four"</span>)
  | <span class="hljs-string">"5"</span> =&gt; Some(<span class="hljs-string">"Five"</span>)
  | <span class="hljs-string">"6"</span> =&gt; Some(<span class="hljs-string">"Six"</span>)
  | <span class="hljs-string">"7"</span> =&gt; Some(<span class="hljs-string">"Seven"</span>)
  | <span class="hljs-string">"8"</span> =&gt; Some(<span class="hljs-string">"Eight"</span>)
  | <span class="hljs-string">"9"</span> =&gt; Some(<span class="hljs-string">"Nine"</span>)
  | <span class="hljs-string">"10"</span> =&gt; Some(<span class="hljs-string">"Ten"</span>)
  | <span class="hljs-string">"J"</span> =&gt; Some(<span class="hljs-string">"Jack"</span>)
  | <span class="hljs-string">"Q"</span> =&gt; Some(<span class="hljs-string">"Queen"</span>)
  | <span class="hljs-string">"K"</span> =&gt; Some(<span class="hljs-string">"King"</span>)
  | <span class="hljs-string">"A"</span> =&gt; Some(<span class="hljs-string">"Ace"</span>)
  | _ =&gt; None
  };</code></pre>

<p>Now that we changed those two functions to be more expressive, we can check that the compiler is not generating a new JS file. Our <code>parseAndRenderCard</code> is no longer valid, so we need to change it. In my previous experience with strongly typed languages, this is the strongest point: refactoring feels safe! The compiler tells you exactly what breaks, and you just need to go there and fix it. In our case, let&#39;s exchange the last If to a pattern match:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> parseAndRenderCard = cardStr =&gt; {
  <span class="hljs-comment">/* Separating the input string: */</span>
  <span class="hljs-keyword">let</span> length = length(cardStr);
  <span class="hljs-keyword">let</span> suitStr = sliceToEnd(~from=length - <span class="hljs-number">1</span>, cardStr);
  <span class="hljs-keyword">let</span> valueStr = slice(~from=<span class="hljs-number">0</span>, ~to_=length - <span class="hljs-number">1</span>, cardStr);

  <span class="hljs-comment">/* Parsing and rendering the strings with our functions: */</span>
  <span class="hljs-keyword">let</span> renderedSuit = parseAndRenderSuit(suitStr);
  <span class="hljs-keyword">let</span> renderedValue = parseAndRenderValue(valueStr);

  <span class="hljs-comment">/* If inputs were valid, print the card: */</span>
  <span class="hljs-keyword">switch</span> (renderedValue, renderedSuit) {
  | (Some(value), Some(suit)) =&gt; value ++ <span class="hljs-string">" of "</span> ++ suit
  | _ =&gt; <span class="hljs-string">"-- unknown card --"</span>
  };
};</code></pre>

<p>Yes, we can pattern match on more than one value, and yes, it&#39;s awesome :)</p>
<p>The complete file <a href="https://github.com/lucasmreis/learning-reasonml/blob/master/part-1/src/first.re">can be found here</a>.</p>
<p>I like this implementation a lot more than the previous one, mainly for how well it expresses intention by using the option types. Now let&#39;s go further, and completely decouple the parsing and the rendering phases.</p>
<h2 id="a-third-approach-decoupling-parsing-and-rendering">A Third Approach: Decoupling Parsing And Rendering</h2>
<p>To achieve decoupling, we need to parse the string to a card representation, and then build a function that transforms this representation into a string. First, why would we do that? The main reason would be if we want to render in different ways, let&#39;s say we want to render to the DOM instead of logging to the console, or maybe our domain is getting so complex that the &quot;parseAndRender&quot; function is too large and complex. In our case, let&#39;s do it for fun and learning.</p>
<p>In javascript world, all data is represented mainly by objects and arrays. A card representation would be something like:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> card = {
  value: CardValueConstants.QUEEN,
  suit: CardSuitConstants.HEARTS
};</code></pre>

<p>The suit is enum-like, and we usually represent it in javascript by having an object with strings or symbols as values:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> CardSuitConstants = {
  HEARTS: <span class="hljs-string">"HEARTS"</span>,
  DIAMONDS: <span class="hljs-string">"DIAMONDS"</span>,
  CLUBS: <span class="hljs-string">"CLUBS"</span>,
  SPADES: <span class="hljs-string">"SPADES"</span>
};</code></pre>

<p>Now if we want to check against a value, or check if a given string is a valid suit, we import and use this object.</p>
<p>In ReasonML, we would represent the suits this way, which works like an enum of symbols:</p>
<pre><code class="hljs js">type suit = Hearts | Diamonds | Clubs | Spades;</code></pre>

<p>These are called <em>Discriminated Unions</em>. The best part of working with them is that when we pattern match on a variable of this type, the compiler will make sure we handle all the cases.</p>
<p>For the card value, we need a little more information for the numbered card cases. Back in JS world, we could add a <code>number</code> property:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> card = {
  value: CardValueConstants.NUMBER,
  number: <span class="hljs-number">7</span>,
  suit: CardSuitConstants.CLUBS
};</code></pre>

<p>The weakness of a representation like that is that &quot;impossible&quot; cards are easy to be represented. So we need to make sure we are always testing not only for <code>value</code> being equal <code>CardValueConstants.NUMBER</code>, but also to see if there&#39;s a <code>number</code> property present and that it&#39;s a valid number.</p>
<p>In ReasonML, we would represent the values as:</p>
<pre><code class="hljs js">type value =
  | Ace
  | King
  | Queen
  | Jack
  | Num(int);</code></pre>

<p>The most interesting characteristic of this way of representing the value is that there&#39;s simply <em>no way</em> of having a card of value Queen that also has a number, or to have a numbered card without a defined number. This is huge, and, combined with pattern matching, this will make our code very reliable without the need to test the existence of properties everywhere.</p>
<p><em>Note:</em> there&#39;s still impossible states that can be represented this way, for instance <code>Num(333)</code>. There are only numbered cards from 2 to 10. We could list all cases explicitly, and our function would be even more reliable, but let&#39;s continue with this representation since it&#39;ll lead to more interesting code and more opportunities to learn.</p>
<p>Our final card representation can now be:</p>
<pre><code class="hljs js">type card =
 | Card(value, suit);</code></pre>

<p>Which is a single case discriminated union. There&#39;s no reason to use one, we could use a simple tuple of type <code>(value, suit)</code>, but I find this expresses the intent better.</p>
<h3 id="renderer">Renderer</h3>
<p>Now let&#39;s write the renderer. It will be simple, since it&#39;s only a matter of matching all the available cases:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> suitToString = suit =&gt;
  <span class="hljs-keyword">switch</span> suit {
  | Hearts =&gt; <span class="hljs-string">"Hearts"</span>
  | Diamonds =&gt; <span class="hljs-string">"Diamonds"</span>
  | Clubs =&gt; <span class="hljs-string">"Clubs"</span>
  | Spades =&gt; <span class="hljs-string">"Spades"</span>
  };

<span class="hljs-keyword">let</span> numToString = num =&gt;
  <span class="hljs-keyword">switch</span> num {
  | <span class="hljs-number">2</span> =&gt; <span class="hljs-string">"Two"</span>
  | <span class="hljs-number">3</span> =&gt; <span class="hljs-string">"Three"</span>
  | <span class="hljs-number">4</span> =&gt; <span class="hljs-string">"Four"</span>
  | <span class="hljs-number">5</span> =&gt; <span class="hljs-string">"Five"</span>
  | <span class="hljs-number">6</span> =&gt; <span class="hljs-string">"Six"</span>
  | <span class="hljs-number">7</span> =&gt; <span class="hljs-string">"Seven"</span>
  | <span class="hljs-number">8</span> =&gt; <span class="hljs-string">"Eight"</span>
  | <span class="hljs-number">9</span> =&gt; <span class="hljs-string">"Nine"</span>
  | <span class="hljs-number">10</span> =&gt; <span class="hljs-string">"Ten"</span>
  | _ =&gt; failwith(<span class="hljs-string">"this is an exception from numToString"</span>)
  };

<span class="hljs-keyword">let</span> valueToString = value =&gt;
  <span class="hljs-keyword">switch</span> value {
  | Ace =&gt; <span class="hljs-string">"Ace"</span>
  | King =&gt; <span class="hljs-string">"King"</span>
  | Queen =&gt; <span class="hljs-string">"Queen"</span>
  | Jack =&gt; <span class="hljs-string">"Jack"</span>
  | Num(n) =&gt; numToString(n)
  };

<span class="hljs-keyword">let</span> renderCard = card =&gt;
  <span class="hljs-keyword">switch</span> card {
  | Card(value, suit) =&gt;
    valueToString(value) ++ <span class="hljs-string">" of "</span> ++ suitToString(suit)
  };

<span class="hljs-comment">/* example */</span>
Card(Num(<span class="hljs-number">8</span>), Hearts) |&gt; renderCard |&gt; Js.log;</code></pre>

<p>The only different code here is the <code>failwith</code> case in <code>numToString</code>. It&#39;s there because we need to handle all the integers when pattern matching, but we&#39;ll make sure never to have an invalid number. Again, we could deal with it by being explicit with all the cases, but sometimes it&#39;s not possible - imagine if we had an imaginary deck with numbered cards from two to a thousand. The best way to handle a situation like this would be to make sure the functions that output cards never return invalid cards, and it&#39;s a good place for unit and generative tests. Once more: strongly typed languages are much more reliable than dynamic languages, but it does not mean they are 100% reliable - we still have to be careful. But it&#39;s much, much easier to write correct code :)</p>
<p><em>Note:</em> there are attempts at expressing some of those constraints in the types themselves, like saying a variable is a number between 2 and 10. Some languages already have this ability, such as <a href="https://en.wikipedia.org/wiki/Ada_(programming_language">Ada</a>&gt;). Other more recent languages are trying to deal with this more generically through dependent types, such as <a href="https://en.wikipedia.org/wiki/Idris_(programming_language">Idris</a>&gt;) and <a href="https://en.wikipedia.org/wiki/F*_(programming_language">F*</a>&gt;).</p>
<h3 id="parser">Parser</h3>
<p>The parser will be a function that takes a string and returns a card option. Let&#39;s start with the simple suit parser:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> parseSuit = suitStr =&gt;
 <span class="hljs-keyword">switch</span> suitStr {
 | <span class="hljs-string">"H"</span> =&gt; Some(Hearts)
 | <span class="hljs-string">"D"</span> =&gt; Some(Diamonds)
 | <span class="hljs-string">"C"</span> =&gt; Some(Clubs)
 | <span class="hljs-string">"S"</span> =&gt; Some(Spades)
 | _ =&gt; None
 };</code></pre>

<p>The function type is inferred as <code>(string) =&gt; option(suit)</code> which is exactly our intention.</p>
<p>For the value, I&#39;ll separate the number parsing to the other card values. Supposing we have a <code>parseNumValue</code> function implemented, we could use it like this:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> parseValue = valueStr =&gt;
 <span class="hljs-keyword">switch</span> valueStr {
 | <span class="hljs-string">"A"</span> =&gt; Some(Ace)
 | <span class="hljs-string">"K"</span> =&gt; Some(King)
 | <span class="hljs-string">"Q"</span> =&gt; Some(Queen)
 | <span class="hljs-string">"J"</span> =&gt; Some(Jack)
 | n =&gt; parseNumValue(n)
 };</code></pre>

<p>We are defining outputs for the &quot;A&quot;, &quot;K&quot;, &quot;Q&quot; and &quot;J&quot; inputs, and calling the <code>parseNumValue</code> function with the value if it did not match any of the previous. The compiler will not let us continue if our <code>parseNumValue</code> does not return a suit option! Let&#39;s implement it, and learn some new ReasonML concepts:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> parseNumValue = numStr =&gt; {
  <span class="hljs-keyword">let</span> parsed =
    <span class="hljs-keyword">try</span> (Some(int_of_string(numStr))) {
    | Failure(_) =&gt; None
    };

  <span class="hljs-keyword">switch</span> parsed {
  | Some(n) when n &gt;= <span class="hljs-number">2</span> &amp;&amp; n &lt;= <span class="hljs-number">10</span> =&gt; Some(Num(n))
  | _ =&gt; None
  };
};</code></pre>

<p>Starting with the <code>parsed</code> variable: we want to transform a string that may be a number into an integer variable. There&#39;s a standard function for that, <code>int_of_string</code>. But it raises an exception if the string input is not a valid integer. That&#39;s not the behavior we want here. We want a function that returns a value option, in this case, a <code>Num(int)</code> option, so we need a try expression.</p>
<p>It works similarly to javascript&#39;s try / catch, with the difference being that it returns the value of the provided expression if it does not raise, and pattern match on the exceptions if it does raise. Looking at <code>int_of_string</code> <a href="https://reasonml.github.io/api/Pervasives.html#6_Stringconversionfunctions">documentation</a> we can see that the exception is of type <code>Failure(string)</code> so we catch it and return <code>None</code> in that case.</p>
<p><em>Note:</em> be really careful when working with exceptions. They are not defined in the function types, so the compiler can&#39;t help you make sure you&#39;re handling all cases. Also, you need to look at documentation to understand what to match for. As a rule of thumb, never use or rely on exceptions. Only use them if it&#39;s needed for integrating with existing code (our case here), or if somehow it makes the code simpler.</p>
<p><em>Another note:</em> The Js.Option module provides a <code>some</code> function that returns a <code>Some</code> option variable. It&#39;s useful if we want to use the pipe operator to get rid of parenthesis:</p>
<pre><code class="hljs js">open Js.Option;

(...)

<span class="hljs-keyword">let</span> parsed =
  <span class="hljs-keyword">try</span> (numStr |&gt; int_of_string |&gt; some) {
  | Failure(_) =&gt; None
  };</code></pre>

<p>It&#39;s a matter of taste, and I think the pipe operator can make the code more elegant. I&#39;m excited that it&#39;s being <a href="https://github.com/tc39/proposal-pipeline-operator">considered for javascript too!</a></p>
<p>Continuing with our function, there&#39;s something different in the pattern match:</p>
<pre><code class="hljs js"><span class="hljs-keyword">switch</span> parsed {
| Some(n) when n &gt;= <span class="hljs-number">2</span> &amp;&amp; n &lt;= <span class="hljs-number">10</span> =&gt; Some(Num(n))
| _ =&gt; None
};</code></pre>

<p>We can put constraints on the patterns we want to match with the <code>when</code> keyword. And since this is the <em>only</em> function that generates a <code>Num(int)</code>, we are guaranteeing that there no invalid cards! Of course, as I said before, in real life we should write some tests, and I&#39;ll cover them later in this series.</p>
<p>And, to finish the parser:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> parseCard = cardStr =&gt; {
  <span class="hljs-keyword">let</span> length = Js.String.length(cardStr);
  <span class="hljs-keyword">let</span> suitStr = Js.String.sliceToEnd(~from=length - <span class="hljs-number">1</span>, cardStr);
  <span class="hljs-keyword">let</span> valueStr = Js.String.slice(~from=<span class="hljs-number">0</span>, ~to_=length - <span class="hljs-number">1</span>, cardStr);

  <span class="hljs-keyword">switch</span> (parseValue(valueStr), parseSuit(suitStr)) {
  | (Some(value), Some(suit)) =&gt; Card(value, suit) |&gt; some
  | _ =&gt; None
  };</code></pre>

<h3 id="gluing-the-pieces-together">Gluing The Pieces Together</h3>
<p>It would be amazing if we could simply use our functions like this:</p>
<pre><code class="hljs js"><span class="hljs-string">"8H"</span> |&gt; parseCard |&gt; renderCard |&gt; Js.log;</code></pre>

<p>But we get the (very good btw) compiler error message:</p>
<pre><code class="hljs">We<span class="hljs-comment">'ve found a bug for you!</span>

<span class="hljs-number">102</span> 
<span class="hljs-number">103</span>  /* example */
<span class="hljs-number">104</span>  <span class="hljs-string">"8H"</span> |&gt; parseCard |&gt; renderCard |&gt; Js.log;

This has type:
 (card) =&gt; <span class="hljs-built_in">string</span>
But somewhere wanted:
 (<span class="hljs-keyword">option</span>(card)) =&gt; <span class="hljs-comment">'a</span>

The incompatible parts:
 card
 vs
 <span class="hljs-keyword">option</span>(card)</code></pre>

<p><em>Note:</em> Elm is known for having amazing error messages - and it really does have them. It&#39;s nice that they were vocal about it, and now this practice is &quot;leaking&quot; to other languages! Congratulations to the ReasonML / Bucklescript team for borrowing the right features from different projects.</p>
<p>Alright, so we can&#39;t pipe our functions because <code>parseCard</code> returns an option(card), and <code>renderCard</code>&#39;s input is a card. Let&#39;s use this opportunity to build a couple of helper functions!</p>
<p>First, wouldn&#39;t it be useful to have a function that receives an option of something and a function of something, and applies the function to the value if it&#39;s a Some, and does not do anything if it&#39;s a None? This function is called <code>map</code>, and it will help our pipeline:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> optionMap = fn =&gt; opt =&gt;
  <span class="hljs-keyword">switch</span> opt {
  | Some(x) =&gt; fn(x) |&gt; some
  | None =&gt; None
  };</code></pre>

<p>This is a higher order function, so now we can use:</p>
<pre><code class="hljs js"><span class="hljs-string">"8H"</span> |&gt; parseCard |&gt; optionMap(renderCard) |&gt; Js.log;</code></pre>

<p>And <code>renderCard</code> will only be called if <code>parseCard</code> returns a Some. But, after saving the file, we can see that the declaration of the function is changed by the code formatter to <code>let optionMap = (fn, opt) =&gt; (...)</code>! Does this mean that ReasonML doesn&#39;t like higher order functions? No, it&#39;s the opposite: in ReasonML and most other ML languages, <em>all the functions are curried by default</em>. That means that, differently from usual JS functions, if you call a function with fewer input parameters than the function was expecting, you will have another function as a result that will expect the other parameters. A simple, classic example:</p>
<pre><code class="hljs js"><span class="hljs-comment">/* (int, int) =&gt; (int) */</span>
<span class="hljs-keyword">let</span> sum = (x, y) =&gt; x + y;

<span class="hljs-comment">/* (int) =&gt; (int) */</span>
<span class="hljs-keyword">let</span> sum5 = sum(<span class="hljs-number">5</span>);

<span class="hljs-comment">/* int */</span>
<span class="hljs-keyword">let</span> eight = sum5(<span class="hljs-number">3</span>);</code></pre>

<p>Ok, back to our code, now our file compiles, but the logged output is an <em>array</em> of string instead of a string. That&#39;s because <code>optionMap(renderCard)</code> returns a string <em>option</em>, not a string! If we feed the pipeline with an invalid card, say &quot;1X&quot;, We&#39;ll see that the logged output will be &quot;0&quot;, which is how Bucklescript translates None to javascript.</p>
<p>So let&#39;s implement a function to transform a string option into a string. We can do it by returning the string itself if it&#39;s inside a Some, or returning a default value if it&#39;s a None:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> optionWithDefault = (defaultValue, opt) =&gt;
  <span class="hljs-keyword">switch</span> opt {
  | Some(x) =&gt; x
  | None =&gt; defaultValue
  };

<span class="hljs-comment">/* example */</span>
<span class="hljs-string">"2D"</span>
|&gt; parseCard
|&gt; optionMap(renderCard)
|&gt; optionWithDefault(<span class="hljs-string">"-- unknown card --"</span>)
|&gt; Js.log;</code></pre>

<p>And now we have everything we need! Working functions, confidence that they&#39;ll do what we want them to do, and elegant implementations.</p>
<p><em>Note:</em> have you noticed the inferred type for <code>optionWithDefault</code>? It&#39;s <code>(&#39;a, option(&#39;a)) =&gt; &#39;a</code>, which does not mention strings. <code>&#39;a</code> is a generic type, so that means this function will work with options of <em>anything</em>. The only thing we have to be careful with is that the default value passed must be of the same type inside the option :) That means that <code>optionWithDefault(0, Some(5))</code> or <code>optionWithDefault(Card(Ace, Diamonds), None)</code> are both valid! (and the same thing happens to <code>optionMap</code>, check it out).</p>
<p>We can also divide our functions into modules. In ReasonML, every file is a module, but we can also define modules inside a file, so let&#39;s do it to better organize our functions:</p>
<pre><code class="hljs js">type suit = (...)
type value = (...)
type card = (...)

<span class="hljs-built_in">module</span> Parser = {
  <span class="hljs-keyword">let</span> parseNumValue = (...)
  <span class="hljs-keyword">let</span> parseValue = (...)
  <span class="hljs-keyword">let</span> parseSuit = (...)
  <span class="hljs-keyword">let</span> parseCard = (...)
};

<span class="hljs-built_in">module</span> RenderToString = {
  <span class="hljs-keyword">let</span> numToString = (...)
  <span class="hljs-keyword">let</span> valueToString = (...)
  <span class="hljs-keyword">let</span> suitToString = (...)
  <span class="hljs-keyword">let</span> renderCard = (...)
  <span class="hljs-comment">/* let's store this value here */</span>
  <span class="hljs-keyword">let</span> defaultErrorCard = <span class="hljs-string">"-- unknown card --"</span>;
};

<span class="hljs-built_in">module</span> Option = {
  <span class="hljs-keyword">let</span> map = (...)
  <span class="hljs-keyword">let</span> withDefault = (...)
};

<span class="hljs-comment">/* We can call functions inside modules easily: */</span>
<span class="hljs-string">"JH"</span>
|&gt; Parser.parseCard
|&gt; Option.map(RenderToString.renderCard)
|&gt; Option.withDefault(RenderToString.defaultErrorCard)
|&gt; Js.log;</code></pre>

<p>Good, and we can extract the modules as single files if they get too large. I like the fact that we can have exactly the same abstraction as code and as a file. That makes the extraction of files mostly just an organizational issue.</p>
<h2 id="spec-change-">Spec Change!</h2>
<p>As I&#39;ve done in the <a href="https://lucasmreis.github.io/blog/learning-elm-part-1/">Learning Elm series</a>, let&#39;s change the specs. Let&#39;s suppose we also want to parse &quot;J&quot; into a joker card and render it as &quot;Joker&quot;. How would we represent a joker card? It does not have a value or a suit. So probably the best place to represent it is by changing the card type itself:</p>
<pre><code class="hljs js">type card =
  | OrdinaryCard(value, suit)
  | Joker;</code></pre>

<p>We can already see the compiler complaining, and that&#39;s another benefit of having this card representation defined. The compiler uses this information and helps us by pointing to the places that need to be changed, so our application works as intended.</p>
<p>The function that we need to change is, according to the compiler, <code>renderCard</code>. So let&#39;s change it to deal with the new card type:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> renderCard = card =&gt;
  <span class="hljs-keyword">switch</span> card {
  | OrdinaryCard(value, suit) =&gt;
    valueToString(value) ++ <span class="hljs-string">" of "</span> ++ suitToString(suit)
  | Joker =&gt; <span class="hljs-string">"Joker"</span>
  };</code></pre>

<p>Simple and easy! The compiler also says <code>parseCard</code> needs some work, so use the opportunity to think about how to parse &quot;J&quot; into the Joker representation. The &quot;J&quot; string is structured differently since it does not have a defined suit. So it may be better not to change <code>parseValue</code> or <code>parseSuit</code>. Let&#39;s try to pattern match &quot;J&quot; first, and then call our parse function to parse the string if we didn&#39;t already identify it as a Joker.</p>
<p>Let&#39;s first rename <code>parseCard</code> to <code>parseOrdinaryCard</code>, and then make sure we handle &quot;J&quot; in a new <code>parseCard</code> function:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> parseOrdinaryCard = cardStr =&gt; {
  <span class="hljs-keyword">let</span> length = Js.String.length(cardStr);
  <span class="hljs-keyword">let</span> suitStr = Js.String.sliceToEnd(~from=length - <span class="hljs-number">1</span>, cardStr);
  <span class="hljs-keyword">let</span> valueStr = Js.String.slice(~from=<span class="hljs-number">0</span>, ~to_=length - <span class="hljs-number">1</span>, cardStr);
  <span class="hljs-keyword">switch</span> (parseValue(valueStr), parseSuit(suitStr)) {
  | (Some(value), Some(suit)) =&gt; OrdinaryCard(value, suit) |&gt; some
  | _ =&gt; None
  };
};

<span class="hljs-keyword">let</span> parseCard = cardStr =&gt;
  <span class="hljs-keyword">switch</span> cardStr {
  | <span class="hljs-string">"J"</span> =&gt; Some(Joker)
  | str =&gt; parseOrdinaryCard(str)
  };

<span class="hljs-comment">/* example */</span>
<span class="hljs-string">"J"</span>
|&gt; Parser.parseCard
|&gt; Option.map(RenderToString.renderCard)
|&gt; Option.withDefault(RenderToString.defaultErrorCard)
|&gt; Js.log;</code></pre>

<p>And we&#39;re done. Amazingly, ReasonML&#39;s changes to the syntax did not affect the super refactoring powers of Ocaml :)</p>
<p>The final code for the function <a href="https://github.com/lucasmreis/learning-reasonml/blob/master/part-1/src/second.re">can be found here</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>First of all, all the benefits present in Fable are present in ReasonML - and that&#39;s great. Just like Fable, it&#39;s a nice pragmatic Elm, and out of all the languages, it was the easiest to just start a project - I did not have to install any different tools, and the main packages are in npm. So that&#39;s a win for ReasonML :)</p>
<p>In the next part of this series, I&#39;ll start writing an actual web app, and I&#39;ll use the React integration library called <a href="https://reasonml.github.io/reason-react/">ReasonReact</a>. I think this is where all the mentioned languages will differ the most. In the javascript world, I&#39;m finding myself using a &quot;pure React&quot; model more and more, and it seems ReasonReact will work well with it. Let&#39;s find it out together!</p>
<p>A last comment: ReasonML&#39;s <a href="https://discordapp.com/invite/reasonml">Discord channel</a> is a great place, and the language maintainers are very active and helpful. Thank you for helping and answering questions so quickly!</p>
]]></description>
            <guid isPermaLink="false">Learning ReasonML, part 1</guid>
            <pubDate>Sun, 31 Dec 2017 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Simple React Patterns]]></title>
            <description><![CDATA[<p>I&#39;ve been writing React applications for a few years now, and I&#39;ve noticed that some patterns tend to repeat themselves. In this post, I&#39;ll review these patterns which will summarize about 99% of the React code I write every day.</p>
<p>As a sample spec, let&#39;s build an app that fetches information about the Dagobah planet from Star Wars API and shows it to the user.</p>
<h2 id="simple-everyday-patterns">Simple everyday patterns</h2>
<p>About 95% of the code written every day will be either simple view components or components with some logic.  This is the first pattern, and it&#39;s the easiest one:</p>
<h3 id="the-vanilla-or-mixed-pattern">The Vanilla or Mixed Pattern</h3>
<pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dagobah</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-comment">// State:</span>
  <span class="hljs-comment">// { loading: true }</span>
  <span class="hljs-comment">// { loading: false, planet: { name, climate, terrain } }</span>
  <span class="hljs-comment">// { loading: false, error: any }</span>
  state = { loading: <span class="hljs-literal">true</span> };

  componentDidMount() {
    fetch(<span class="hljs-string">"https://swapi.co/api/planets/5"</span>)
      .then(res =&gt; res.json())
      .then(
        planet =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, planet }),
        error =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, error })
      );
  }

  renderLoading() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span>
  }

  renderError() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>I'm sorry! Please try again.<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span>
  }

  renderPlanet() {
    <span class="hljs-keyword">const</span> { name, climate, terrain } = <span class="hljs-keyword">this</span>.state.planet;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">h2</span>&gt;</span>{name}<span class="hljs-tag">&lt;/<span class="hljs-title">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Climate: {climate}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Terrain: {terrain}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }

  render() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.loading) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.renderLoading();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.planet) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.renderPlanet();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.renderError();
    }
  }
}</code></pre>

<p>This is a <em>vanilla</em> React component, something you will write after reading the docs. Writing a component like this one has its benefits: the main one is that it&#39;s easy, and it&#39;s self-contained. Plug a <code>&lt;Dagobah /&gt;</code> anywhere in your application, and it will fetch and render the data.</p>
<p><strong>Side note</strong>: whenever we deal with fetching data from somewhere in a way that may take time or fail, <em>we need to define views for those states</em>. We always need to define a view for the loading state and a view for the error state. No network is perfect, and we need to prepare our app for problems! You can even define more intricate logic, such as waiting milliseconds before showing the loading view to avoid blinking screens, and so on. This is a great subject, but I won&#39;t go further in this blog post. I&#39;ll stick to the simple Loading / Error / Success pattern in all the examples.</p>
<p>So, what problems could this component have? Let&#39;s say we want to use a style guide tool like <a href="https://storybook.js.org/">Storybook</a> to render the component in all three states to be able to polish each version well or even showcase it to other teams. Is it possible? What if I want to unit test the view without fetching the data every time, or without mocking the requests? It&#39;s not going to happen.</p>
<p>Both the logic and the view are intertwined in one indivisible component, and that&#39;s why I also call this pattern the <em>Mixed Component</em> pattern. For a better workflow and simpler, more testable and more maintainable code, we need to separate the logic and the view. And that&#39;s why this second pattern is probably the most useful, and the one I try to use as much as possible:</p>
<h3 id="the-container-view-pattern">The Container / View Pattern</h3>
<pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlanetView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  renderLoading() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span>
  }

  renderError() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>I'm sorry! Please try again.<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span>
  }

  renderPlanet() {
    <span class="hljs-keyword">const</span> { name, climate, terrain } = <span class="hljs-keyword">this</span>.props.planet;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">h2</span>&gt;</span>{name}<span class="hljs-tag">&lt;/<span class="hljs-title">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Climate: {climate}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Terrain: {terrain}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }

  render() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.props.loading) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.renderLoading();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.props.planet) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.renderPlanet();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.renderError();
    }
  }
}

<span class="hljs-comment">// State:</span>
<span class="hljs-comment">// { loading: true }</span>
<span class="hljs-comment">// { loading: false, planet: { name, climate, terrain } }</span>
<span class="hljs-comment">// { loading: false, error: any }</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DagobahContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = { loading: <span class="hljs-literal">true</span> };

  componentDidMount() {
    fetch(<span class="hljs-string">"https://swapi.co/api/planets/5"</span>)
      .then(res =&gt; res.json())
      .then(
        planet =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, planet }),
        error =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, error })
      );
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">PlanetView</span> {<span class="hljs-attribute">...this.state</span>} /&gt;</span>;</span>
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> DagobahContainer;</code></pre>

<p>That&#39;s it. You&#39;ve just seen the majority of the code I write today. A simple view-only generic planet component, and a logic-only component, that simply calls the view in its render function.</p>
<p>With the separated view component, we can very easily use it in a style guide, and fine tune each of the variants just by providing different props. Also, we can easily test the view using <a href="https://github.com/airbnb/enzyme">Enzyme</a> for instance.</p>
<p>Also, my experience shows that this pattern scales better: maybe one of the view states gets big, and it&#39;s straightforward to extract it through a new component. On the logic side, it&#39;s also much easier to understand and change code not polluted with view related stuff.</p>
<p>Notice that the view component has some &quot;if&quot; logic to define what to render. We can extract it into its own component, in what could be considered a variant of the Container / View pattern:</p>
<h3 id="the-container-branch-view-pattern">The Container / Branch / View Pattern</h3>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> LoadingView = () =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span>

<span class="hljs-keyword">const</span> ErrorView = () =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>I'm sorry! Please try again.<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span>

<span class="hljs-keyword">const</span> PlanetView = ({ name, climate, terrain }) =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">h2</span>&gt;</span>{name}<span class="hljs-tag">&lt;/<span class="hljs-title">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Climate: {climate}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Terrain: {terrain}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
)</span>;

<span class="hljs-keyword">const</span> PlanetBranch = ({ loading, planet }) =&gt; {
  <span class="hljs-keyword">if</span> (loading) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">LoadingView</span> /&gt;</span>;</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (planet) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">PlanetView</span> {<span class="hljs-attribute">...planet</span>} /&gt;</span>;</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">ErrorView</span> /&gt;</span>;</span>
  }
};

<span class="hljs-comment">// State:</span>
<span class="hljs-comment">// { loading: true }</span>
<span class="hljs-comment">// { loading: false, planet: { name, climate, terrain } }</span>
<span class="hljs-comment">// { loading: false, error: any }</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DagobahContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = { loading: <span class="hljs-literal">true</span> };

  componentDidMount() {
    fetch(<span class="hljs-string">"https://swapi.co/api/planets/5"</span>)
      .then(res =&gt; res.json())
      .then(
        planet =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, planet }),
        error =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, error })
      );
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">PlanetBranch</span> {<span class="hljs-attribute">...this.state</span>} /&gt;</span>;</span>
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> DagobahContainer;</code></pre>

<p>Now the individual views are even more isolated, which can help the testing, showcasing and development workflow. Deciding how much to break the view is best done with a case by case analysis, and the rule of thumb is to keep it simple to understand. This can vary a lot, so use your best judgment!</p>
<p>The only situation that these initial patterns are not useful for is when we need to <em>reuse the logic with different views</em>. These can be interesting cases, and there are two main ways of dealing with them. Let start with the &quot;oldest&quot; one:</p>
<h2 id="higher-order-components">Higher Order Components</h2>
<p>Higher-Order Components (HOCs) are simply functions that take at least one component as a parameter and return another component. Usually it adds props to the passed component after doing some work. For instance, we could have a <code>withDagobah</code> HOC that fetches info about Dagobah and passes the result as a prop:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> withDagobah = PlanetViewComponent =&gt;
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    state = { loading: <span class="hljs-literal">true</span> };

    componentDidMount() {
      fetch(<span class="hljs-string">"https://swapi.co/api/planets/5"</span>)
        .then(res =&gt; res.json())
        .then(
          planet =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, planet }),
          error =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, error })
        );
    }

    render() {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">PlanetViewComponent</span> {<span class="hljs-attribute">...this.state</span>} /&gt;</span>;</span>
    }
  };

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> withDagobah(PlanetBranch);</code></pre>

<p>Now, all the planet fetching logic is inside this HOC, and is <em>not dependent on any view logic</em>. It does not have any dependency on any particular React views, and it only adds some props to a passed component. That way, you can, for instance, use it in all your routes, with different components rendering planets differently.</p>
<p><strong>Note:</strong> if you use this HOC in two components being rendered on the same screen, it will fetch the data twice. Fetching data is an expensive side effect, and usually, we try to do it as little as possible. I&#39;ll talk about how to deal with it in the last pattern of this post, so keep on reading! :)</p>
<p>A HOC can also accept different parameters to define its behavior. We could have for instance a <code>withPlanet</code> HOC that fetches different planets:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> hoc = withPlanet(<span class="hljs-string">'tatooine'</span>);
<span class="hljs-keyword">const</span> Tatooine = hoc(PlanetView);

<span class="hljs-comment">// somewhere else inside a component:</span>
render() {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">Tatooine</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  )</span>;
}</code></pre>

<p>An example of a HOC with this ability is <a href="https://github.com/ctrlplusb/react-sizeme">react-sizeme</a>. It receives an options object and a component and returns another component with a <code>size</code> prop containing height, width, and position information.</p>
<p>So, what are the cons of HOCSs? The first painful one is that every view that will be used with the HOC has to understand the shape of the props passed. In our example, we add <code>loading</code>, <code>error</code> and <code>planet</code>, and our views need to be prepared for it. Sometimes we have to have a component whose only purpose is transforming props into the intended ones, and that feels inefficient (interestingly, one of the most used HOCs does not have this problem: <a href="https://github.com/reactjs/react-redux">react-redux</a>&#39;s <code>connect</code>, because the user decides the shape of the props passed to the view component).</p>
<p>Some HOCs will always lead to branched views, like our <code>withDagobah</code> that almost always will be viewed with Loading, Error and Success views. That can give rise to a HOC variant:</p>
<h3 id="variation-branching-higher-order-components">Variation: Branching Higher Order Components</h3>
<p>We can put the branching logic inside the HOC:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> withDagobah = ({
  LoadingViewComponent,
  ErrorViewComponent,
  PlanetViewComponent
}) =&gt;
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    state = { loading: <span class="hljs-literal">true</span> };

    componentDidMount() {
      fetch(<span class="hljs-string">"https://swapi.co/api/planets/5"</span>)
        .then(res =&gt; res.json())
        .then(
          planet =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, planet }),
          error =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, error })
        );
    }

    render() {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.loading) {
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">LoadingViewComponent</span> /&gt;</span>;</span>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.planet) {
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">PlanetViewComponent</span> {<span class="hljs-attribute">...this.state.planet</span>} /&gt;</span>;</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">ErrorViewComponent</span> /&gt;</span>;</span>
      }
    }
  };

<span class="hljs-comment">// and the HOC would be called like this:</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> withDagobah({
  LoadingViewComponent: LoadingView,
  ErrorViewComponent: ErrorView,
  PlanetViewComponent: PlanetView
});</code></pre>

<p>There&#39;s a trade-off here: even though the views are simpler, there&#39;s more logic inside the HOC. It&#39;s only worth it if you know that more than one view is going to be used and that the branching logic will be the same every time. An example of a branching HOC is <a href="https://github.com/thejameskyle/react-loadable">react-loadable</a>, which accepts both a dynamically loaded component and a Loading component that handles both the loading and the error state.</p>
<h2 id="render-props">Render Props</h2>
<p>There is another widely used pattern that separates the logic from the view, the Render Props (also known as Children as Function). <a href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce">Some people swear by it</a>,and some people <a href="http://americanexpress.io/faccs-are-an-antipattern/">consider it an anti-pattern</a>. Opinions aside, this is how our Dagobah logic would be implemented as a Render Prop:</p>
<pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DagobahRP</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = { loading: <span class="hljs-literal">true</span> };

  componentDidMount() {
    fetch(<span class="hljs-string">"https://swapi.co/api/planets/5"</span>)
      .then(res =&gt; res.json())
      .then(
        planet =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, planet }),
        error =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, error })
      );
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.props.render(<span class="hljs-keyword">this</span>.state);
  }
}

<span class="hljs-comment">// notice that a function is passed to the render prop:</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">DagobahRP</span>
    <span class="hljs-attribute">render</span>=<span class="hljs-value">{({</span> <span class="hljs-attribute">loading</span>, <span class="hljs-attribute">error</span>, <span class="hljs-attribute">planet</span> }) =&gt;</span> {
      if (loading) {
        return <span class="hljs-tag">&lt;<span class="hljs-title">LoadingView</span> /&gt;</span>;</span>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (planet) {
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">PlanetView</span> {<span class="hljs-attribute">...planet</span>} /&gt;</span>;</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">ErrorView</span> /&gt;</span>;</span>
      }
    }}
  /&gt;
);</code></pre>

<p><strong>Note:</strong> in the Render Props debate, the performance issue has been raised many times. This post shows how <a href="https://cdb.reacttraining.com/react-inline-functions-and-performance-bdff784f5578">it&#39;s not a straightforward issue</a>. Anytime we talk about performance, we should also be talking about measurements. If you have any doubts about performance on a specific issue, load your profilers and measure it! :)</p>
<p>I tend to feel that the benefits of HOCs versus Render Props vary from situation to situation. At my previous job, we tended to write more Render Props, and at my current job we tend to write more HOCs, and I don&#39;t feel those choices made either of the teams more productive, or the code more readable in general. I feel one pattern is better than the other whenever I see it in the code, but as I said, it&#39;s on a case by case basis. As always, use your better judgment.</p>
<p>The first time I saw the Render Props pattern was in the <a href="https://github.com/chenglou/react-motion">React Motion library</a>. <a href="https://reacttraining.com/react-router/web/api/Route/render-func">React Router v4</a> is another large library implementing it. The two authors are probably the most influential render props enthusiasts, and they have a couple of other <a href="https://reacttraining.com/react-idle/">small libraries</a> <a href="https://reacttraining.com/react-network/">using it</a>.</p>
<p>Render props can also lead to a lot of branching views code, so I feel I also should register here the Branching Render Props variant:</p>
<h3 id="variation-branching-render-props">Variation: Branching Render Props</h3>
<pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DagobahRP</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = { loading: <span class="hljs-literal">true</span> };

  componentDidMount() {
    fetch(<span class="hljs-string">"https://swapi.co/api/planets/5"</span>)
      .then(res =&gt; res.json())
      .then(
        planet =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, planet }),
        error =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, error })
      );
  }

  render() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.loading) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.props.renderLoading();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.planet) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.props.renderPlanet(<span class="hljs-keyword">this</span>.state.planet);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.props.renderError(<span class="hljs-keyword">this</span>.state.error);
    }
  }
}

<span class="hljs-comment">// different callback for different branches:</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">DagobahRP</span>
    <span class="hljs-attribute">renderLoading</span>=<span class="hljs-value">{()</span> =&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-title">LoadingView</span> /&gt;</span>}
    renderError={error =&gt; <span class="hljs-tag">&lt;<span class="hljs-title">ErrorView</span> /&gt;</span>}
    renderPlanet={planet =&gt; <span class="hljs-tag">&lt;<span class="hljs-title">PlanetView</span> {<span class="hljs-attribute">...planet</span>} /&gt;</span>}
  /&gt;
)</span>;</code></pre>

<p>And that&#39;s it.</p>
<h2 id="what-if-the-side-effects-are-costly-">What if the side effects are costly?</h2>
<p>In a lot of situations, the logic provided by the HOC or Render Prop leads to costly code that we want to avoid if possible. The most common case is fetching data remotely. In our Dagobah case, we would like for instance to fetch the planet data only once, and make it available to view components through HOCs or render props. How would we achieve it?</p>
<h2 id="the-provider-pattern">The Provider Pattern</h2>
<p>This is one of the most powerful patterns in React. It&#39;s relatively simple: you gather your data, put it in the React context object, and then in a HOC (or Render Prop) you access the context object and pass it as a prop to the intended components. If you don&#39;t know what the context object is in React, please <a href="https://reactjs.org/docs/context.html">head to the official docs</a>.</p>
<p>Let&#39;s implement it for our Dagobah example. First, we need to implement the <code>DagobahProvider</code>:</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">"prop-types"</span>;

<span class="hljs-comment">// IMPORTANT: we need to define childContextTypes</span>
<span class="hljs-comment">// to be able to access the context object in React</span>
<span class="hljs-keyword">const</span> contextTypes = {
  dagobah: PropTypes.shape({
    loading: PropTypes.bool,
    error: PropTypes.object,
    planet: PropTypes.shape({
      name: PropTypes.string,
      climate: PropTypes.string,
      terrain: PropTypes.string
    })
  })
};

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DagobahProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = { loading: <span class="hljs-literal">true</span> };

  componentDidMount() {
    fetch(<span class="hljs-string">"https://swapi.co/api/planets/5"</span>)
      .then(res =&gt; res.json())
      .then(
        planet =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, planet }),
        error =&gt; <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, error })
      );
  }

  static childContextTypes = contextTypes;

  getChildContext() {
    <span class="hljs-keyword">return</span> { dagobah: <span class="hljs-keyword">this</span>.state };
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.props.children;
  }
}</code></pre>

<p>The provider uses the same logic we had before, and it&#39;s handled in the <code>componentDidMount</code> method. The only difference to the previous implementations is that it adds a <code>dagobah</code> property to the context object, via the <code>getChildContext</code> method. Then, it simply renders its children by returning the children props in the render method.</p>
<p>Now, any component under the provider will have access to the <code>dagobah</code> object inside the context. But accessing the context object in a component is usually considered bad practice, since the context is kind of an &quot;invisible&quot; input, and it makes testing and reasoning about the code a little bit tougher. Let&#39;s implement a HOC to access the context and inject the <code>dagobah</code> object in a component props:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> withDagobah = PlanetViewComponent =&gt;
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    static contextTypes = contextTypes;

    render() {
      <span class="hljs-keyword">const</span> { props, context } = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">PlanetViewComponent</span> {<span class="hljs-attribute">...props</span>} {<span class="hljs-attribute">...context.dagobah</span>} /&gt;</span>;</span>
    }
  };</code></pre>

<p>Easy, right? Notice the <code>contextTypes</code> property: we need it to be defined with the same schema of the provider to be able to access the context. Then, we spread it to the passed component. That way, we can use as many <code>withDagobah</code> in the same screen, and data will only be fetched once!</p>
<p>And of course, we could also access the context through a Render Props:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> DagobahRp = ({ render }, { dagobah }) =&gt; render(dagobah);

DagobahRp.contextTypes = contextTypes;</code></pre>

<p>Very easy too! And this is how we could use it in an application:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> DagobahPlanet = withDagobah(View);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">DagobahProvider</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">DagobahPlanet</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">DagobahPlanet</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">DagobahPlanet</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">DagobahRp</span> <span class="hljs-attribute">render</span>=<span class="hljs-value">{props</span> =&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-title">View</span> {<span class="hljs-attribute">...props</span>} /&gt;</span>} /&gt;
        <span class="hljs-tag">&lt;<span class="hljs-title">DagobahRp</span> <span class="hljs-attribute">render</span>=<span class="hljs-value">{props</span> =&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-title">View</span> {<span class="hljs-attribute">...props</span>} /&gt;</span>} /&gt;
        <span class="hljs-tag">&lt;<span class="hljs-title">DagobahRp</span> <span class="hljs-attribute">render</span>=<span class="hljs-value">{props</span> =&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-title">View</span> {<span class="hljs-attribute">...props</span>} /&gt;</span>} /&gt;
      <span class="hljs-tag">&lt;/<span class="hljs-title">DagobahProvider</span>&gt;</span>
    )</span>;
  }
}</code></pre>

<p>Dagobah is going to be rendered six times, and data will only be fetched once.</p>
<p>A lot of libraries use the Provider pattern, including the aforementioned <a href="https://github.com/reactjs/react-redux">react-redux</a> and <a href="https://reacttraining.com/react-router/web/api/Route/render-func">React Router v4</a>. <a href="https://github.com/yahoo/react-intl">React-intl</a> is also a good example of the pattern.</p>
<p>Going back to the percentages, I would say my React code (and most I&#39;ve come across) is about 99% written using those patterns. The other 1% would be weird integration code with some non-React libraries. Also, most of the main React libraries will fall in one of the categories above! Learn how they work, why they exist and you&#39;ll understand most of the React world :)</p>
<h2 id="summary">Summary</h2>
<p>Regular React components work well most of the time, but it&#39;s better to try separating logic from view. If you need to reuse logic for different view components, use HOCs or Render Props. If the logic involves expensive side effects that should only run once, use a provider.</p>
<p>The code used in this post can <a href="https://github.com/lucasmreis/react-patterns/tree/master/src/planet">be found here</a>.</p>
]]></description>
            <guid isPermaLink="false">Simple React Patterns</guid>
            <pubDate>Mon, 09 Oct 2017 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[The Single Most Important Driver Of Software Quality]]></title>
            <description><![CDATA[<p>So, there I was, ready to press the button. All the while three hundred people were looking at me, thinking &quot;is this guy going to make my work more difficult?&quot;. I had nowhere to hide, and the button needed to be pushed.</p>
<p>My claim: <strong>developers having skin in the game is the <em>main</em> driver of software quality</strong>. If your life depends on the software you are building, you can bet that the software will be of a much higher quality than any software that your life does not depend on.  That being said, there is also the second best scenario of being near <em>people whose lives</em> depend on the quality of your code. I cannot imagine any better factor than skin in the game to drive quality.</p>
<p>But let me start from the beginning.</p>
<p>I work at a large online retail company, with millions and millions of  users. In addition to the millions of users using from home, a modified version of the website is leveraged by a telemarketing sector within my company.  As you may have guessed, these are the three hundred people who were not very comfortable with my presence.</p>
<p>I can&#39;t say that I blame them for being uncomfortable, because they do earn a share of what they sell for the company.  In other words, they have a lot of skin in the game. They don&#39;t use the website as a normal user, to buy something; they use it <em>as a selling tool</em>. If the checkout doesn&#39;t work, they don&#39;t sell, and they don&#39;t make money. Needless to say some of them are thinking, &quot;I&#39;d kill the person who broke this thing!&quot; when the site goes down.</p>
<p>When I pitched my idea to refactor/rewrite a part of our checkout to upper management, they were a little unsure of the project.  First, I tried to sell them on it with a promise of an increase in code quality and better performance, and when they still seemed hesitant, I said, &quot;I&#39;ll deploy the changes to production in the middle of the telemarketers&quot;. At that moment they realized I was serious about idea, and they agreed to sign off on the project.</p>
<p>As soon as I got back to my work station, I felt something different. As always we were very serious about our metrics and processes, and we took every action necessary to be sure the website would not have any problems for our millions of users. But just the thought of deploying the changes to production while at the telemarketing headquarters, next to people who depend on the site to make a living, gave us a different feeling. From early on, everyone on the team worked hard to avert potential disasters down the road.</p>
<p>Not only were we super careful with our code, we also got very engaged with UX, UI, and with the infrastructure of the project. From the very beginning, our team came up with strategies to deploy the application while causing the least impact possible. We created a &quot;panic&quot; link for the telemarketers to go to the previous application. We even developed a new telemarketing-only feature to help them sell additional services and insurance, as an incentive not to press that panic link.</p>
<p>Our website is really large, with lots of different micro-services and different clients interacting, and at this level of complexity, it&#39;s almost inevitable that problems will occur in production, no matter how much testing you do, or how careful you are in your process.  With that in mind, it wasn&#39;t a huge surprise that on deploy day, in the first ten minutes, we had a small problem affecting the sale of gift wrap.</p>
<p>Everybody had been cordial to us from the beginning, but I could feel the tension in the air during those ten minutes. And then, after rolling back and fixing the issue, I could still see that the telemarketers were not very confident. What other errors would affect the sales?</p>
<p>But by the end of the day, everything had gone well. We had anticipated almost every scenario, and we were ready to fix all the problems that were raised. The application started to run smoothly, and no one was using the panic link anymore, success! By the end of a couple of weeks, we learned that services and insurance sales had risen by 20% for telemarketing, and we raised the overall conversion of the website by about 2%.</p>
<p>So, when I see that <a href="https://zapier.com/blog/how-basecamp-uses-basecamp3/">Basecamp uses Basecamp</a>, and <a href="https://www.youtube.com/watch?v=uLrnQtAq5Ec&amp;t=4m10s">the VS Code team uses VS Code to build VS Code itself</a>, I understand why those products have really high quality. They have <em>skin in the game</em>.</p>
<p><em>Final notes</em>: of course this is not a scientific claim :) It is a hypothesis raised from our own experience, and we continue to observe this property in different projects. The effects of skin in the game are usually very well described by some economists and philosophers, and especially by <a href="https://www.amazon.com/Nassim-Nicholas-Taleb/e/B000APVZ7W">Nassim Taleb</a>. He&#39;s actually writing a book called <em>Skin In The Game</em>, and <a href="https://medium.com/incerto/why-each-one-should-eat-his-own-turtles-equality-in-uncertainty-e2b2ee3bcddf">a lot</a> <a href="https://medium.com/incerto/the-skin-of-others-in-your-game-3f51d8ccc3fb">of really</a> <a href="https://medium.com/incerto/no-worship-without-skin-in-the-game-70b4aa341092">interesting chapters</a> <a href="https://medium.com/incerto/an-expert-called-lindy-fdb30f146eaf">are online</a>.</p>
]]></description>
            <guid isPermaLink="false">The Single Most Important Driver Of Software Quality</guid>
            <pubDate>Wed, 31 May 2017 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Type Driven Domain Modelling, part 3]]></title>
            <description><![CDATA[<p><em>This is part 3 of a series:</em></p>
<ul>
<li><a href="http://lucasmreis.github.io/blog/type-driven-domain-modelling-part-1/">Part 1: Types And Property Testing</a></li>
<li><a href="http://lucasmreis.github.io/blog/type-driven-domain-modelling-part-2/">Part 2: Evolving Models</a></li>
</ul>
<p>In this third part of the series, we will add a feature to the basket read model: every line will be more explicit about whether or not it&#39;s being promoted, and what the discount is.</p>
<h2 id="spec">Spec</h2>
<p>Lines in the basket will have one total value if there are no promotions applied. In cases where a promotion is applied, lines in the basket will list the <em>original</em> total value (before discount), the resulting <em>discount</em>, and the <em>final</em> total value after subtracting the discount from the original total.</p>
<h2 id="evolving-the-types">Evolving The Types</h2>
<p>To achieve the new spec, we don&#39;t need to change the Product or the Event. Or In <em>CQRS</em> terms, we don&#39;t need to change the <em>Command</em> side, only the <em>Read</em> side.</p>
<p>Let&#39;s first define a type <code>ReadTotal</code>, that expresses the totals we need to show the user according to the new spec:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">ReadTotal</span> </span>=
    | NotPromoted <span class="hljs-keyword">of</span> Price
    | Promoted <span class="hljs-keyword">of</span> original: Price * discount: Price * final: Price</code></pre>

<p>There we have it: a <code>NotPromoted</code> total that only stores the price, or a <code>Promoted</code> total, that stores the price before, the discount, and the price after the promotion (<code>original</code>, <code>discount</code>, and <code>final</code>).</p>
<p>Now let&#39;s see it in our read models:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Line</span> </span>= {
    productSku: Sku
    quantity: Qty
    lineTotal: ReadTotal
}

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Basket</span> </span>= {
    lines: Line list
    total: ReadTotal
}

<span class="hljs-keyword">let</span> empty = { lines = [] ; total = NotPromoted <span class="hljs-number">0</span> }</code></pre>

<p>That&#39;s everything we need with our types, now let&#39;s go to the functions.</p>
<h2 id="adapting-the-functions">Adapting The Functions</h2>
<p>First, I&#39;m going to rename <code>promotedTotal</code> to <code>promotedFinalTotal</code> - that&#39;s more descriptive of what the function does now:</p>
<pre><code class="hljs fsharp"><span class="hljs-comment">// only changed the function's name</span>
<span class="hljs-keyword">let</span> promotedFinalTotal quantity price promotion =
    <span class="hljs-keyword">let</span> promotedQty = quantity / promotion.promoQty
    <span class="hljs-keyword">let</span> promotedTotal = promotedQty * promotion.promoPrice

    <span class="hljs-keyword">let</span> notPromotedQty = quantity % promotion.promoQty
    <span class="hljs-keyword">let</span> notPromotedTotal = notPromotedQty * price

    promotedTotal + notPromotedTotal</code></pre>

<p>And then we reimplement <code>promotedTotal</code>. This function will calculate the promoted total, and the total without promotion. If the values are different, it returns a <code>Promoted</code>. If the values are not different, it returns a <code>NotPromoted</code>:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> promotedTotal quantity price promotion =
    <span class="hljs-keyword">let</span> final = promotedFinalTotal quantity price promotion
    <span class="hljs-keyword">let</span> original = quantity * price

    <span class="hljs-keyword">if</span> final &lt;&gt; original
    <span class="hljs-keyword">then</span> Promoted(original, original - final, final)
    <span class="hljs-keyword">else</span> NotPromoted(final)</code></pre>

<p>Easy! Now we adapt the <code>lineTotal</code> function to return <code>ReadTotal</code>:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> lineTotal quantity product =
    <span class="hljs-keyword">match</span> product.promotion <span class="hljs-keyword">with</span>
    | None -&gt; NotPromoted(quantity * product.price)
    | Some promotion -&gt; promotedTotal quantity product.price promotion</code></pre>

<p>And we&#39;re done with all the line refactoring :) If we compile the project now, we see that we only have to adapt <code>basketTotal</code> to sum the totals of all the lines. Let&#39;s do it.</p>
<h2 id="summing-readtotals">Summing ReadTotals</h2>
<p>Let&#39;s have a look at the current <code>basketTotal</code> implementation:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> basketTotal lines =
    lines
    |&gt; List.map (<span class="hljs-keyword">fun</span> l -&gt; l.lineTotal)
    |&gt; List.sum</code></pre>

<p><code>List.sum</code> is a simple function that sums all the ints from a list. Another way we could sum the ints could be:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> basketTotal lines =
    lines
    |&gt; List.map (<span class="hljs-keyword">fun</span> l -&gt; l.lineTotal)
    |&gt; List.fold (+) <span class="hljs-number">0</span></code></pre>

<p>This works the same way, but exposes a more generic syntax that we can take advantage of. <code>(+)</code> is the function that sums two ints, and <code>0</code> is an &quot;initial&quot; int; that means that in order to adapt this function to <code>ReadTotal</code> instead of int we only need to implement a function that sums two <code>ReadTotal</code> and an initial total!</p>
<p>To sum two <code>ReadTotal</code>, we have to take into account that both could be either <code>NotPromoted</code> or <code>Promoted</code>. I&#39;ll implement it as four case pattern match, and if you have a better idea, please write it in the comments!</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> sumTotals t1 t2 =
    <span class="hljs-keyword">match</span> t1, t2 <span class="hljs-keyword">with</span>
    | NotPromoted v1, NotPromoted v2 -&gt;
        NotPromoted(v1 + v2)

    | NotPromoted v, Promoted(o, d, f) -&gt;
        Promoted(v + o, d, v + f)

    | Promoted(o, d, f), NotPromoted v -&gt;
        Promoted(v + o, d, v + f)

    | Promoted(o1, d1, f1), Promoted(o2, d2, f2) -&gt;
        Promoted(o1 + o2, d1 + d2, f1 + f2)

<span class="hljs-keyword">let</span> basketTotal lines =
    lines
    |&gt; List.map (<span class="hljs-keyword">fun</span> l -&gt; l.lineTotal)
    |&gt; List.fold sumTotals (NotPromoted <span class="hljs-number">0</span>)</code></pre>

<p>And our new domain is ready! Just run the <code>Experiments.fsx</code> script we <a href="http://lucasmreis.github.io/blog/type-driven-domain-modelling-part-2/">wrote in Part 2</a>, and see the results :)</p>
<h2 id="updating-the-tests">Updating The Tests</h2>
<p>For the &quot;promoted line total&quot; test, we need now to build both the <code>Promoted</code> and <code>NotPromoted</code> expected results:</p>
<pre><code class="hljs fsharp">testProperty <span class="hljs-string">"promoted line total"</span> &lt;| <span class="hljs-keyword">fun</span> (N : Qty) -&gt;
    <span class="hljs-keyword">let</span> price = <span class="hljs-number">10</span>
    <span class="hljs-keyword">let</span> promotedPrice = <span class="hljs-number">7</span>

    <span class="hljs-keyword">let</span> promoQty = N + <span class="hljs-number">2</span>us
    <span class="hljs-keyword">let</span> promotion = { promoQty = promoQty ; promoPrice = promotedPrice }
    <span class="hljs-keyword">let</span> promoted = promotedTotal promoQty price promotion

    <span class="hljs-keyword">let</span> notPromoQty = N + <span class="hljs-number">1</span>us
    <span class="hljs-keyword">let</span> notPromoted = promotedTotal notPromoQty price promotion

    <span class="hljs-keyword">let</span> promotedExpected = Promoted(promoQty * price, promoQty * price - promotedPrice , promotedPrice)
    <span class="hljs-keyword">let</span> notPromotedExpected = NotPromoted(notPromoQty * price)

    Expect.equal promoted promotedExpected <span class="hljs-string">"same price as promotion"</span>
    Expect.equal notPromoted notPromotedExpected <span class="hljs-string">"multiplied by regular price"</span></code></pre>

<p>We can also test that adding any quantity of non-promoted products to a basket with non-promoted lines results in a non-promoted basket:</p>
<pre><code class="hljs fsharp">testProperty <span class="hljs-string">"not promoted products added to not promoted"</span> &lt;| <span class="hljs-keyword">fun</span> (N : Qty) -&gt;
    <span class="hljs-keyword">let</span> initial = {
        lines = [{ productSku = <span class="hljs-string">"a"</span> ; quantity = <span class="hljs-number">3</span>us ; lineTotal = NotPromoted <span class="hljs-number">30</span> }]
        total = NotPromoted <span class="hljs-number">30</span>
    }
    <span class="hljs-keyword">let</span> prod = { sku = <span class="hljs-string">"sku"</span> ; price = <span class="hljs-number">10</span> ; promotion = None }
    <span class="hljs-keyword">let</span> event = AddToBasket(prod, <span class="hljs-number">1</span>us)

    <span class="hljs-keyword">let</span> basket =
        [<span class="hljs-number">1.</span>.(int N + <span class="hljs-number">1</span>)]
        |&gt; List.map (<span class="hljs-keyword">fun</span> _ -&gt; event)
        |&gt; List.fold update initial

    <span class="hljs-keyword">let</span> isNotPromoted =
        <span class="hljs-keyword">match</span> basket.total <span class="hljs-keyword">with</span>
        | NotPromoted _ -&gt; <span class="hljs-keyword">true</span>
        | Promoted _ -&gt; <span class="hljs-keyword">false</span>

    Expect.isTrue isNotPromoted <span class="hljs-string">"should stay not promoted"</span></code></pre>

<p>We can also test that adding any quantity of not promoted products to a basket with a promoted line results in a promoted basket, with the same discount as before:</p>
<pre><code class="hljs fsharp">testProperty <span class="hljs-string">"not promoted products added to promoted"</span> &lt;| <span class="hljs-keyword">fun</span> (N : Qty) -&gt;
    <span class="hljs-keyword">let</span> initial = {
        lines = [{ productSku = <span class="hljs-string">"a"</span> ; quantity = <span class="hljs-number">3</span>us ; lineTotal = Promoted(<span class="hljs-number">30</span>, <span class="hljs-number">11</span>, <span class="hljs-number">19</span>) }]
        total = Promoted(<span class="hljs-number">30</span>, <span class="hljs-number">11</span>, <span class="hljs-number">19</span>)
    }
    <span class="hljs-keyword">let</span> prod = { sku = <span class="hljs-string">"sku"</span> ; price = <span class="hljs-number">10</span> ; promotion = None }
    <span class="hljs-keyword">let</span> event = AddToBasket(prod, <span class="hljs-number">1</span>us)

    <span class="hljs-keyword">let</span> basket =
        [<span class="hljs-number">1.</span>.(int N + <span class="hljs-number">1</span>)]
        |&gt; List.map (<span class="hljs-keyword">fun</span> _ -&gt; event)
        |&gt; List.fold update initial

    <span class="hljs-keyword">let</span> isPromoted =
        <span class="hljs-keyword">match</span> basket.total <span class="hljs-keyword">with</span>
        | NotPromoted _ -&gt; <span class="hljs-keyword">false</span>
        | Promoted(_, discount, _) -&gt;
            <span class="hljs-comment">// asserting here; I know, not very elegant :(</span>
            Expect.equal discount <span class="hljs-number">11</span> <span class="hljs-string">"discount is the same"</span>
            <span class="hljs-keyword">true</span>

    Expect.isTrue isPromoted <span class="hljs-string">"should stay promoted"</span></code></pre>

<p>I think these tests are enough to have a lot of confidence in the code, but of course they don&#39;t assure absolute correctness. So, if you have any other ideas for interesting properties to test, please write it in the comment section!</p>
<h2 id="conclusions">Conclusions</h2>
<p>Now we have a function that transforms a list of events into a relatively complex basket. I really like how the code is very declarative, and is also self explanatory. The type system contributes to that. This, combined with the property tests, makes me feel very confident in the <em>correctness</em> of this code.</p>
<p>As a side note, I&#39;m completely sold on ML languages now :). Not only do I tend to find my code more reliable and safe, it&#39;s also more concise <em>and</em> readable. After these last months experimenting with Elm and F#, I think that ML languages take all the benefits of a dynamic functional language like Clojure to a whole new level.</p>
<p>The final code for the domain is <a href="https://github.com/lucasmreis/basket-promotions-kata/blob/master/BasketPromotions/Domain.fs">here</a>, and the final code for the tests are <a href="https://github.com/lucasmreis/basket-promotions-kata/blob/master/BasketPromotions/Tests.fs">here</a>.</p>
<h2 id="next-steps">Next Steps</h2>
<p>That is my &quot;planned last part&quot; of this series. But this exercise could go in two different directions from here: either building an actual application using this domain model, a web API for example, or evolving the domain model, by adding either new commands or read models. Feel free to share any ideas you have!</p>
]]></description>
            <guid isPermaLink="false">Type Driven Domain Modelling, part 3</guid>
            <pubDate>Wed, 01 Mar 2017 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Type Driven Domain Modelling, part 2]]></title>
            <description><![CDATA[<p><em>This is part 2 of a series:</em></p>
<ul>
<li><a href="http://lucasmreis.github.io/blog/type-driven-domain-modelling-part-1/">Part 1: Types And Property Testing</a></li>
<li><a href="http://lucasmreis.github.io/blog/type-driven-domain-modelling-part-3/">Part 3: One More Spec Change</a></li>
</ul>
<p>We wrote our initial domain in part 1. The user produces an event called <code>AddToBasket</code>, with a product and a quantity. Then we wrote a function that takes a list of events, and produces a read model to send to the client to be rendered.</p>
<p>In this second part we&#39;ll add <em>promotions</em> to products, and make sure total calculations are right!</p>
<h2 id="spec">Spec</h2>
<p>In the second part of the series, we&#39;ll add what I call <em>quantity promotions</em>: they are the classic &quot;buy N for X&quot;. For instance, an item costs $3, but we can buy 2 for $5. This is the promotion we&#39;re going to model in this post.</p>
<h2 id="modelling-a-promotion">Modelling A Promotion</h2>
<p><em>The starting point for this code is <a href="https://github.com/lucasmreis/basket-promotions-kata/blob/master/BasketPromotions/DomainPart1.fs">here</a>.</em></p>
<p>First, let&#39;s start with the Promotion itself, and add it to the Product type:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Promotion</span> </span>= {
    promoQty: Qty
    promoPrice: Price
}

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Product</span> </span>= {
    sku: Sku
    price: Price
    promotion: Promotion option
}</code></pre>

<p>It&#39;s modeled as an Option, since not all products have a promotion.</p>
<p>With that in mind, we need to change the <code>buildLine</code> function to account for promotions. Let&#39;s build a function to calculate the total of a line, given a product and a quantity:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> lineTotal quantity product =
    <span class="hljs-keyword">match</span> product.promotion <span class="hljs-keyword">with</span>
    | None -&gt; quantity * product.price
    | Some promotion -&gt; <span class="hljs-number">0</span> <span class="hljs-comment">// implement it!</span>

<span class="hljs-keyword">let</span> buildLine product quantity = {
    productSku = product.sku
    quantity = quantity
    lineTotal = lineTotal quantity product
}</code></pre>

<p>Everything is working up to this point, but one thing bothers me: because both <code>Qty</code> and <code>Price</code> are aliases for <code>int</code>, the inferred types are often confused:</p>
<p><img src="../assets/wrong-inferring.png" alt="Wrong Inferring"></p>
<p>We could fix this particular case by &quot;forcing&quot; a <code>Qty</code> type to <code>quantity</code>, but I think there&#39;s a bigger message here: quantity and price are <em>not</em> the same thing!</p>
<p>Within our domain, there is one property of quantity that can help us model it: <em>it&#39;s never negative</em>. Another property is that it has to be able to do some arithmetic; we need to be able to sum and divide quantities at least.</p>
<p>Looking through the <a href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/primitive-types">primitives of F#</a>, I found one that can help us: <em>unsigned ints</em>! I think that <code>uint16</code> is a good choice, since it&#39;s a integer with a 0 - 65535 range. As a bonus, it also has all the arithmetic between <code>uint16</code> implemented:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Sku</span> </span>= string
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Price</span> </span>= int
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Qty</span> </span>= uint16</code></pre>

<h2 id="calculating-totals">Calculating Totals</h2>
<p>Now, we can right away see an error in the <code>lineTotal</code> call, since it is inferring that it takes a <code>Price</code>, and not a <code>Qty</code>. Before fixing it, I can see that we&#39;re gonna need an important functionality: we need to be able to multiply a quantity by a price! And it needs to return a price. This is a key function in our domain, so let&#39;s implement it:</p>
<pre><code class="hljs"><span class="hljs-comment">// super cool custom operator!</span>
<span class="hljs-keyword">let</span> (*) (qty : Qty) (price : Price) : Price =
    <span class="hljs-keyword">int</span> qty * price

<span class="hljs-keyword">let</span> lineTotal quantity product =
    <span class="hljs-keyword">match</span> product.promotion with
    | <span class="hljs-built_in">None</span> -&gt; quantity * product.price
    | <span class="hljs-built_in">Some</span> promotion -&gt; <span class="hljs-number">0</span> <span class="hljs-comment">// implement it!</span></code></pre>

<p>Much cleaner. Now, the difficult part: actually calculating the total of a line, when the product is promoted. Let&#39;s do some TDD-ish programming, since it&#39;s easy to make some mistakes in calculations like these. First, a stub of the function itself:</p>
<pre><code class="hljs fsharp"><span class="hljs-comment">// Domain.fs</span>
<span class="hljs-keyword">let</span> promotedTotal quantity price promotion = <span class="hljs-number">0</span>

<span class="hljs-comment">// Tests.fs</span>
(...)

testProperty <span class="hljs-string">"promoted line total"</span> &lt;| <span class="hljs-keyword">fun</span> (N : Qty) -&gt;
    <span class="hljs-keyword">let</span> promoQty = N + <span class="hljs-number">2</span>us <span class="hljs-comment">// notation for unit16</span>
    <span class="hljs-keyword">let</span> promotion = { promoQty = promoQty ; promoPrice = <span class="hljs-number">7</span> }
    <span class="hljs-keyword">let</span> promoted = promotedTotal promoQty <span class="hljs-number">10</span> promotion

    <span class="hljs-keyword">let</span> notPromoQty = N + <span class="hljs-number">1</span>us
    <span class="hljs-keyword">let</span> notPromoted = promotedTotal notPromoQty <span class="hljs-number">10</span> promotion

    <span class="hljs-keyword">let</span> promotedExpected = <span class="hljs-number">7</span>
    <span class="hljs-keyword">let</span> notPromotedExpected = notPromoQty * <span class="hljs-number">10</span>

    Expect.equal promoted promotedExpected <span class="hljs-string">"same price as promotion"</span>
    Expect.equal notPromoted notPromotedExpected <span class="hljs-string">"multiplied by regular price"</span></code></pre>

<p>I also had to correct the other tests to work with the new <code>Product</code> and <code>Price</code> types. The final version of the test file is <a href="https://github.com/lucasmreis/basket-promotions-kata/blob/master/BasketPromotions/Tests.fs">here</a>. Fixing these errors is very direct, since it only involves &quot;getting rid of the red underlinings&quot; that Ionide + the compiler signal. It&#39;s never - ever - that easy in JS, or any other dynamic language for that matter. It&#39;s a much more stressful activity, and stressful activities drain your energy.</p>
<p>The test is simple: if I have a promotion &quot;buy N for $7&quot;, if I add N to the basket, my total is 7. If I add N - 1, my total is (N - 1) * unit price. (I use <code>N + 2us</code> here to guarantee that I don&#39;t have any unwanted zeros).</p>
<p>Now, the implementation:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> promotedTotal quantity price promotion =
    <span class="hljs-keyword">let</span> promotedQty = quantity / promotion.promoQty
    <span class="hljs-keyword">let</span> promotedTotal = promotedQty * promotion.promoPrice

    <span class="hljs-keyword">let</span> notPromotedQty = quantity % promotion.promoQty
    <span class="hljs-keyword">let</span> notPromotedTotal = notPromotedQty * price

    promotedTotal + notPromotedTotal

<span class="hljs-keyword">let</span> lineTotal quantity product =
    <span class="hljs-keyword">match</span> product.promotion <span class="hljs-keyword">with</span>
    | None -&gt; quantity * product.price
    | Some promotion -&gt; promotedTotal quantity product.price promotion</code></pre>

<p>Run the Expecto tests, and there we have it! Working totals :)</p>
<h2 id="experimenting-with-the-domain">Experimenting With The Domain</h2>
<p>Even though the project has no compile errors and the tests are ok, it&#39;s still good practice to experiment with the types and functions. At the very least you will be able to rest easy seeing that everything is working, right?</p>
<p>A good way of doing this is by creating a script file, including our Domain module, and just sending code to F# Interactive. For instance, I created a <code>Experiments.fsx</code> file, with the following contents:</p>
<pre><code class="hljs fsharp">#load <span class="hljs-string">"Domain.fs"</span>

<span class="hljs-keyword">open</span> Domain

<span class="hljs-keyword">let</span> productA = {
    sku = <span class="hljs-string">"a"</span>
    price = <span class="hljs-number">1</span>
    promotion = None
}

<span class="hljs-keyword">let</span> productB = {
    sku = <span class="hljs-string">"b"</span>
    price = <span class="hljs-number">2</span>
    promotion = Some {
        promoQty = <span class="hljs-number">3</span>us
        promoPrice = <span class="hljs-number">5</span>
    }
}

<span class="hljs-keyword">let</span> events = [
    AddToBasket(productA, <span class="hljs-number">5</span>us)
    AddToBasket(productB, <span class="hljs-number">7</span>us)
    AddToBasket(productA, <span class="hljs-number">4</span>us)
]

<span class="hljs-keyword">let</span> myBasket = List.fold update empty events</code></pre>

<p>I created a couple of products, one with a promotion. Then I created a series of events, and built a basket with it. With Ionide it&#39;s easy to run:</p>
<p><img src="../assets/ionide-fsi-send-file.png" alt="FSI Send File"></p>
<p>Now we can play with different products and events, and check the results!</p>
<h2 id="conclusions">Conclusions</h2>
<p>Changing F# code is so smooth, it&#39;s almost fun. And this is a good thing - it&#39;s a sign that it does not <em>drain a lot of energy</em> from the developer. We can focus on the models and algorithms without using a lot of energy with silly errors from the changes we&#39;re making.</p>
<p>Whenever we do a lot of cognitive-intense work, we get tired. There&#39;s no escape to that. And when we get tired, we make mistakes. In the projects I&#39;ve worked on, I think 90% of the simple errors that were deployed to production were deployed by tired developers. So, that&#39;s another positive contribution from F# and its tooling and ecosystem to a project&#39;s <em>safety</em>, in the sense that <em>no unwanted accidents happen in production</em>.</p>
<p>The final code for the domain is <a href="https://github.com/lucasmreis/basket-promotions-kata/blob/master/BasketPromotions/DomainPart2.fs">here</a>, and the final code for the tests are <a href="https://github.com/lucasmreis/basket-promotions-kata/blob/master/BasketPromotions/TestsPart2.fs">here</a>.</p>
<h2 id="next-steps">Next Steps</h2>
<p>Imagine we want not only to show the calculated totals, but we also want to show to our users <em>how much they are saving</em> on each line, and in the basket as a whole. I&#39;ll cover this in Part 3 of this series!</p>
]]></description>
            <guid isPermaLink="false">Type Driven Domain Modelling, part 2</guid>
            <pubDate>Wed, 01 Feb 2017 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Type Driven Domain Modelling, part 1]]></title>
            <description><![CDATA[<p><em>This is part 1 of a series:</em></p>
<ul>
<li><a href="http://lucasmreis.github.io/blog/type-driven-domain-modelling-part-2/">Part 2: Evolving Models</a></li>
<li><a href="http://lucasmreis.github.io/blog/type-driven-domain-modelling-part-3/">Part 3: One More Spec Change</a></li>
</ul>
<p>A while ago I saw this tweet:</p>
<div style="display: flex; justify-content: center">
  <blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Every system tends towards complexity, slowness and difficulty<br>Staying simple, fast and easy-to-use is a battle that must be fought everyday</p>&mdash; Guillermo Rauch (@rauchg) <a href="https://twitter.com/rauchg/status/813529770059186176">December 26, 2016</a></blockquote>
  <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>

<p>I work daily in big javascript projects, so I get where Guillermo is coming from. Javascript doesn&#39;t have types, and doesn&#39;t enforce immutability, so the following things tend to happen in almost every project I&#39;ve come across:</p>
<ol>
<li>The first version is (most of the time) clean and simple. Well chosen libraries being used with the best practices.</li>
<li>As a project grows, big refactorings begin to become more and more &quot;dangerous&quot;. There&#39;s always the risk of having a runtime error that was not caught in dev, and will be caught in production.</li>
<li>New changes, then, become small refactorings, mostly <em>thin layers of code</em> over previous code. A lot of null / undefined testing takes place, unit tests are corrected, and new ones are written.</li>
</ol>
<p>These thin layers of code end up adding bits of complexity to the code. At first it&#39;s manageable, but, months later, the project starts getting more and more difficult to change. The worst effect on these projects is losing <em>reliability</em> and <em>safety</em>: we are not sure the application does what we want it to do, and we are not sure if any hidden bugs will make it to production.</p>
<p>Of course, there are tools to help us deal with this complexity. We&#39;ve been using Typescript at work for a while now, and it has been great. But, from <a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">my previous</a> <a href="http://lucasmreis.github.io/blog/does-elm-harmonize-with-f/#/">experiments here</a> <a href="http://lucasmreis.github.io/blog/from-elm-to-fable/">in the blog</a>, I still think that a &quot;stronger typed&quot; language could help much more to avoid this type of complexity-piling.</p>
<p>So, in this post series, I&#39;ll model a simple e-commerce basket using F#. Then I&#39;ll change the specs and add features of this model, and try to maintain reliability and simplicity in the code. Let&#39;s start!</p>
<h2 id="specs">Specs</h2>
<p>Let&#39;s keep the first spec simple: the user can add a quantity of a product to his basket, he should have access to the current state of the basket, with a calculated total.</p>
<p>The next version should contemplate what I&#39;ll call <em>quantity promotions</em>; it&#39;s the classic <em>buy 3 pay $10</em>, <em>buy 2 pay 5</em> kind of promotion.</p>
<p>On version 3, not only the final price should be shown to the user, but it should also show the price <em>without considering the promotions</em>, and how much discount was given in that product.</p>
<p>On version 4, and final version (maybe?), we should also tell the user, for each line &quot;if you buy another 2 of these, you&#39;ll have an added discount of X!&quot;. This tip will be based in the quantity promotions of each product.</p>
<h2 id="initial-setup">Initial Setup</h2>
<p>I&#39;ll use <a href="https://code.visualstudio.com/">VS Code</a> editor with the <a href="https://github.com/ionide/ionide-vscode-fsharp">Ionide</a> extension to start a new project. I chose to start an &quot;Expecto&quot; project, since it already has a test file configured:</p>
<div style="display: flex">
  <div style="padding-right: 10px">
    <img src="../assets/ionide-new-project.png" alt="Ionide: New Project" style="box-shadow: 5px 5px 14px 0px #999" />
  </div>
  <div>
    <img src="../assets/ionide-expecto.png" alt="Ionide: Expecto" style="box-shadow: 5px 5px 14px 0px #999" />
  </div>
</div>

<p>After the project is created, we need to create a new file. I created a <code>Domain.fs</code> file inside the project folder, together with the <code>Main.fs</code> and <code>Tests.fs</code> that were there. Now - and this is particular to F# - the file needs to be <em>added to the project</em>. In every F# project, we need to specify not only the files to be compiled, but the <em>order in which they should be compiled</em>. That may sound weird and too old-school, but today I agree that <a href="https://fsharpforfunandprofit.com/posts/cyclic-dependencies/">its a good thing</a>, since it helps to avoid circular dependencies among other problems.</p>
<p>So, to add it, open the <code>.fsproj</code> file in the project folder. It&#39;s a big messy XML, I know :) The file ordering is easy to do, though. Just search for the <code>Main.fs</code> file, and you&#39;ll find this XML node:</p>
<pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-title">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">Compile</span> <span class="hljs-attribute">Include</span>=<span class="hljs-value">"Tests.fs"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">Compile</span> <span class="hljs-attribute">Include</span>=<span class="hljs-value">"Main.fs"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">None</span> <span class="hljs-attribute">Include</span>=<span class="hljs-value">"App.config"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ItemGroup</span>&gt;</span></code></pre>

<p>The <code>Domain.fs</code> file needs to be compiled before the other files, so we only need to change the config to:</p>
<pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-title">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">Compile</span> <span class="hljs-attribute">Include</span>=<span class="hljs-value">"Domain.fs"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">Compile</span> <span class="hljs-attribute">Include</span>=<span class="hljs-value">"Tests.fs"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">Compile</span> <span class="hljs-attribute">Include</span>=<span class="hljs-value">"Main.fs"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">None</span> <span class="hljs-attribute">Include</span>=<span class="hljs-value">"App.config"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ItemGroup</span>&gt;</span></code></pre>

<p>This way our file is going to be compiled first, and we can use it in the tests and in the main function.</p>
<h2 id="starting-with-the-domain">Starting With The Domain</h2>
<p>Now we can start to code our model in the <code>Domain.fs</code> file:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">module</span> Domain

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Product</span> </span>= {
    sku: string
    price: int
}

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Event</span> </span>=
    | AddToBasket <span class="hljs-keyword">of</span> Product * int</code></pre>

<p>The first thing I don&#39;t like about this modelling is that we&#39;re using <code>int</code> for the price, and we&#39;re also using <code>int</code> for the quantity in the event. The latter is especially bad, since it&#39;s not clear that it means the quantity of products added to the basket. One way of making it better and more explicit would be:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Sku</span> </span>= string
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Price</span> </span>= int
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Qty</span> </span>= int

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Product</span> </span>= {
    sku: Sku
    price: Price
}

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Event</span> </span>=
    | AddToBasket <span class="hljs-keyword">of</span> Product * Qty</code></pre>

<p>Much better, right?</p>
<p><em>Observation</em>: I&#39;m using int as the price unit because I know that in the first specs I only have to sum and subtract prices. In these situations, I think an integer representing cents are enough. Things get hairy when dividing money, and other more complex conversions. When our model needs that, we will probably need to change from <code>int</code> to something else.</p>
<h2 id="the-basket-read-model">The Basket Read Model</h2>
<p>The user should have access to the current state of the basket, and to the total he or she will have to pay. Let&#39;s first define a <em>line</em>, which is a combination of a sku, a quantity and a total price:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Line</span> </span>= {
    productSku: Sku
    quantity: Qty
    lineTotal: Price
}</code></pre>

<p>Now, the basket read model can be defined as a list of lines and a total to be paid:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Basket</span> </span>= {
    lines: Line list
    total: Price
}</code></pre>

<p>I consider these to be good initial types. Let&#39;s start with these, and make changes when we see the need.</p>
<p>The basket will be built by an <code>update</code> function, that takes a basket and an event as parameters, and returns an updated basket:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> empty = { lines = [] ; total = <span class="hljs-number">0</span> }

<span class="hljs-comment">// wrong implementation so</span>
<span class="hljs-comment">// we can write our test;</span>
<span class="hljs-comment">// this is our main function!</span>
<span class="hljs-keyword">let</span> addToBasket product basket = empty

<span class="hljs-keyword">let</span> update basket event =
    <span class="hljs-keyword">match</span> event <span class="hljs-keyword">with</span>
    | AddToBasket(product, quantity) -&gt;
        addToBasket product basket</code></pre>

<h2 id="the-first-tests">The First Tests</h2>
<p>Before starting the tests, let&#39;s think about some properties of our basket. One good property is <em>if there&#39;s only one line in our basket, it&#39;s total must be the same as the basket&#39;s total</em>. Let&#39;s write a test that makes sure this property holds.</p>
<p>First, we need to install <code>Expecto.FsCheck</code>, which is the library that let&#39;s Expecto run <a href="http://lucasmreis.github.io/blog/learning-elm-part-4/">property based tests</a>. With the <code>paket.dependencies</code> file opened, run the <em>Add Nuget Package</em> command to install the package:</p>
<div style="display: flex">
  <div style="padding-right: 10px">
    <img src="../assets/ionide-add-nuget.png" alt="Ionide: Add Nuget" style="box-shadow: 5px 5px 14px 0px #999" />
  </div>
  <div>
    <img src="../assets/ionide-expecto-fscheck.png" alt="Ionide: Expecto FsCheck" style="box-shadow: 5px 5px 14px 0px #999" />
  </div>
</div>

<p>Now that the package is installed, we need to add the dependency in the project. Open the <code>paket.references</code> file, and add <code>Expecto.FsCheck</code> to the list of dependencies. Then run the install command from Paket:</p>
<div style="display: flex">
  <div style="padding-right: 10px">
    <img src="../assets/ionide-paket-references.png" alt="Ionide: Paket References" style="box-shadow: 5px 5px 14px 0px #999" />
  </div>
  <div>
    <img src="../assets/ionide-paket-install.png" alt="Ionide: Paket Install" style="box-shadow: 5px 5px 14px 0px #999" />
  </div>
</div>

<p>Now, in the <code>Tests.fs</code> file, let&#39;s write the following test:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">open</span> Domain

<span class="hljs-annotation">[&lt;Tests&gt;]</span>
<span class="hljs-keyword">let</span> tests =
    testList <span class="hljs-string">"basket promotions"</span> [
        testProperty <span class="hljs-string">"total of single line"</span> &lt;| <span class="hljs-keyword">fun</span> (quantity : Qty ) (price : Price) -&gt;
            <span class="hljs-keyword">let</span> prod = { sku = <span class="hljs-string">"a"</span> ; price = price }
            <span class="hljs-keyword">let</span> event = AddToBasket(prod, quantity)
            <span class="hljs-keyword">let</span> basket = update empty event

            <span class="hljs-keyword">let</span> lineTotal = basket.lines.Head.lineTotal
            <span class="hljs-keyword">let</span> basketTotal = basket.total

            Expect.equal lineTotal basketTotal <span class="hljs-string">"must be the same as basket total"</span>
    ]</code></pre>

<p>That&#39;s the first property to our model that we&#39;re going to test. Another property is <em>whenever a new product is added, if it&#39;s already in the basket, the number of lines stays the same</em>:</p>
<pre><code class="hljs">testProperty <span class="hljs-string">"adding product multiple times downto the basket"</span> &lt;| <span class="hljs-function"><span class="hljs-keyword">fun</span> (<span class="hljs-title">N</span></span> : uint16 ) -&gt;
    let prod = { sku = <span class="hljs-string">"sku"</span> ; price = <span class="hljs-number">10</span> }
    let event = <span class="hljs-constant">AddToBasket</span>(prod, <span class="hljs-number">1</span>)
    let basket =
        [<span class="hljs-number">1</span>..(int <span class="hljs-constant">N</span> + <span class="hljs-number">1</span>)]
        |&gt; <span class="hljs-constant">List</span>.map (<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">_</span></span> -&gt; event)
        |&gt; <span class="hljs-constant">List</span>.fold update empty

    <span class="hljs-constant">Expect</span>.equal basket.lines.<span class="hljs-constant">Length</span> <span class="hljs-number">1</span> <span class="hljs-string">"must have one line"</span></code></pre>

<p>Note the use of <code>N : uint16</code> in the parameter. I chose it because of the range: it goes from 0 to 65535, so it&#39;s never negative, and it has a reasonable range for this application. Calling <code>(int N + 1)</code> converts it to the desired type and range.</p>
<p>And, of course, the property <em>if we add N different products, our basket will have N lines</em>:</p>
<pre><code class="hljs fsharp">testProperty <span class="hljs-string">"adding multiple products to the basket"</span> &lt;| <span class="hljs-keyword">fun</span> (N : uint16 ) -&gt;
    <span class="hljs-keyword">let</span> prod (num : int) = { sku = <span class="hljs-string">"sku"</span> + num.ToString() ; price = <span class="hljs-number">10</span> }
    <span class="hljs-keyword">let</span> event (num : int) = AddToBasket(prod num, <span class="hljs-number">1</span>)
    <span class="hljs-keyword">let</span> basket =
        [<span class="hljs-number">1.</span>.(int N + <span class="hljs-number">1</span>)]
        |&gt; List.map event
        |&gt; List.fold update empty

    Expect.equal basket.lines.Length (int N + <span class="hljs-number">1</span>) <span class="hljs-string">"must have N lines"</span></code></pre>

<p>These tests seem enough to make sure the function is reliable. If you have any ideas for other basket properties that could be tested, or even some unit tests that seem important, please let me know in the comments!</p>
<h2 id="the-function">The Function</h2>
<p>The <code>addToBasket</code> function should be straightforward: it should add a line with the selected quantity and sku and the calculated total. Then it should calculate the basket total by summing the line totals. The only &quot;gotcha&quot; is that, if the product is already in the basket, the corresponding line should be updated.</p>
<p>So, I&#39;ll start with two helper functions:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> buildLine product quantity = {
    productSku = product.sku
    quantity = quantity
    lineTotal = quantity * product.price
}

<span class="hljs-keyword">let</span> basketTotal lines =
    lines
    |&gt; List.map (<span class="hljs-keyword">fun</span> l -&gt; l.lineTotal)
    |&gt; List.sum</code></pre>

<p>Now, for the actual function, I&#39;ll use this strategy: I&#39;ll <em>transform</em> the Line list so that a line with the same sku as the product being added gets updated. If this transformed list is different than the original line list, that means that the product was already in the basket! If the transformed list is the same, that means we only need to append a new line to the list:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> addToBasket product quantity basket =
    <span class="hljs-keyword">let</span> transformLine line =
        <span class="hljs-keyword">if</span> line.productSku = product.sku
        <span class="hljs-keyword">then</span> buildLine product (line.quantity + quantity)
        <span class="hljs-keyword">else</span> line

    <span class="hljs-keyword">let</span> transformedLines =
        basket.lines
        |&gt; List.map transformLine

    <span class="hljs-keyword">let</span> productAlreadyInBasket =
        transformedLines &lt;&gt; basket.lines

    <span class="hljs-keyword">let</span> lines =
        <span class="hljs-keyword">if</span> productAlreadyInBasket
        <span class="hljs-keyword">then</span> transformedLines
        <span class="hljs-keyword">else</span> (buildLine product quantity)::basket.lines

    { basket <span class="hljs-keyword">with</span> lines = lines ; total = basketTotal lines }</code></pre>

<p>Now run the Expecto tests, and voil! Everything is working :)</p>
<h2 id="conclusions">Conclusions</h2>
<p>It&#39;s incredible how reliable your code can feel when it&#39;s written in a strong typed language with some property tests. This is a trait of ML-type languages like F#, Haskell, Ocaml and Elm, and I think this is the the direction we should look in when looking for reliability and safety.</p>
<p>Speaking on F# in particular, it&#39;s a very &quot;agile&quot; developing experience. Good type inferring, with the tooling that Ionide provides, makes it very easy and quick to experiment with different ways of writing the same thing, while still maintaining correctness through types.</p>
<p>Another good surprise was Expecto, and how easy it was to setup, write and run the tests - even the property based ones.</p>
<p>The final code can be found <a href="https://github.com/lucasmreis/basket-promotions-kata/blob/master/BasketPromotions/DomainPart1.fs">here</a>, and the tests <a href="https://github.com/lucasmreis/basket-promotions-kata/blob/master/BasketPromotions/TestsPart1.fs">here</a>.</p>
<h2 id="next-steps">Next Steps</h2>
<p>Now that we have a simple model working, it&#39;s time to change the specs and add new features. In my next update I&#39;ll add promotions to the products. Stay tuned!</p>
<p>And, as always, I&#39;m constantly learning - and would love to know if some of you have any ideas on how to better implement these specs, or if there&#39;s any library or framework that I&#39;m missing and would make my life easier. Thanks in advance :)</p>
]]></description>
            <guid isPermaLink="false">Type Driven Domain Modelling, part 1</guid>
            <pubDate>Thu, 26 Jan 2017 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[From Elm To Fable]]></title>
            <description><![CDATA[<p>A few months ago I started a <a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">quest to gain reliability in frontend development</a>. I chose Elm as my starting point, from this list:</p>
<ol>
<li>Plain Javascript</li>
<li>Facebook Flow</li>
<li>TypeScript</li>
<li>PureScript</li>
<li>Elm</li>
</ol>
<p>This was a ranking from &quot;not reliable&quot; to &quot;reliable&quot; frontend languages, mainly taking <em>types</em> into consideration. After programming with Elm a bit (and fiding it awesome :) ), I started looking for <a href="http://lucasmreis.github.io/blog/does-elm-harmonize-with-f/#/">other languages with similar characteristics</a>. That was when I found F#, and I&#39;m really impressed by it.</p>
<p>It turns out that there is an F# to JS compiler called <a href="http://fable.io/">Fable</a>. In the ranking, it would be between Typescript and Purescript, because it trades a bit of its &quot;safety&quot; for an easier Javascript interop.</p>
<p>In this post I&#39;ll &quot;convert&quot; the <a href="http://lucasmreis.github.io/blog/learning-elm-part-3/">star wars app I wrote in Elm</a> to Fable, and then I&#39;ll refactor it. Along the way, I&#39;ll compare the experience to both Elm and regular Javascript workflows.</p>
<p>For this post, I&#39;ll presume some familiarity with Elm or other ML languages, mainly that you understand how <em>discriminated unions</em> and <em>pattern matching</em> work. I wrote about these subjects in <a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">part one of the Learning Elm series</a>. Scott Wlaschin has one of the best blogs on typed functional programming that I&#39;ve come across, and has written a <a href="https://fsharpforfunandprofit.com/posts/discriminated-unions/">great article on F# discriminated unions</a>.</p>
<p>Let&#39;s get started!</p>
<h2 id="starting-a-new-fable-project">Starting A New Fable Project</h2>
<p>Elm is very &quot;beginner friendly&quot; - <em>it has always been one of its main goals</em>. This makes it very easy to start out playing with the language, be it with <a href="http://elm-lang.org/try">Try Elm online</a> or using <a href="https://github.com/elm-lang/elm-reactor">Elm Reactor</a> locally. Fable works more like a regular Javascript transpiler; so we need to do the initial pumbling, and then run our project through a local server.</p>
<p>Fortunately, it&#39;s simple. This is what I did: first, I wrote an index.html file that imports a <code>build/bundle.js</code> script:</p>
<pre><code class="hljs html"><span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">'Content-Type'</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">'text/html; charset=utf-8'</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Star Wars - Fable<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"build/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>

<p>Then I globally installed the Fable compiler, and locally installed the <code>fable-core</code> and <code>fable-compiler</code> packages in the project:</p>
<pre><code class="hljs bash">$ npm install -g fable-compiler
$ npm init
$ npm install --save fable-core fable-compiler</code></pre>

<p>Before writing the first F# file, please install the <a href="http://ionide.io/">Ionide extension</a> to VS Code or Atom. It is very powerful, and makes the developing experience very pleasurable. The compiler realtime help is even <em>better</em> than Elm&#39;s! I&#39;ll talk more about this in the conclusion.</p>
<p>Now we can write a F# file, let&#39;s say in <code>src/Main.fsx</code>:</p>
<pre><code class="hljs fsharp">#r <span class="hljs-string">"../node_modules/fable-core/Fable.Core.dll"</span>

<span class="hljs-keyword">open</span> Fable.Import.Browser

console.log(<span class="hljs-string">"It's working!"</span>)</code></pre>

<p>I&#39;ll explain the syntax soon. Now we can build the project by using the <code>fable</code> command with some arguments:</p>
<pre><code class="hljs bash">$ fable src/Main.fsx --outDir ./build --rollup</code></pre>

<p>I&#39;m saying &quot;build the <code>src/Main.fsx</code> file, and save the output in the <code>./build</code> directory, and bundle it using the <a href="http://rollupjs.org/">Rollup bundler!</a>&quot;.</p>
<p>Now, as a last step, to run the built project, choose your favorite simple local server to serve the index.html. I&#39;ve been using <code>http-server</code> and haven&#39;t had any problems:</p>
<pre><code class="hljs bash">$ npm install -g http-server
$ http-server</code></pre>

<p>Just head to <code>http://localhost:8080</code> and we&#39;re running! :)</p>
<h2 id="the-fsx-file">The .fsx File</h2>
<p>The <code>Main.fsx</code> file is a F# script. That&#39;s the format we&#39;re going to use in this project. Let me explain our initial script:</p>
<ul>
<li>Usually in the beginning of the file, the external dependencies are listed. This is how regular F# dll&#39;s are imported:</li>
</ul>
<pre><code class="hljs fsharp">#r <span class="hljs-string">"../node_modules/fable-core/Fable.Core.dll"</span></code></pre>

<p>(If we want to import another .fsx file or a regular .fs F# file we will use the <code>#load</code> command)</p>
<ul>
<li>Then import the modules that&#39;ll be used:</li>
</ul>
<pre><code class="hljs fsharp"><span class="hljs-keyword">open</span> Fable.Import.Browser</code></pre>

<p>This module imports the browser API, like <code>window</code> or <code>console</code>.</p>
<ul>
<li>Now you can write the application code:</li>
</ul>
<pre><code class="hljs fsharp">console.log(<span class="hljs-string">"It's working!"</span>)</code></pre>

<p>That&#39;s everything that&#39;s on an fsx file. Now let&#39;s implement the Star Wars app using Fable.</p>
<h2 id="the-spec">The Spec</h2>
<p>As a reminder, let me rewrite here the application spec:</p>
<blockquote>
<p>The spec is simple: a Star Wars character &quot;card&quot; appears on the left, and corresponding film &quot;cards&quot;, representing the films of the character, are shown on the right.</p>
<p>Clicking on a film &quot;card&quot; displays it on the left, and a list of the characters that appear in the film are shown on the right. And so on.</p>
</blockquote>
<p><img src="../assets/swspec.jpg" alt="Characters And Films"></p>
<p><em>Characters cards will be yellow, and film cards will be blue. By clicking on a card, it changes from one screen to the other.</em></p>
<h2 id="the-chosen-framework">The Chosen Framework</h2>
<p><a href="https://github.com/fable-compiler">Fable&#39;s github page</a> also houses two frameworks: <a href="https://github.com/fable-compiler/fable-elmish">Fable Elmish</a> and <a href="http://fable.io/fable-arch/">Fable Arch</a>. Even though Elmish sounded like the one I would be more familiar with because of previous Elm experience, I chose Arch because it has better documentation - or at least a clear list of sample apps :)</p>
<p>To use it, just install it as you would any npm library:</p>
<pre><code class="hljs bash">$ npm install --save fable-arch</code></pre>

<p>An observation: Fable documentation, in general, is still not great. In fact, it&#39;s almost nonexistent if we compare to Elm or to a lot of Javascript libraries and frameworks. But the samples provided are really good and helpful, and I found them the best source for learning Fable in the first moments.</p>
<p>Another thing worth mentioning: there&#39;s a <a href="https://gitter.im/fable-compiler/Fable">Gitter channel</a> dedicated to Fable. I asked a couple of questions there, and was promptly answered. The people who actually make Fable and the frameworks are there, and they are really trying to help everyone!</p>
<h2 id="the-character-and-film-modules">The Character And Film Modules</h2>
<p>First let&#39;s write the Character and Film modules. They only contain Model and View code. Let&#39;s start with the Character model:</p>
<pre><code class="hljs fsharp">#r <span class="hljs-string">"../node_modules/fable-core/Fable.Core.dll"</span>

<span class="hljs-keyword">module</span> Character =
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Model</span> </span>=
        { name: string
          films: string list }</code></pre>

<p>That is straightforward. Only small syntax differences from Elm, like not needing a comma or writing <code>string list</code> instead of <code>List String</code>.</p>
<p>Now the Character view:</p>
<pre><code class="hljs fsharp">#load <span class="hljs-string">"../node_modules/fable-arch/Fable.Arch.Html.fs"</span>

<span class="hljs-keyword">open</span> Fable.Arch.Html

(...)

    <span class="hljs-keyword">let</span> mainStyle =
        Style
            [ <span class="hljs-string">"background-color"</span>, <span class="hljs-string">"rgba(230, 126, 34,1.0)"</span>
              <span class="hljs-string">"width"</span>, <span class="hljs-string">"200px"</span>
              <span class="hljs-string">"height"</span>, <span class="hljs-string">"200px"</span>
              <span class="hljs-string">"color"</span>, <span class="hljs-string">"white"</span>
              <span class="hljs-string">"font-family"</span>, <span class="hljs-string">"-apple-system, system, sans-serif"</span>
              <span class="hljs-string">"margin"</span>, <span class="hljs-string">"20px 0px 0px 20px"</span>
              <span class="hljs-string">"cursor"</span>, <span class="hljs-string">"pointer"</span> ]

    <span class="hljs-keyword">let</span> nameStyle =
        Style
            [ <span class="hljs-string">"padding"</span>, <span class="hljs-string">"20px"</span>
              <span class="hljs-string">"font-size"</span>, <span class="hljs-string">"18px"</span> ]

    <span class="hljs-keyword">let</span> view model =
        div
            [ mainStyle ; onMouseClick (<span class="hljs-keyword">fun</span> _ -&gt; model) ]
            [ div [ nameStyle ] [ text model.name ] ]</code></pre>

<p>The model code is very similar to the Elm version, but there&#39;s something important to be said here: <em>in F#, all code should be written in compile order</em>. That means that if you use a function or variable in another function, that should be declared earlier in the file. This is different from Elm, and from Javascript (if you declare a function with the <code>function</code> keyword). It seems this is a source of some debate in the F# community, since in regular F# projects you even need to specify the order that the files should be compiled! I have no problem with it. I tend to prefer that the <code>view</code> function comes before the style variables, but I also see that forcing things to be in order can be beneficial to the understanding of the code.</p>
<p>The Film module is then very similar:</p>
 <pre><code class="hljs fsharp"><span class="hljs-keyword">module</span> Film =
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Model</span> </span>=
        { title: string
          episodeId: int
          characters: string list }

    <span class="hljs-keyword">let</span> mainStyle =
        Style
            [ <span class="hljs-string">"background-color"</span>, <span class="hljs-string">"rgba(52, 152, 219,1.0)"</span>
              <span class="hljs-string">"width"</span>, <span class="hljs-string">"200px"</span>
              <span class="hljs-string">"height"</span>, <span class="hljs-string">"200px"</span>
              <span class="hljs-string">"color"</span>, <span class="hljs-string">"white"</span>
              <span class="hljs-string">"font-family"</span>, <span class="hljs-string">"-apple-system, system, sans-serif"</span>
              <span class="hljs-string">"margin"</span>, <span class="hljs-string">"20px 0px 0px 20px"</span>
              <span class="hljs-string">"cursor"</span>, <span class="hljs-string">"pointer"</span> ]

    <span class="hljs-keyword">let</span> nameStyle =
        Style
            [ <span class="hljs-string">"padding"</span>, <span class="hljs-string">"20px"</span>
              <span class="hljs-string">"font-size"</span>, <span class="hljs-string">"18px"</span> ]

    <span class="hljs-keyword">let</span> numberStyle =
        Style
            [ <span class="hljs-string">"padding"</span>, <span class="hljs-string">"20px 20px 0px 20px"</span>
              <span class="hljs-string">"font-size"</span>, <span class="hljs-string">"60px"</span> ]

    <span class="hljs-keyword">let</span> view model =
        div
            [ mainStyle ; onMouseClick (<span class="hljs-keyword">fun</span> _ -&gt; model) ]
            [ div [ numberStyle ] [ text (model.episodeId.ToString()) ]
              div [ nameStyle ] [ text model.title ] ]</code></pre>

<h2 id="the-application-model-and-view">The Application Model And View</h2>
<p>Let&#39;s now define the application model:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Model</span> </span>=
    | InitialScreen
    | LoadingFilms <span class="hljs-keyword">of</span> Character.Model
    | LoadingCharacters <span class="hljs-keyword">of</span> Film.Model
    | FilmsFromCharacter <span class="hljs-keyword">of</span> Character.Model * Film.Model list
    | CharactersFromFilm <span class="hljs-keyword">of</span> Film.Model * Character.Model list
    | ErrorScreen</code></pre>

<p>The application model is a discriminated union, and I just adapted the syntax from the original Elm version. </p>
<p>Let&#39;s convert the views one by one. First <code>InitialScreen</code>:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> messageStyle =
    Style
        [ <span class="hljs-string">"margin"</span>, <span class="hljs-string">"20px 0px 0px 20px"</span>
          <span class="hljs-string">"width"</span>, <span class="hljs-string">"200px"</span>
          <span class="hljs-string">"height"</span>, <span class="hljs-string">"200px"</span>
          <span class="hljs-string">"font-family"</span>, <span class="hljs-string">"-apple-system, system, sans-serif"</span>
          <span class="hljs-string">"color"</span>, <span class="hljs-string">"rgba(149, 165, 166,1.0)"</span>
          <span class="hljs-string">"font-size"</span>, <span class="hljs-string">"18px"</span> ]

<span class="hljs-keyword">let</span> messageView t =
    div [ messageStyle ] [ text t ]

<span class="hljs-keyword">let</span> view model =
    <span class="hljs-keyword">match</span> model <span class="hljs-keyword">with</span>
    | InitialScreen -&gt;
        messageView <span class="hljs-string">"Loading amazing characters and films..."</span>

    | _ -&gt; 
        div [] []</code></pre>

<p>To render the view, we need to call the run <code>createApp</code>. That&#39;s a little different from Elm&#39;s <code>Program</code>:</p>
<pre><code class="hljs fsharp">#load <span class="hljs-string">"../node_modules/fable-arch/Fable.Arch.App.fs"</span>
#load <span class="hljs-string">"../node_modules/fable-arch/Fable.Arch.Virtualdom.fs"</span>

(...)

<span class="hljs-keyword">open</span> Fable.Arch
<span class="hljs-keyword">open</span> Fable.Arch.App.AppApi

(...)

<span class="hljs-keyword">let</span> update model msg = model , []

<span class="hljs-keyword">let</span> initialModel = InitialScreen

createApp initialModel view update Virtualdom.createRender
|&gt; withStartNodeSelector <span class="hljs-string">"#app"</span>
|&gt; start</code></pre>

<p><code>createApp</code> is direct: it needs an initial model, a view function, an update function, and a <em>renderer</em>. The renderer is the engine which will render your application view to the browser dom. Currently we can only use <code>virtual-dom</code>, which is a very fast and mature library, but it seems that <a href="https://github.com/fable-compiler/fable-arch/issues/33">a React renderer is also in the works</a>.</p>
<p>We need to install <code>virtual-dom</code> in our project:</p>
<pre><code class="hljs bash">$ npm install --save virtual-dom</code></pre>

<p>Everything is looking good, right? But try compiling it. It doesn&#39;t, and outputs the following error:</p>
<pre><code class="hljs bash"> fable src/Main.fsx --outDir build --rollup
fable-compiler <span class="hljs-number">0.7</span>.<span class="hljs-number">17</span>: Start compilation...
Compiled fable-arch/Fable.Arch.Html.js at <span class="hljs-number">11</span>:<span class="hljs-number">35</span>:<span class="hljs-number">51</span> PM
Compiled fable-arch/Fable.Arch.App.js at <span class="hljs-number">11</span>:<span class="hljs-number">35</span>:<span class="hljs-number">51</span> PM
Compiled fable-arch/Fable.Arch.Virtualdom.js at <span class="hljs-number">11</span>:<span class="hljs-number">35</span>:<span class="hljs-number">51</span> PM
Compiled src/Main.js at <span class="hljs-number">11</span>:<span class="hljs-number">35</span>:<span class="hljs-number">51</span> PM
Bundling...
[BUNDLE ERROR] <span class="hljs-string">'h'</span> is not exported by node_modules/virtual-dom/index.js (imported by build/fable-arch/Fable.Arch.Virtualdom.js). For <span class="hljs-built_in">help</span> fixing this error see https://github.com/rollup/rollup/wiki/Troubleshooting<span class="hljs-comment">#name-is-not-exported-by-module</span>
(...)</code></pre>

<p>We&#39;re using Rollup to bundle the files. It turns out that Rollup works well with ES6 modules, but may break when using regular CommonJS modules. Since some libraries are written using CommonJS, we need to deal with these cases properly.</p>
<p>We need to configure Rollup to see the <code>virtual-dom</code> module and it&#39;s exported functions, so let me introduce you to the <code>fableconfig.json</code> file.</p>
<p>Instead of calling <code>fable src/Main.fsx --outDir ./build --rollup</code> every time, we can put the compiling configuration inside <code>fableconfig.json</code>. For example, if we have this config:</p>
<pre><code class="hljs json">{
 "<span class="hljs-attribute">outDir</span>": <span class="hljs-value"><span class="hljs-string">"build"</span></span>,
 "<span class="hljs-attribute">projFile</span>": <span class="hljs-value"><span class="hljs-string">"./src/Main.fsx"</span></span>,
 "<span class="hljs-attribute">sourceMaps</span>": <span class="hljs-value"><span class="hljs-literal">true</span>
</span>}</code></pre>

<p>We can just run <code>fable</code> or <code>fable --watch</code> in the terminal and get the same output plus a sourcemap.</p>
<p>Now we can add the Rollup CommonJS configuration:</p>
<pre><code class="hljs json">{
  "<span class="hljs-attribute">outDir</span>": <span class="hljs-value"><span class="hljs-string">"build"</span></span>,
  "<span class="hljs-attribute">projFile</span>": <span class="hljs-value"><span class="hljs-string">"./src/Main.fsx"</span></span>,
  "<span class="hljs-attribute">sourceMaps</span>": <span class="hljs-value"><span class="hljs-literal">true</span></span>,
  "<span class="hljs-attribute">rollup</span>": <span class="hljs-value">{
    "<span class="hljs-attribute">plugins</span>": <span class="hljs-value">[
      [<span class="hljs-string">"commonjs"</span>, {
        "<span class="hljs-attribute">namedExports</span>": <span class="hljs-value">{
          "<span class="hljs-attribute">virtual-dom</span>": <span class="hljs-value">[ <span class="hljs-string">"h"</span>, <span class="hljs-string">"create"</span>, <span class="hljs-string">"diff"</span>, <span class="hljs-string">"patch"</span> ]
        </span>}
      </span>}]
    ]
  </span>}
</span>}</code></pre>

<p>This step is a small complication in our build system. It&#39;s definitely more complex than anything related to an Elm project build, but, on the other hand, it&#39;s the effect of using a very good and used <em>Javascript</em> tool. Efficient bundles are a central and important issue in frontend projects, and since we cannot escape it, I actually like that we are using a good tool for that.</p>
<h2 id="messages-and-the-rest-of-the-views">Messages And The Rest Of The Views</h2>
<p>Before building the other views, let&#39;s define the application Messages. As a reminder: a message is a description of a user action or an event that happens in the application. It is a model of the state <em>transitions</em>. Converting the original messages we have:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Msg</span> </span>=
    | LoadCharacters <span class="hljs-keyword">of</span> Film.Model
    | ToCharactersFromFilm <span class="hljs-keyword">of</span> Film.Model * Character.Model list
    | LoadFilms <span class="hljs-keyword">of</span> Character.Model
    | ToFilmsFromCharacter <span class="hljs-keyword">of</span> Character.Model * Film.Model list
    | FetchFail</code></pre>

<p>Now let&#39;s write one more case for the main view function: </p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> view model =
    <span class="hljs-keyword">match</span> model <span class="hljs-keyword">with</span>
    | InitialScreen -&gt;
        messageView <span class="hljs-string">"Loading amazing characters and films..."</span>

    | LoadingFilms ch -&gt;
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ Character.view ch
              messageView (<span class="hljs-string">"Loading "</span> + ch.name + <span class="hljs-string">" films..."</span>) ]</code></pre>

<p><code>LoadingFilms</code> shows one character and is waiting for the related films to load. If you hover on the <code>view</code> function declaration - or if you are using Ionide, it&#39;s already showing - you&#39;ll see that the function type signature is:</p>
<pre><code class="hljs fsharp">Model -&gt; DomNode&lt;Character.Model&gt;</code></pre>

<p>That means that <code>view</code> is a function that receives a Model and sends messages of type <code>Character.Model</code>. This occurs because of the attribute <code>onMouseClick (fun _ -&gt; model)</code> we wrote in the <code>Character.view</code> that we are calling in this function.</p>
<p>The thing is, we want to send messages of the type <code>Msg</code> we just defined. An error occurs if we add the <code>FilmsFromCharacter</code> case, that calls <code>Film.view</code>:</p>
<pre><code class="hljs fsharp">(...)

    | FilmsFromCharacter (ch, fs) -&gt;
        <span class="hljs-keyword">let</span> filmsView = List.map Film.view fs
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ Character.view ch
              div [] filmsView ]</code></pre>

<pre><code class="hljs bash">$ fable
[ERROR] F<span class="hljs-comment"># project contains errors:</span>
Type mismatch. Expecting a
    <span class="hljs-string">'DomNode&lt;Character.Model&gt; list'</span>    
but given a
    <span class="hljs-string">'DomNode&lt;Film.Model&gt; list'</span>    
The <span class="hljs-built_in">type</span> <span class="hljs-string">'Character.Model'</span> does not match the <span class="hljs-built_in">type</span> <span class="hljs-string">'Film.Model'</span></code></pre>

<p>So, <code>Film.view</code> sends messages of type <code>Film.Model</code>. These are not compatible with <code>Character.Model</code>, which was the message being sent by the function before we wrote the case. This is a great example of the power of F#&#39;s type inference; I don&#39;t know if you noticed, but we haven&#39;t written any type signature so far :) It&#39;s rarely needed in F#, and I still feel the same type power and safety that I felt in Elm. </p>
<p>To make sure that our main <code>view</code> only produces messages of type <code>Msg</code>, we need to <em>map</em> both the Character&#39;s and Film&#39;s <code>view</code> functions to produce it:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> mappedCharacterView model =
    <span class="hljs-keyword">let</span> characterView = Character.view model
    Html.map LoadFilms characterView

<span class="hljs-keyword">let</span> mappedFilmView model =
    <span class="hljs-keyword">let</span> filmView = Film.view model
    Html.map LoadCharacters filmView</code></pre>

<p>Now, just for fun, let&#39;s refactor <code>mappedCharacterView</code>. First of all, we can identify a <em>pipeline</em> there: we transform our model with the <code>view</code> function and then we map it to <code>LoadFilms</code> message. That translates directly to code:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> mappedCharacterView model =
    model
    |&gt; Character.view
    |&gt; Html.map LoadFilms</code></pre>

<p>Which is already simple and clear. There&#39;s another F# operator, the <code>&gt;&gt;</code>. It composes two functions into another one, in the same order as <code>|&gt;</code>. The next rewrite has the same behavior:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> mappedCharacterView model =
    <span class="hljs-keyword">let</span> transform = Character.view &gt;&gt; Html.map LoadFilms
    transform model</code></pre>

<p>When I see a function like that, I immediately think that <code>model</code> and <code>transform</code> are temporary variables that do not add a lot to readability. So I think this is a nice case where a <a href="http://lucasmreis.github.io/blog/pointfree-javascript/">point free function</a> is simple:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> mappedCharacterView =
    Character.view &gt;&gt; Html.map LoadFilms

<span class="hljs-keyword">let</span> mappedFilmView =
    Film.view &gt;&gt; Html.map LoadCharacters</code></pre>

<p>And now we can convert all the views of the application:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> view model =
    <span class="hljs-keyword">match</span> model <span class="hljs-keyword">with</span>
    | InitialScreen -&gt;
        messageView <span class="hljs-string">"Loading amazing characters and films..."</span>

    | LoadingFilms ch -&gt;
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ mappedCharacterView ch
              messageView (<span class="hljs-string">"Loading "</span> + ch.name + <span class="hljs-string">" films..."</span>) ]

    | FilmsFromCharacter (ch, fs) -&gt;
        <span class="hljs-keyword">let</span> filmsView = List.map mappedFilmView fs
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ mappedCharacterView ch
              div [] filmsView ]

    | LoadingCharacters f -&gt;
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ mappedFilmView f
              messageView (<span class="hljs-string">"Loading "</span> + f.title + <span class="hljs-string">" characters..."</span>) ]

    | CharactersFromFilm (f, chs) -&gt;
        <span class="hljs-keyword">let</span> chsView = List.map mappedCharacterView chs
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ mappedFilmView f
              div [] chsView ]

    | ErrorScreen -&gt;
        messageView <span class="hljs-string">"An error ocurred. Please refresh the page and try again - and may the Force be with you!"</span></code></pre>

<p>The syntax is very clean. I like not having to use commas when changing lines, and don&#39;t mind the occasional parenthesis. I love Elm Format and how it formats your code automatically - F# doesn&#39;t have this, but I don&#39;t feel I lose a lot of time with code formatting to get a good look and feel.</p>
<p>Now we can try the views with &quot;mock&quot; application states, for instance:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> char:Character.Model =
    { name = <span class="hljs-string">"Luke Skywalker"</span> ; films = [] }

<span class="hljs-keyword">let</span> film:Film.Model =
    { title = <span class="hljs-string">"A New Hope"</span> ; episodeId = <span class="hljs-number">4</span> ; characters = [] }

<span class="hljs-keyword">let</span> initialModel =
    FilmsFromCharacter ( char , [ film ; film ; film ] )</code></pre>

<p>Run <code>fable &amp;&amp; http-server</code> and reload the browser, and you&#39;ll see it!</p>
<h2 id="the-update-function-and-async-work">The Update Function And Async Work</h2>
<p>Fable Arch resembles Elm in the sense that the <code>update</code> function returns a new model and a list of &quot;actions&quot;. Actions are functions that receive a <code>handler</code> callback parameter; <code>handler</code> is a function that receives a <code>Msg</code> and feeds it back to the update function.</p>
<p>Let&#39;s start with the initial work of the application: getting a character from the API, and transitioning from <code>Initial Screen</code> to <code>LoadingFilms of Character.Model</code>. </p>
<p>We&#39;ll get the entities from the <a href="https://swapi.co/">Star Wars API</a>, so we need to use the browser fetch function. There&#39;s a library called <a href="https://github.com/fable-compiler/fable-powerpack">fable-powerpack</a> that makes it easier to use both fetch and promises with fable:</p>
<pre><code class="hljs bash">$ npm install --save fable-powerpack</code></pre>

<p>And then we can use the following in our project:</p>
<pre><code class="hljs fsharp">#r <span class="hljs-string">"../node_modules/fable-powerpack/Fable.PowerPack.dll"</span>

(...)

<span class="hljs-keyword">open</span> Fable.PowerPack
<span class="hljs-keyword">open</span> Fable.PowerPack.Fetch

(...)

<span class="hljs-keyword">let</span> fetchEntity url =
    promise {
        <span class="hljs-keyword">let!</span> fetched = fetch url []
        <span class="hljs-keyword">let!</span> response = fetched.text()
        <span class="hljs-keyword">return</span> response }</code></pre>

<p><code>promise { ... }</code> is a F# <em>computation expression</em>. There&#39;s nothing like it in Elm - it&#39;s kind of an ES6 generator, or ES7 async/await. Inside the promise block, code is written sequentially, but runs asynchronously. If you define a promise variable using <code>let!</code>, it will wait for the promise to resolve <em>without blocking the thread</em>, and then continue running the code. The code above could be loosely translated to Javascript as:</p>
<pre><code class="hljs js"><span class="hljs-comment">// using promises:</span>
<span class="hljs-keyword">const</span> fetchEntity = url =&gt; fetch(url, {}).then(r =&gt; r.text())

<span class="hljs-comment">// using async/await:</span>
<span class="hljs-keyword">const</span> fetchEntity = url =&gt; {
  <span class="hljs-keyword">const</span> fetched = <span class="hljs-keyword">await</span> fetch(url, {})
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetched.text()
  <span class="hljs-keyword">return</span> response
}</code></pre>

<p>The only difference is that promises run as soon as they are defined, and computation expressions run only when they are actually used. I find this to be better behaviour, and more compatible with the more &quot;famous&quot; F#&#39;s <code>async { ... }</code>.</p>
<p>The inferred type is <code>string -&gt; Promise&lt;string&gt;</code>, but we want the function to return either a Character or a Film model. So we need <code>string -&gt; Character.Model</code> and <code>string -&gt; Film.Model</code> parse functions. So, inside the Film module:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">open</span> Fable.Core.JsInterop

(...)

<span class="hljs-keyword">module</span> Film =
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Model</span> </span>=
        { title: string
          episodeId: int
          characters: string list }

    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">ModelJSON</span> </span>=
        { title: string
          episode_id: int
          characters: string list }

    <span class="hljs-keyword">let</span> parse str =
        <span class="hljs-keyword">let</span> obj = ofJson&lt;ModelJSON&gt; str
        { title = obj.title
          episodeId = obj.episode_id
          characters = obj.characters }

    (...)</code></pre>

<p>I created a record type for the json, so I could use the function <code>ofJson&lt;&#39;a&gt;</code> to convert a string by finding the json keys that are equivalent to <code>&#39;a</code> keys. Then it builds a regular <code>Film.Model</code> with the result.</p>
<p>This function has the signature <code>string -&gt; Film.Model</code>, but if there&#39;s any error in the process, it <em>raises an exception</em>. I&#39;m not an exception fan (it&#39;s not explicit in the type signature!), but it&#39;ll work here because we&#39;ll put it inside a promise computation expression, and it will behave just like it would in Javascript: it will <em>reject</em>, and we&#39;ll treat it in a <code>Promise.catch</code> expression.</p>
<p>The Character module ended up being much simpler:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">module</span> Character =

    (...)

    <span class="hljs-keyword">let</span> parse = ofJson&lt;Model&gt;</code></pre>

<p>Since <code>Model</code> already mirrors the json schema of the API :)</p>
<p>We can now change our <code>fetchEntity</code> function to receive a parser:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> fetchEntity url parser =
    promise {
        <span class="hljs-keyword">let!</span> fetched = fetch url []
        <span class="hljs-keyword">let!</span> response = fetched.text()
        <span class="hljs-keyword">return</span> response |&gt; parser }</code></pre>

<p>And we can write the <code>getFirstCharacter</code> function that fetches the first character of the application:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> getFirstCharacter handler =
    fetchEntity <span class="hljs-string">"http://swapi.co/api/people/1/"</span> Character.parse
    |&gt; Promise.map LoadFilms
    |&gt; Promise.catch ( <span class="hljs-keyword">fun</span> _ -&gt; FetchFail )
    |&gt; Promise.map handler
    |&gt; ignore</code></pre>

<p>It receives <code>handler</code> as a parameter, which is a function that will receive a <code>Msg</code> and feed it back to the appication. <code>ignore</code> is just a function that returns <code>unit</code>, which is F#&#39;s &quot;void&quot;. </p>
<p>The handler is receiving both <code>LoadFilms</code> and <code>FetchFail</code> messages, so let&#39;s implement an initial update function that changes the application state properly, and also call <code>getCharacter</code> in <code>createApp</code>:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> update model msg =
    <span class="hljs-keyword">match</span> msg <span class="hljs-keyword">with</span>
    | LoadFilms ch -&gt; LoadingFilms ch , []
    | FetchFail -&gt; ErrorScreen , []
    | _ -&gt; model , []

(...)

createApp InitialScreen view update Virtualdom.createRender
|&gt; withStartNodeSelector <span class="hljs-string">"#app"</span>
|&gt; withInitMessage getFirstCharacter
|&gt; start</code></pre>

<p>If we run the application, we&#39;ll be able to see the initial screen transitioning to the next screen with real info from the API!</p>
<p>Now the last two functions: <code>getCharacters</code> and <code>getFilms</code>, that get all the related entities of a character or a film:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> getCharacters (film: Film.Model) handler =
    film.characters
    |&gt; List.map ( <span class="hljs-keyword">fun</span> url -&gt; fetchEntity url Character.parse )
    |&gt; Promise.Parallel
    |&gt; Promise.map ( <span class="hljs-keyword">fun</span> chs -&gt; ToCharactersFromFilm (film, List.ofArray chs) )
    |&gt; Promise.catch ( <span class="hljs-keyword">fun</span> _ -&gt; FetchFail )
    |&gt; Promise.map handler
    |&gt; ignore</code></pre>

<p>This function fetchs all the entities in parallel, waits for all the promises to resolve, builds a <code>ToCharactersFromFilm</code> message and calls <code>handler</code>.</p>
<p><code>getFilms</code> is almost mirrored:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> getFilms (character: Character.Model) handler =
    character.films
    |&gt; List.map ( <span class="hljs-keyword">fun</span> url -&gt; fetchEntity url Film.parse )
    |&gt; Promise.Parallel
    |&gt; Promise.map ( <span class="hljs-keyword">fun</span> fs -&gt; ToFilmsFromCharacter (character, List.ofArray fs) )
    |&gt; Promise.catch ( <span class="hljs-keyword">fun</span> _ -&gt; FetchFail )
    |&gt; Promise.map handler
    |&gt; ignore</code></pre>

<p>Now we&#39;ll finish our update (notice the side-effects listed!):</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> update model msg =
    <span class="hljs-keyword">match</span> msg <span class="hljs-keyword">with</span>
    | LoadCharacters f -&gt;
        LoadingCharacters f , [ getCharacters f ]

    | ToCharactersFromFilm ( f , chs ) -&gt;
        CharactersFromFilm ( f , chs ), []

    | LoadFilms ch -&gt;
        LoadingFilms ch , [ getFilms ch ]

    | ToFilmsFromCharacter ( ch , fs ) -&gt;
        FilmsFromCharacter ( ch , fs ), []

    | FetchFail -&gt;
        ErrorScreen , []</code></pre>

<p>And that&#39;s it - the application is up and running without any errors. That&#39;s the sensation you have only with a good compiled language: code running and working at the same time, from the very beginning.</p>
<p>The complete application <a href="https://github.com/lucasmreis/star-wars-fable/blob/master/src/MainFirst.fsx">can be found here</a>.</p>
<h2 id="bonus-refactoring-">Bonus: Refactoring!</h2>
<p>There&#39;s one thing that I really don&#39;t like in this solution: the amount of &quot;almost duplicate&quot; code related to Characters and Films. I feel I&#39;m writing everything twice. I think it came from thinking that Character and Film should be separate modules, and I could not figure out at the time a way to have &quot;generic&quot; modules or something of the sort. So I&#39;ll try now to make it better, and find a better abstraction for Character and Film that does not result in &quot;almost duplicate&quot; code.</p>
<p>I&#39;ll start by defining the models of the entities:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Url</span> </span>= string

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Details</span> </span>=
    | Character <span class="hljs-keyword">of</span> name: string
    | Film <span class="hljs-keyword">of</span> title: string * episode: string

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Entity</span> </span>=
    { related : Url list
      details : Details }</code></pre>

<p>An entity has a generic list of related entities, and a <code>Details</code> property that holds the actual characteristics of a film or a character. Now that we have a generic entity type, we can simplify the application model:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Model</span> </span>=
    | InitialScreen
    | Loading <span class="hljs-keyword">of</span> Entity
    | List <span class="hljs-keyword">of</span> Entity * Entity list
    | ErrorScreen</code></pre>

<p>And we can parse the json using the function:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">CharacterResponseJson</span> </span>=
    { name : string
      films : string list }

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">FilmResponseJson</span> </span>=
    { title : string
      episode_id : int
      characters : string list }

<span class="hljs-keyword">let</span> <span class="hljs-annotation">[&lt;PassGenericsAttribute&gt;]</span> betterOfJson&lt;<span class="hljs-attribute">'a</span>&gt; text =
    <span class="hljs-keyword">try</span>
        <span class="hljs-keyword">let</span> json = ofJson&lt;<span class="hljs-attribute">'a</span>&gt; text
        Some json
    <span class="hljs-keyword">with</span> _ -&gt;
        None

<span class="hljs-keyword">let</span> parse text =
    <span class="hljs-keyword">let</span> chRecord = betterOfJson&lt;CharacterResponseJson&gt; text
    <span class="hljs-keyword">let</span> filmRecord = betterOfJson&lt;FilmResponseJson&gt; text
    <span class="hljs-keyword">match</span> chRecord , filmRecord <span class="hljs-keyword">with</span>
    | Some ch , _ -&gt;
        { related = ch.films
          details = Character ch.name }
    | _ , Some film -&gt;
        { related = film.characters
          details = Film ( film.title , film.episode_id.ToString() ) }
    | _ -&gt;
        failwith <span class="hljs-string">"could not parse entity"</span></code></pre>

<p>Let&#39;s pause a little to understand this function. First, I created the record types to reflect the information I&#39;m looking for in the API&#39;s json schema. Then, I created a function called <code>betterOfJson</code> which is just <code>ofJson</code> returning an <code>option</code>. We have to use the <code>[&lt;PassGenericsAttribute&gt;]</code> so this function works properly when transpiled to Javascript. No need to worry about how it works - the compiler tells you where you need to use it! :)</p>
<p>After that, the parse function is defined. It raises an exception if there&#39;s an error; which, again, I really do not like since it works as a &quot;hidden output&quot;, but we&#39;re going to use it inside a Promise, so it&#39;s not that bad.</p>
<p>In trying to make this function better, I learned another really amazing F# feature: <em>Partial Active Patterns</em>. I wanted to to have this function written somewhat like this:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> parse text =
    <span class="hljs-keyword">match</span> text <span class="hljs-keyword">with</span>
    | IsCharacter ch -&gt; ...
    | IsFilm film -&gt; ...
    | _ -&gt; failwith <span class="hljs-string">"could not parse entity"</span></code></pre>

<p>It turns out that there&#39;s a simple way to achieve that:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> (|IsCharacter|_|) text =
    betterOfJson&lt;CharacterResponseJson&gt; text

<span class="hljs-keyword">let</span> (|IsFilm|_|) text =
    betterOfJson&lt;FilmResponseJson&gt; text</code></pre>

<p>To build a Partial Active Pattern, you have to write a function that returns an <code>option</code>, and has this <code>(|PatternMatchCase|_|)</code> definition. Now you can use both <code>IsCharacter</code> and <code>IsFilm</code> in a pattern match:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> parse text =
    <span class="hljs-keyword">match</span> text <span class="hljs-keyword">with</span>
    | IsCharacter ch -&gt;
        { related = ch.films
          details = Character ch.name }
    | IsFilm film -&gt;
        { related = film.characters
          details = Film ( film.title , film.episode_id.ToString() ) }
    | _ -&gt;
        failwith <span class="hljs-string">"could not parse entity"</span></code></pre>

<p>This is much simpler. This is another feature of F# that makes it stand out.</p>
<p>I&#39;m still not 100% happy with an &quot;exception-throwing&quot; function. If someone knows of a better way to deal with JSON parsing, please let me know in the comment section!</p>
<p>Next, let&#39;s deal with the update part of the application. The messages can be simplified too:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Msg</span></span>
    = Load <span class="hljs-keyword">of</span> Entity
    | ToList <span class="hljs-keyword">of</span> Entity * Entity list
    | FetchFail</code></pre>

<p><code>getFirstCharacter</code> is very similar:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> fetchEntity (url:Url) =
    promise {
        <span class="hljs-keyword">let!</span> fetched = fetch url []
        <span class="hljs-keyword">let!</span> response = fetched.text()
        <span class="hljs-keyword">return</span> parse response }

<span class="hljs-keyword">let</span> getFirstCharacter handler =
    fetchEntity <span class="hljs-string">"http://swapi.co/api/people/2/"</span>
    |&gt; Promise.map Load
    |&gt; Promise.catch ( <span class="hljs-keyword">fun</span> _ -&gt; FetchFail )
    |&gt; Promise.map handler
    |&gt; ignore</code></pre>

<p>And now we only need one <code>getRelatedEntities</code> instead of <code>getCharacters</code> and <code>getFilms</code>:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> getRelatedEntities (entity:Entity) handler =
    List.map fetchEntity entity.related
    |&gt; Promise.Parallel
    |&gt; Promise.map ( <span class="hljs-keyword">fun</span> list -&gt; ToList ( entity , List.ofArray list ) )
    |&gt; Promise.catch ( <span class="hljs-keyword">fun</span> _ -&gt; FetchFail )
    |&gt; Promise.map handler
    |&gt; ignore</code></pre>

<p>And our <code>update</code> function became simpler:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> update model msg =
    <span class="hljs-keyword">match</span> msg <span class="hljs-keyword">with</span>
    | Load entity -&gt; Loading entity , [ getRelatedEntities entity ]
    | ToList ( entity , list ) -&gt; List ( entity , list ) , []
    | FetchFail -&gt; ErrorScreen , []</code></pre>

<p>From this point on, we only need to implement the view functions. This is the final <code>view</code> function (<code>messageView</code> and <code>entityView</code> were ommited for brevity, but <a href="https://github.com/lucasmreis/star-wars-fable/blob/master/src/Main.fsx#L94">can be found here</a>):</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> view model =
    <span class="hljs-keyword">match</span> model <span class="hljs-keyword">with</span>
    | InitialScreen -&gt;
        messageView <span class="hljs-string">"Loading amazing characters and films..."</span>

    | Loading entity -&gt;
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ mappedEntityView entity ; loadingMessageView entity ]

    | List ( entity , list ) -&gt;
        <span class="hljs-keyword">let</span> listView = List.map mappedEntityView list
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ mappedEntityView entity ; div [] listView ]

    | ErrorScreen -&gt;
        messageView <span class="hljs-string">"An error ocurred. Please refresh the page and try again - and may the Force be with you!"</span></code></pre>

<p>Much better, right? It&#39;s always a pleasure to refactor code using an ML language :)</p>
<h2 id="conclusions">Conclusions</h2>
<p>That&#39;s it - we have a completely refactored working version of the Star Wars app. <a href="https://github.com/lucasmreis/star-wars-fable">The complete code is here</a>, and <a href="https://lucasmreis.github.io/star-wars-fable/">the working app is here</a>.</p>
<p><a href="http://lucasmreis.github.io/blog/does-elm-harmonize-with-f/#final-conclusions">I&#39;ve compared Elm and F# before</a>, and this experiment compares both <em>in the same domain</em>: frontend web programming. Here are some of my thoughts on the outcome:</p>
<ul>
<li>Elm is much friendlier for beginners. It has one way to do almost everything, so there&#39;s not many decisions to make when implementing something - it has more of a &quot;puzzle&quot; feel to it. Also, tools like <a href="http://elm-lang.org/try">Try Elm</a> and <a href="https://github.com/elm-lang/elm-reactor">Elm Reactor</a> make it very simple and fast to begin coding and experimenting with the language.</li>
<li>On the other hand, Fable does not hide from you the fact that it&#39;s going to compile to Javascript, and because of that, you have a lot of freedom. For instance, I could immediately make the requests parallel, because promises work just like they do in JS. There was <a href="http://lucasmreis.github.io/blog/learning-elm-part-3/#almost-finishing-our-application-">no default way to do this</a> when I implemented the same app in Elm.</li>
<li>F#&#39;s <em>computation expressions</em> and <em>partial active patterns</em> are really powerful, and make the code more readable and elegant. Actually, it also makes it <em>simpler</em>. There&#39;s nothing like it in Elm.</li>
<li>F#, when used with the Ionide VS Code plugin, is probably the best coding experience I&#39;ve had to date. Elm comes close (and <code>elm-format</code> is great), but hovering in any variable to understand what it is in realtime is an amazing experience. And the type code lenses are really useful too.</li>
</ul>
<h2 id="next-steps">Next Steps</h2>
<p>I enjoyed the Fable experimentation. I&#39;ll continue to look at it, and probably try something with more JS interop to understand better how it would behave in a more real world scenario.</p>
<p>Elm still seems the sensible solution if you have a team of people that are <em>learning</em> functional programming. Elm has a lighter cognitive load, since there&#39;s almost only one way of doing it, and the defaults are very good, making it a great learning tool as well. </p>
<p>Teams looking for more freedom and power, on the other hand, can find it with Fable, while still maintaining most of the reliability and safety from an ML language.</p>
]]></description>
            <guid isPermaLink="false">From Elm To Fable</guid>
            <pubDate>Sat, 10 Dec 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Learning Elm, part 4]]></title>
            <description><![CDATA[<p>As I said in the conclusion of part 1 of this series, the function I wrote in <a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">that post</a> felt very <em>reliable</em>, in a way that&#39;s difficult to achieve with any javascript code.</p>
<p>As a reminder, here is the card type used in the code:</p>
<pre><code class="hljs elm"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Value</span> = <span class="hljs-type">Jack</span> | <span class="hljs-type">Queen</span> | <span class="hljs-type">King</span> | <span class="hljs-type">Ace</span> | <span class="hljs-type">Num</span> <span class="hljs-type">Int</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Suit</span> = <span class="hljs-type">Club</span> | <span class="hljs-type">Diamond</span> | <span class="hljs-type">Spade</span> | <span class="hljs-type">Heart</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Card</span> = <span class="hljs-type">OrdinaryCard</span> <span class="hljs-type">Value</span> <span class="hljs-type">Suit</span> | <span class="hljs-type">Joker</span></span></code></pre>

<p>Looking at these types, a question arises: <em>how can I guarantee that I never end up with an invalid card?</em> By invalid card, I mean something like a thirteen of Clubs, or a minus five of Hearts.</p>
<h2 id="unit-testing">Unit Testing</h2>
<p>The &quot;unsafe&quot; part of the type is the type <code>Value</code>. It&#39;s created by the function <code>parseNumValue</code>, which has the type:</p>
<pre><code class="hljs elm"><span class="hljs-title">parseNumValue</span> : <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Value</span></code></pre>

<p>By testing the <code>parseNumValue</code> function, we&#39;ll be able to raise the reliability of the code as a whole.</p>
<p>Unit testing pure functions is very simple: we define some example cases of the function, and then define the expected return values. Let&#39;s use the library <code>elm-test</code> for our tests.</p>
<p>Installing Elm Test is easy, <a href="https://github.com/elm-community/elm-test#running-tests-locally">as described here</a>:</p>
<ol>
<li>Run <code>npm install -g elm-test</code> if you haven&#39;t already.</li>
<li><code>cd</code> into the project&#39;s root directory that has your <code>elm-package.json</code>.</li>
<li>Run <code>elm-test init</code>. It will create a <code>tests</code> directory inside this one, with some files in it.</li>
<li>Copy all the dependencies from <code>elm-package.json</code> into
<code>tests/elm-package.json</code>. These dependencies need to stay in sync, so make sure whenever you change your dependencies in your current
<code>elm-package.json</code>, you make the same change to <code>tests/elm-package.json</code>.</li>
<li>Run <code>elm-test</code>.</li>
<li>Edit <code>tests/Tests.elm</code> to introduce new tests.</li>
</ol>
<p>After writing the unit tests, this is how my <code>Tests.elm</code> file looks:</p>
<pre><code class="hljs elm">module Tests exposing (..)

import Test exposing (..)
import Expect
import Cards exposing (..)


all : Test
all =
    describe "parseNumValue"
        [ test "cannot be less than 2"
            &lt;| \() -&gt; Expect.equal (parseNumValue "1") Nothing
        , test "minimum of 2"
            &lt;| \() -&gt; Expect.equal (parseNumValue "2") (Just (Num 2))
        , test "maximum of 10"
            &lt;| \() -&gt; Expect.equal (parseNumValue "10") (Just (Num 10))
        , test "cannot be more than 10"
            &lt;| \() -&gt; Expect.equal (parseNumValue "11") Nothing
        ]</code></pre>

<p>The syntax is direct: you describe a test suite, and then define the tests inside a list. I tested the &quot;corner cases&quot; of the function, to make sure that any value less than 2 or greater than 10 will not be parsed to a Card. I also like that tests in general also work as documentation to show how the function is supposed to behave.</p>
<p>So, unit tests raise reliability, but could they do better? What would happen if we call the <code>parseNumValue</code> function with the string &quot;100&quot;? Or the string &quot;-22&quot;? Is it possible to write more general tests, that answer the more powerful question <em>can I guarantee that only integers between 2 and 10 get converted to a Value, and no others</em>?</p>
<h2 id="property-based-testing">Property Based Testing</h2>
<p>Property Based Testing is very interesting because it allows you to test a whole set of values. For instance, let&#39;s pretend that we have at our disposal the set of all integers. If we transform them into strings, we have the perfect inputs for testing <code>parseNumValue</code>.</p>
<p>Elm Test has an easy way of doing property based tests. Instead of using the <code>test</code> function, you will use <code>fuzz</code> function, specify a &quot;fuzzer&quot;, and write your test using the generated value as a parameter:</p>
<pre><code class="hljs elm">(...)

<span class="hljs-import"><span class="hljs-keyword">import</span> Fuzz <span class="hljs-keyword">exposing</span> <span class="hljs-container">(..)</span></span>

(...)

, fuzz int <span class="hljs-string">"parseNumValue"</span>
    &lt;| \number -&gt;
        <span class="hljs-keyword">let</span>
            parsed =
                number
                    |&gt; toString
                    |&gt; parseNumValue
        <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">case</span> parsed <span class="hljs-keyword">of</span>
                <span class="hljs-type">Just</span> (<span class="hljs-type">Num</span> v) -&gt;
                    <span class="hljs-type">Expect</span>.true
                        <span class="hljs-string">"Number should be &gt;= 2 and &lt;= 10 when Just Num v"</span>
                        (v &gt;= <span class="hljs-number">2</span> &amp;&amp; v &lt;= <span class="hljs-number">10</span>)

                _ -&gt;
                    <span class="hljs-type">Expect</span>.false
                        <span class="hljs-string">"Number should not be &gt;= 2 and &lt;= 10 when Nothing"</span>
                        (number &gt;= <span class="hljs-number">2</span> &amp;&amp; number &lt;= <span class="hljs-number">10</span>)</code></pre>

<p>This test is direct: it generates an <code>int</code> and passes it as a parameter to the testing function - that&#39;s why we&#39;re using <code>\number -&gt; ...</code>. Then we convert the number to a string and parse it with our <code>parseNumValue</code> function.</p>
<p>We are testing for the following: if the result of the parse is a <code>Just (Num v)</code>, then the number was something between two and ten. And, if the result is <code>Nothing</code>, the number was either smaller than 2 or greater than 10.  That is what we are asserting in the pattern matching section of the test.</p>
<p>How does it work? It&#39;s simple: <code>fuzz int</code> generates a bunch of random integers, and runs a test for each integer generated. That way, it&#39;s almost the same as writing a lot of <code>test</code> functions for a lot of integer values.</p>
<p><em>Observation</em>: during these tests, I found a little problem: the key values of 1, 2, 10 and 11 were <em>not</em> tested every time. That means I could have a false positive! The fuzz test would say everything is ok, but my function could have an error and I would end up with a <code>Just (Num 11)</code>. The solution to this could be raising the number of random integers tested, but I could not find a way to do it. If you have an idea of how to deal with this situation, please comment below it in the comments section!</p>
<p>In the end, I maintained the four unit tests that I knew were important cases, and added the fuzz test. <a href="https://github.com/lucasmreis/learning-elm/blob/master/part-4/tests/Tests.elm">Here&#39;s how the final test file looks</a>.</p>
<p>I believe the solution feels much more reliable with the addition of the property based tests. But one thing still bothers me: the fact that, if I do not use the parsers to build a card, I can still have an invalid card like <code>Just (Num 11)</code>.</p>
<h2 id="can-we-do-better-">Can We Do Better?</h2>
<p>Our cards have a small finite domain. Instead of having a <code>Num Int</code> case for the <code>Value</code> type, we could be explicit about every value possible:</p>
<pre><code class="hljs elm"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Value</span></span>
    = <span class="hljs-type">Jack</span>
    | <span class="hljs-type">Queen</span>
    | <span class="hljs-type">King</span>
    | <span class="hljs-type">Ace</span>
    | <span class="hljs-type">Two</span>
    | <span class="hljs-type">Three</span>
    | <span class="hljs-type">Four</span>
    | <span class="hljs-type">Five</span>
    | <span class="hljs-type">Six</span>
    | <span class="hljs-type">Seven</span>
    | <span class="hljs-type">Eight</span>
    | <span class="hljs-type">Nine</span>
    | <span class="hljs-type">Ten</span>


<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Suit</span></span>
    = <span class="hljs-type">Club</span>
    | <span class="hljs-type">Diamond</span>
    | <span class="hljs-type">Spade</span>
    | <span class="hljs-type">Heart</span>


<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Card</span></span>
    = <span class="hljs-type">OrdinaryCard</span> <span class="hljs-type">Value</span> <span class="hljs-type">Suit</span>
    | <span class="hljs-type">Joker</span></code></pre>

<p>This modelling is very simple and direct, but it&#39;s also <em>powerful</em>. It is literally impossible to represent an invalid card. This is what <a href="https://vimeo.com/14313378">Yaron Minsky</a>, <a href="https://vimeo.com/162036084">Mark Seemann</a>, <a href="http://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/">Scott Wlaschin</a> and <a href="https://www.youtube.com/watch?v=IcgmSRJHu_8">Richard Feldman</a> mean when they say &quot;make illegal states unrepresentable&quot;. All these talks are amazing, and illustrate very well the benefits of having types that simply do not allow invalid models to be represented, and also cover techniques to achieve that.</p>
<p>And now we have a much more robust set of functions to parse and &quot;pretty print&quot; cards. (<a href="https://github.com/lucasmreis/learning-elm/blob/master/part-4/src/SafeCards.elm">The whole final code with the new types is here</a>).</p>
<h2 id="is-it-always-a-possibility-">Is It Always A Possibility?</h2>
<p>I tend to think that we were kind of &quot;lucky&quot; here, in the sense that a normal deck of cards has about nine numbered cards only. It&#39;s easier to enumerate every case in that sense, but I do not know if it would be practical to do that if the numbered cards were in the 2 - 100 range, for example.</p>
<p>I think that the simple way of dealing with it is to always first try to have all your modeling constraints through types. For example, imagine that the only way to have a user name is through logging in. That means that instead of:</p>
<pre><code class="hljs elm"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">User</span> =</span>
    { isLogged : <span class="hljs-type">Bool</span>
    , name : <span class="hljs-type">String</span>
    }</code></pre>

<p>You should have:</p>
<pre><code class="hljs elm"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">User</span></span>
    = <span class="hljs-type">NotLogged</span>
    | <span class="hljs-type">Logged</span> <span class="hljs-type">String</span></code></pre>

<p>With the second modeling, you never have the risk of having a NotLogged user with a name. That means you <em>don&#39;t need a test to assure that a constructed user is invalid</em>. This is what I mean by powerful! :)</p>
<p>And what do I do if I can&#39;t model my domain that way? For example, what do I do if I have a deck of cards with numbered cards ranging from 2 to 1000? In this case, I think that testing your constructors with property based tests is the way to go.</p>
<p><em>Observation</em>: even when your typings make illegal states unrepresentable, unit and property based tests are still useful when testing <em>state transitions</em>. In our User example, it&#39;s useful to test if &quot;logging out function results in a NotLogged User&quot;. So, even though good type modeling lowers the need for tests, <em>tests are still useful for making your code reliable</em>.</p>
<p>One last remark: we could represent our 1000 card deck using only types if we could have a &quot;bounded integer&quot; type, such as, &quot;this is an integer larger than X and smaller than Y&quot;. This would be a type that is <em>dependent on values</em>, and it&#39;s not possible to do in Elm. Actually, it seems it&#39;s not possible to do in any mainstream language. :(</p>
<p><a href="http://stackoverflow.com/questions/9338709/what-is-dependent-typing">This stack overflow question</a> explains dependent typing very directly, and <a href="https://en.wikipedia.org/wiki/Dependent_type">here&#39;s a list of languages with dependent typing</a> so we can research more about it. <a href="http://www.idris-lang.org/example/">Idris</a> looks particularly nice!</p>
]]></description>
            <guid isPermaLink="false">Learning Elm, part 4</guid>
            <pubDate>Wed, 02 Nov 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Does Elm Harmonize With F#?]]></title>
            <description><![CDATA[<p>After <a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">experimenting with Elm</a>, I was hooked. I could feel that working with a smart type system brought both <em>reliability</em>, in the sense of &quot;it does what I want it to do&quot;, and <em>safety</em>, in the sense of &quot;it does not have bugs&quot;.</p>
<p>Elm&#39;s main focus is the front end (<a href="https://github.com/ElmCast/elm-node">even though</a> <a href="https://github.com/Fresheyeball/elm-http-server">some work</a> <a href="https://github.com/eeue56/servelm">is being done</a>), so a natural next question could be <em>What would using an Elm-like language in the server be like</em>? And by &quot;Elm-like&quot; I mean a language with immutable data structures as default, encouraging expressions over statements, and of course, having those cool discriminated unions we all learned to love. :)</p>
<p>After doing some quick research, my finalists were Haskell, Ocaml and F#. A former coworker was always saying good things about F#, and after seeing things like <a href="http://fsharp.github.io/FSharp.Data/">FSharp.Data</a>, <a href="https://developer.xamarin.com/guides/cross-platform/fsharp/fsharp_support_overview/">Xamarin</a> and <a href="https://fsharpforfunandprofit.com/">this amazing blog</a>, I decided to go with F#.</p>
<h2 id="setting-up">Setting Up</h2>
<p>The first week with F# was not easy. I was a little clueless about where to get started since I don&#39;t have a Windows machine. So, I downloaded Xamarin Studio, and used it for a couple of days. It&#39;s a good IDE with a so so editor, so I started looking for some alternatives.</p>
<p>Every F# project needs a <code>*.fsproj</code> config file, which is a big messy XML that is not meant to be changed by &quot;human beings&quot; (as opposed to the simpler <code>package.json</code> from Node or <code>elm-package.json</code> from Elm). But it turns out that the F# open source community has built some nice tools to deal with it. Summing up, install the <a href="http://ionide.io/">Ionide</a> extension to VS Code or Atom, and everything will be easier.</p>
<p>My programming workflow then became: start coding something, and &quot;send&quot; the code little by little to the REPL. Define some types, send to the REPL. Write a function, send to the REPL. Write some use cases, send to the REPL. It&#39;s the exact same workflow I used with Clojure, and it leads to a lot of early feedback and agility from the very beginning.</p>
<p>With F# up and running, I decided to implement a simple project to learn the language.</p>
<h2 id="the-project">The Project</h2>
<p>My wife was a girl scout when she was a kid. She told me about a common girl scout activity in the US, which is selling cookies door to door to raise money for their girl scout activities. I found that was a cool tradition, so I decided to implement a girl scout cookie selling dashboard! :)</p>
<p>The requirements are: each scout somehow send commands like &quot;Visit House&quot; or &quot;Sell 5 Cookies&quot; to the server. The server validates the command, and broadcast events like &quot;Maggie Just Visited A House&quot; or &quot;Lisa Just Sold 5 Cookies&quot; to the dashboards, that are updated in realtime and consolidate all the information.</p>
<h2 id="the-domain-model">The Domain Model</h2>
<p>Each scout can be modelled as a &quot;state machine&quot;. This is where these type systems really shine. F#, like Elm, has union types and pattern matching, so the code was pretty similar. For instance:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">ScoutState</span> </span>=
    | Walking
    | Visiting
    | HavingFun

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">ScoutCommand</span> </span>=
    | StartDay
    | VisitHouse
    | Sell <span class="hljs-keyword">of</span> int
    | HaveFun

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">ScoutEvent</span> </span>=
    | DayStarted
    | HouseVisited
    | Sold <span class="hljs-keyword">of</span> int
    | DayFinished

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">ScoutError</span> </span>=
    | ShouldBeHavingFun
    | ShouldBeWalking
    | ShouldBeVisiting</code></pre>

<p>A word about Commands and Events: when programming in Elm, &quot;everything&quot; that happened in the application was called a Message. The Update function understands the Messages, updates the state accordingly, and then emits or not new Messages.</p>
<p>When reading about F#, I came across lots of reading materials on Domain Driven Design (DDD), Event Sourcing and Command Query Responsibility Segregation (CQRS). One of the nice ideas I&#39;ve read is the <em>separation between Commands and Events</em> among the Messages.</p>
<p>Every time a user wants to change the domain, it issues a Command. If the Command actually changes the domain, an Event is generated. An Event represents things that actually happened to the domain. For example, if a scout issues a Command <code>Sell 3</code>, the server checks if it&#39;s a valid Command for the actual State, and if it&#39;s ok it issues an Event <code>Sold 3</code>. If it&#39;s not valid, let&#39;s say the scout was not visiting any house, it returns a <code>ShouldBeVisiting</code> error, and the State is not updated.</p>
<p>The cool part is that we can store all the Events, and query them at will. The present State is a replay of all the past Events! That&#39;s what Event Sourcing is all about, and I really recommend watching <a href="https://www.youtube.com/watch?v=8JKjvY4etTY">every video you can</a> <a href="https://www.youtube.com/watch?v=kZL41SMXWdM">from Greg Young</a>, <a href="https://www.youtube.com/watch?v=LDW0QWie21s">the &quot;father&quot; of the Event Sourcing pattern</a>.</p>
<p>With that in mind, this is the final state machine representation of the scouts:</p>
<p><img src="../assets/scouts-model.png" alt="Scout&#39;s Model"></p>
<p><a href="https://github.com/lucasmreis/AmazingCookies/blob/master/src/Domain/Domain.fs">The final code for the domain is here</a>.</p>
<h2 id="a-simple-event-store">A Simple Event Store</h2>
<p>The events produced by the server need to be stored somewhere. To continue the learning experience, I decided to implement the simplest in-memory event store I could think of. It should be able to store every event, broadcast them to listeners, and that&#39;s it.</p>
<p>Since the store actually stores data, and this data is accessed through methods, I thought that modelling the store as an <em>object</em> would be ok. Yes, it&#39;s the kind of object that we try to escape with functional programming, but it still has it uses :)</p>
<p>It was also good to see that &quot;object oriented programming&quot; with F# is very simple, and has almost no boilerplate. You just declare a type with <code>()</code> near the name, and declare &quot;members&quot; of the type. For instance:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">EventStore</span></span>() =
    <span class="hljs-keyword">let</span> eventList =
        <span class="hljs-keyword">new</span> ResizeArray&lt;String * ScoutEvent&gt;()

    <span class="hljs-keyword">member</span> this.Save(name, events) =
        events |&gt; List.iter (<span class="hljs-keyword">fun</span> e -&gt; eventList.Add(name, e))

    <span class="hljs-keyword">member</span> this.Get() =
        eventList</code></pre>

<p>When instanced with <code>let store = new EventStore()</code>, this object creates an array of <code>String * ScoutEvent</code> tuples. This will hold all the events produced by the application, together with the scout&#39;s name that produced the event.</p>
<p>F# has a very interesting feature called <em>computation expressions</em>. <a href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions">The docs</a> describe it as <em>a convenient syntax for writing computations that can be sequenced and combined using control flow constructs and bindings</em>. I do not know of an easier way to describe it, so let me show two examples, <code>async</code> and <code>seq</code>:</p>
<pre><code class="hljs fsharp"><span class="hljs-comment">// First example</span>

<span class="hljs-comment">// this works just like Javascript's async/await,</span>
<span class="hljs-comment">// or Clojure's core.async</span>
<span class="hljs-keyword">let</span> asyncFetchedDocument = async {
    <span class="hljs-keyword">let</span> url = <span class="hljs-string">"http://some-url.com/api"</span>

    <span class="hljs-comment">// this line will wait for the response without blocking the thread</span>
    <span class="hljs-keyword">let!</span> res = someAsyncFetchFunction url

    <span class="hljs-keyword">return</span> res.data }

<span class="hljs-keyword">let</span> fetchedDocument =
    Async.RunSynchronously asyncFetchedDocument


<span class="hljs-comment">// Second example</span>

<span class="hljs-comment">// this produces a lazy sequence</span>
<span class="hljs-keyword">let</span> lazySeq = seq {
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> .. <span class="hljs-number">5</span> <span class="hljs-keyword">do</span>
      <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>
        <span class="hljs-keyword">yield</span> i
        <span class="hljs-keyword">yield</span> -i }

<span class="hljs-keyword">let</span> list =
    Seq.toList lazySeq
<span class="hljs-comment">// =&gt; [2; -2; 4; -4]</span></code></pre>

<p>In the event store I wrote, I used a <code>query</code> computation expression to get all the events from a given name in the EventStore:</p>
<pre><code class="hljs fsharp">...

<span class="hljs-keyword">member</span> this.Get(name) =
    query {
        <span class="hljs-keyword">for</span> (n, ev) <span class="hljs-keyword">in</span> eventList <span class="hljs-keyword">do</span>
        where (n = name)
        select ev
    } |&gt; Seq.toList

...</code></pre>

<p>That&#39;s really cool, right? It feels like a strongly typed SQL :) I feel that Elm would strongly benefit from something like this.</p>
<p>So, to finish the EventStore, I needed a pub/sub to the saved events:</p>
<pre><code class="hljs fsharp">...

  <span class="hljs-keyword">let</span> saveEvent =
      <span class="hljs-keyword">new</span> Event&lt;'Key * 'Event&gt;()

  <span class="hljs-keyword">member</span> this.SaveEvent =
      saveEvent.Publish

  <span class="hljs-keyword">member</span> this.Save(name, events) =
      events |&gt; List.iter (<span class="hljs-keyword">fun</span> e -&gt; eventList.Add(name, e))
      events |&gt; List.iter (<span class="hljs-keyword">fun</span> e -&gt; saveEvent.Trigger((name, e)))

...</code></pre>

<p>The events are published at <code>SaveEvent</code>, and saving an event triggers the listeners. An example subscription would be:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> logger ev = printfn <span class="hljs-string">"-- EVENT: %A"</span> ev

store.SaveEvent.Add(logger)</code></pre>

<p><a href="https://github.com/lucasmreis/AmazingCookies/blob/master/src/EventStore/EventStore.fs">The complete EventStore, with generic typing, is here</a>.</p>
<h2 id="a-server">A Server</h2>
<p>Years ago I worked with C#, and wrote a server with ASP.NET MVC. In this project, I thought I was going to write the server using F#/C# &quot;interop&quot; (and I was not very happy about it :) ). Fortunately, I came across an &quot;F# native&quot; web server framework called <a href="https://suave.io/">Suave</a>. Suave in Portuguese means <em>smooth</em>, and that&#39;s exactly how it feels to write a server with this framework!</p>
<p>For instance, look at the final code for the server:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> app store =
    choose [
        path <span class="hljs-string">"/"</span>          &gt;=&gt; Files.sendFile <span class="hljs-string">"build/index.html"</span> <span class="hljs-keyword">true</span>
        path <span class="hljs-string">"/dashboard"</span> &gt;=&gt; Files.sendFile <span class="hljs-string">"build/dashboard.html"</span> <span class="hljs-keyword">true</span>
        path <span class="hljs-string">"/websocket"</span> &gt;=&gt; handShake (eventSocket store)
        path <span class="hljs-string">"/command"</span>   &gt;=&gt; POST &gt;=&gt; request(commandRequest store)
        ServerErrors.INTERNAL_ERROR <span class="hljs-string">"Sorry, route not valid!"</span> ]</code></pre>

<p>Really clear, right? Writing this server was very easy. The routes are defined through function composition, and Suave comes with some functions that define standard server behaviors, like <code>Filters.POST</code>, <code>Files.sendFile</code> and <code>ServerErrors.INTERNAL_ERROR</code>.</p>
<p>I found one problem while trying to make it work: <em>there&#39;s simply no documentation on working with websockets</em>. After googling it, the material I found was from a couple of StackOverflow questions, and <a href="https://github.com/SuaveIO/suave/blob/master/examples/WebSocket/Program.fs">this example from the project&#39;s github</a>.</p>
<p>It took some time, but, after a few hours, I was able to make it work. This is part of the final code for the socket code:</p>
<pre><code class="hljs fsharp">...

socket {
    <span class="hljs-keyword">let</span> loop = ref <span class="hljs-keyword">true</span>
    <span class="hljs-keyword">while</span> !loop <span class="hljs-keyword">do</span>
        <span class="hljs-keyword">let!</span> msg = webSocket.read()
        <span class="hljs-keyword">match</span> msg <span class="hljs-keyword">with</span>
        | (Ping, _, _) -&gt; <span class="hljs-keyword">do!</span> webSocket.send Pong [||] <span class="hljs-keyword">true</span>
        | (Close, _, _) -&gt;
            <span class="hljs-keyword">do!</span> webSocket.send Close [||] <span class="hljs-keyword">true</span>
            subscription.Dispose()
            loop := <span class="hljs-keyword">false</span>
        | _ -&gt; ()
    }</code></pre>

<p>It&#39;s a computation expression! Gotta love those.</p>
<p><a href="https://github.com/lucasmreis/AmazingCookies/tree/master/src/Server">The complete code for the server can be found here</a>.</p>
<h2 id="an-elm-dashboard">An Elm dashboard</h2>
<p>After implementing F#, it was time to return to Elm. The dashboard architecture was simple: the app listens for events through the native websockets implementation, and it drives the standard Elm architecture. This is what the final result looks like (notice I&#39;m using Postman to send the scout&#39;s commands to the server):</p>
<p><img src="../assets/event-source-a.gif" alt="Event Source A">
<img src="../assets/event-source-b.gif" alt="Event Source B"></p>
<p>One of the best parts of Elm is that the structure of the code does not seem to change from application to application. The &quot;framework&quot; is so close to the language itself, that one simply does not try to do things differently - I&#39;m not even sure it&#39;s possible. Because of that, we can focus more on the real complexity of the problem, and think less and less about implementation details.</p>
<p>The only different part from my <a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">earlier</a> <a href="http://lucasmreis.github.io/blog/learning-elm-part-2/">learning Elm</a> <a href="http://lucasmreis.github.io/blog/learning-elm-part-3/">series</a> is the websockets part. But it&#39;s really, really simple:</p>
<pre><code class="hljs"><span class="hljs-label">type</span> Msg
    = EventReceived <span class="hljs-keyword">String
</span>
<span class="hljs-keyword">subscriptions </span>: Model -&gt; <span class="hljs-keyword">Sub </span>Msg
<span class="hljs-keyword">subscriptions </span>model =
    WebSocket.listen scoutEventsServer EventReceived</code></pre>

<p>And now I only have to treat <code>EventReceived</code> messages in the <code>update</code> function.</p>
<p>Something I did not like: I felt like I had to repeat a lot of the code in the client and the server, mostly in the models. Mismatches between client and server models are a huge source of errors. Although I don&#39;t think it would happen here - after all, they are in the same project :) - I would have to update two pieces of code each time the model needed to change.</p>
<p><a href="https://github.com/lucasmreis/AmazingCookies/blob/master/src/Client/app/Dashboard.elm">The complete code for the dashboard is here</a>.</p>
<h2 id="final-conclusions">Final Conclusions</h2>
<p>In the end, I really enjoyed the experiment. Even though the languages appear similar, I could see a lot of differences between the two, mostly due to Elm being a language looking for reliability in a narrow scope, and F# looking for pragmatism in a much larger scope.</p>
<h3 id="ways-elm-is-superior-to-f">Ways Elm Is Superior To F</h3>
<ul>
<li><p><em>&quot;Only one way to code&quot;, and it&#39;s very well thought out.</em> After grasping the Elm architecture, I am able to concentrate more each time on the complexities of the problems themselves and less about incidental implementation complexities.</p>
</li>
<li><p><em>Elm is safer.</em> Elm&#39;s limitations to immutable data and pure functions make everything safer in general. It&#39;s difficult to think of a runtime error happening in an Elm app.</p>
</li>
<li><p><em>Elm-format diminishes the cognitive load</em>. Auto formatting is much more powerful than I thought it would be! It&#39;s one more tool that let&#39;s you focus on the important problems. If you spend some time using auto formatting with Elm and then go back to any other language without a formatter, you&#39;ll understand how much we gain when we are not thinking about code formatting.</p>
</li>
<li><p><em>Better type signature syntax</em>. When one needs to write a function type signature, nothing beats Elm&#39;s (and for that matter Haskell&#39;s) signatures. I like stating the types on a different line from the function itself, and I even use it as comments in some of my Javascript code, the way <a href="http://ramdajs.com/0.22.1/docs/#repeat">RamdaJS uses it in its docs</a>.</p>
</li>
</ul>
<h3 id="ways-f-is-superior-to-elm">Ways F# Is Superior To Elm</h3>
<ul>
<li><p><em>F# is not focused in a single problem</em>. This means you can use F# in almost any software domain, from web servers to web clients, from mobile apps to data science silos. So, knowledge gained in one domain, is knowledge brought to another.</p>
</li>
<li><p><em>F# is very pragmatic</em>. If you want to deal with async problems, you can choose from native implementations of goroutines, actors or observables. You can tackle a problem using many different paradigms, and you have the whole .NET ecosystem at you disposal. In this sense, it feels as pragmatic as Clojure to me, and that tends to help most of the time.</p>
</li>
<li><p><em>Type inferring</em>. It just works, sometimes it feels like magic, and almost never gets in your way. Just start writing the function, and the compiler starts helping you. <em>Obs:</em> I found that a very good type inferring has one drawback: reading code on a web page. When you read code in an editor, you can always hover your mouse and it gives you information, but when the tool is not there to help you, code can be a little to obscure to understand. That&#39;s not good when you are trying to understand a complicated piece of code on github.</p>
</li>
<li><p><em>Tooling / compiler gives you a lot of information during development</em>. Elm&#39;s error messages are a gem. They are amazingly helpful, but I feel that F#&#39;s compiler helps you <em>more</em> during development. You can basically hover your mouse over anything in your code and you get information about it.</p>
</li>
<li><p><em>Computation Expressions</em>. As I said before, it&#39;s a really simple and unified way of writing code that result in more complex behaviors.</p>
</li>
</ul>
<h2 id="things-i-learned-in-the-process">Things I Learned In The Process</h2>
<p>I learned some valuable lessons working on this project. First of all, on the language level, I learned a lot about how to use types better. ML-style languages make it easier to use types to actively make your code more reliable. I recommend reading <a href="http://blog.ploeh.dk/2016/02/10/types-properties-software/">this blog post series</a> as a masterclass in &quot;making illegal states unrepresentable&quot;. It&#39;s a very powerful and simple idea that consists of using the type system as way to maintain the application in a valid state 100% of the time. Another way of phrasing it is <a href="https://twitter.com/splodingsocks/status/776523774183301120">&quot;testing is good, but impossible is better&quot;</a> :)</p>
<p>And second, in the architecture level, I learned about Event Sourcing and CQRS. Today, I really believe that <em>using event logs as first class citizens is the way to go in most situations</em>. Even in this small project, I could feel the benefits: whenever I was coming up with a new way of visualizing the scouts information in the dashboard, I never had to change any schema, or any code in the backend. &quot;Read models&quot; are only different queries in the stored events.</p>
<p>I feel that in a lot of companies, our main storage consists of &quot;last states of a bunch of view models&quot;, and we spend a lot of money on different analytics, and log-managing tools to deal with the really important business questions. If these companies already stored events, and treated them as they treat their main data, an immense value would be generated at a much lower cost.</p>
<h2 id="next-steps">Next Steps</h2>
<p>The repeated code between client and server made me curious about trying something more &quot;unified&quot;, so I&#39;ll try some <a href="https://fable-compiler.github.io/">Fable</a> for frontend programming.</p>
<p>Also, I&#39;ll also try to use more Event Sourcing whenever I can :)</p>
]]></description>
            <guid isPermaLink="false">Does Elm Harmonize With F#?</guid>
            <pubDate>Fri, 09 Sep 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Learning Elm, part 3]]></title>
            <description><![CDATA[<p><em>This is part 3 of a series:</em></p>
<ul>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-2/">Part 1: Understanding The Benefits Of A Simple Architecture</a></li>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">Part 2: Understanding The Benefits Of A Strong Type System</a></li>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-4/">Part 4: Property Based Testing And Better Modelling</a></li>
</ul>
<p><em>Obs: the code in this post is not compatible with Elm version 0.18 on. I&#39;m planning on updating it soon!</em></p>
<p>It&#39;s time for some interaction with APIs! <em>Now</em> we can say that we&#39;re building an actual web application, and we&#39;ll really be putting Elm to the test.</p>
<p>So, why not implement a Star Wars themed app?</p>
<h2 id="spec">Spec</h2>
<p>The spec is simple: a Star Wars character &quot;card&quot; appears on the left, and corresponding film &quot;cards&quot;, representing the films of the character, are shown on the right.</p>
<p>Clicking on a film &quot;card&quot; displays it on the left, and a list of the characters that appear in the film are shown on the right. And it goes on.</p>
<p><img src="../assets/swspec.jpg" alt="Characters And Films"></p>
<p><em>Characters cards will be yellow, and film cards will be blue. By clicking on a card, it changes from one screen to the other.</em></p>
<h2 id="film-and-character-components">Film And Character Components</h2>
<p>I&#39;ll build both the Character and Film components in separate files. This is the initial implementation:</p>
<pre><code class="hljs"><span class="hljs-comment">-- Character.elm</span>

type <span class="hljs-type">alias</span> Model =
    { <span class="hljs-property">name</span> : String
    }


view model =
    <span class="hljs-keyword">div</span> [ mainStyle ]
        [ <span class="hljs-keyword">div</span> [ nameStyle ] [ <span class="hljs-type">text</span> model.<span class="hljs-property">name</span> ] ]

<span class="hljs-comment">-- imports and styles omitted for brevity...</span></code></pre>

<pre><code class="hljs"><span class="hljs-comment">-- Film.elm</span>

type <span class="hljs-type">alias</span> Model =
    { title : String
    , episode_id : Int
    }


view model =
    let
        chapter =
            toString model.episode_id
    <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">div</span> [ mainStyle ]
            [ <span class="hljs-keyword">div</span> [ numberStyle ]
                [ <span class="hljs-type">text</span> chapter ]
            , <span class="hljs-keyword">div</span> [ nameStyle ]
                [ <span class="hljs-type">text</span> model.title ]
            ]</code></pre>

<p>If these examples do not feel straightforward to you, refer back to <a href="http://lucasmreis.github.io/blog/learning-elm-part-2/">Part 2</a>.</p>
<p>To preview the views and fine tune the CSS, I&#39;ll create the <code>Main.elm</code> file and run Elm Reactor pointing to it:</p>
<pre><code class="hljs">main =
    Html.<span class="hljs-keyword">App</span>.beginnerProgram
        { model = model
        , <span class="hljs-keyword">view</span> = <span class="hljs-keyword">view</span>
        , <span class="hljs-keyword">update</span> = <span class="hljs-keyword">update</span>
        }


<span class="hljs-keyword">update</span> model =
    model


sampleCh : Character.Model
sampleCh =
    { name = <span class="hljs-string">"Luke Skywalker"</span>
    }


sampleFilm : Film.Model
sampleFilm =
    { title = <span class="hljs-string">"A New Hope"</span>
    , episode_id = 4
    }


model =
    ( sampleCh, sampleFilm )


<span class="hljs-keyword">view</span> ( ch, film ) =
    div []
        [ Character.<span class="hljs-keyword">view</span> ch
        , Film.<span class="hljs-keyword">view</span> film
        ]</code></pre>

<p>That should render a sample component of each. Now it&#39;s time to start modeling our application.</p>
<p><img src="../assets/swsample.png" alt="Sample Character And Film"></p>
<h2 id="the-application-model">The Application Model</h2>
<p>Our spec specifies two &quot;application states&quot;: a character with a list of films, or a film with a list of characters. A natural model for this spec would be:</p>
<pre><code class="hljs"><span class="hljs-comment">-- MODEL</span>
<span class="hljs-comment">-- Aliases added for reading simplicity</span>


<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">C</span> =</span>
    <span class="hljs-type">Character</span>.<span class="hljs-type">Model</span>


<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">F</span> =</span>
    <span class="hljs-type">Film</span>.<span class="hljs-type">Model</span>


<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Model</span></span>
    = <span class="hljs-type">FilmsFromCharacter</span> <span class="hljs-type">C</span> (<span class="hljs-type">List</span> <span class="hljs-type">F</span>)
    | <span class="hljs-type">CharactersFromFilm</span> <span class="hljs-type">F</span> (<span class="hljs-type">List</span> <span class="hljs-type">C</span>)</code></pre>
To build the view, I will once again define a sample model:

<pre><code class="hljs"><span class="hljs-setting">model =
    <span class="hljs-value">FilmsFromCharacter sampleCh</span></span>
<span class="hljs-title">        [ sampleFilm
        , sampleFilm
        , sampleFilm
        ]</span></code></pre>

<p>And then, I&#39;ll use it to define the view, while refreshing Elm Reactor:</p>
<pre><code class="hljs">view model =
    case model of
        FilmsFromCharacter c fs -&gt;
            <span class="hljs-tag">div</span> [ twoColumns ]
                [ Character<span class="hljs-class">.view</span> c
                , <span class="hljs-tag">div</span> [] (List<span class="hljs-class">.map</span> Film<span class="hljs-class">.view</span> fs)
                ]

        CharactersFromFilm f cs -&gt;
            <span class="hljs-tag">div</span> [ twoColumns ]
                [ Film<span class="hljs-class">.view</span> f
                , <span class="hljs-tag">div</span> [] (List<span class="hljs-class">.map</span> Character<span class="hljs-class">.view</span> cs)
                ]


twoColumns =
    style [ ( <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ) ]</code></pre>

<p>Just change the sample and it works very well!</p>
<p>So, as a next step, I want to make the application retrieve actual information from the API. This is where things are different from <a href="http://lucasmreis.github.io/blog/learning-elm-part-2/">part 2</a>, because now our update function not only deals with the model, it also deals with <em>Commands</em>.</p>
<h2 id="the-command">The Command</h2>
<p>Because this scenario is much more complex, instead of using the  <code>beginnerProgram</code> , we&#39;ll use the <code>program</code> function. It&#39;s a little different:</p>
<pre><code class="hljs">main =
    Html.<span class="hljs-keyword">App</span>.<span class="hljs-keyword">program</span>
        { init = ( model, Cmd.none )
        , <span class="hljs-keyword">view</span> = <span class="hljs-keyword">view</span>
        , <span class="hljs-keyword">update</span> = <span class="hljs-keyword">update</span>
        , subscriptions = subscriptions
        }

-- (...)

<span class="hljs-keyword">update</span> msg model =
    ( model, Cmd.none )

-- (...)

subscriptions x =
    Sub.none</code></pre>

<p>So, now instead of only a model, we have <code>init</code>. It is a tuple with a model to be rendered immediately and a command that will fire the update function in the future. Another thing to point out is that the update function also returns this same combination.  Subscriptions are listeners that can also fire the update function.</p>
<p>Our next step is to build     <code>init</code>.  First, the app needs to get an initial character from the API and render it on the screen. Then, it has to render the films corresponding to that character. The http request will be the command, and I need an application state to wait for the request to complete.</p>
<p><em>A Key Takeaway:</em> Elm architecture is designed in such a way that it showed me how I completely missed an important screen in my initial design of the page. At this point, it&#39;s clear to me that I need an <em>initial loading screen</em> :)</p>
<pre><code class="hljs"><span class="hljs-keyword">type</span> Model
    = InitialScreen
    | FilmsFromCharacter C (<span class="hljs-built_in">List</span> F)
    | CharactersFromFilm F (<span class="hljs-built_in">List</span> C)

(<span class="hljs-attribute">...</span>)

view model =
    <span class="hljs-keyword">case</span> model of
        InitialScreen <span class="hljs-subst">-&gt;
            </span>simpleMessage <span class="hljs-string">"Loading amazing characters and films..."</span>

(<span class="hljs-attribute">...</span>)

simpleMessage t =
    div <span class="hljs-preprocessor">[</span> simpleMessageStyle <span class="hljs-preprocessor">]</span><span class="hljs-markup"> </span><span class="hljs-preprocessor">[</span> text t <span class="hljs-preprocessor">]</span><span class="hljs-markup"></span></code></pre>

<p>The elm-http <code>get</code> function receives a &quot;Decoder&quot; and a url. The decoder is the function that will convert the json response to a character model. So it makes sense that it&#39;s inside the Character module, right?</p>
<p>Another thing that we realize at this point is that <em>I&#39;ll have to have the list of the films the character was in!</em> Of course. So let&#39;s change the model to also store the films&#39; urls that&#39;ll be in the character card returned by the API:</p>
<pre><code class="hljs">-- Character<span class="hljs-built_in">.</span>elm
<span class="hljs-keyword">import</span> Json<span class="hljs-built_in">.</span>Decode exposing (Decoder, succeed, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">list</span>, int, (:=))
<span class="hljs-keyword">import</span> Json<span class="hljs-built_in">.</span>Decode<span class="hljs-built_in">.</span>Extra exposing ((|:))

(<span class="hljs-attribute">...</span>)

<span class="hljs-keyword">type</span> alias Model =
    { name : <span class="hljs-built_in">String</span>
    , films : <span class="hljs-built_in">List</span> <span class="hljs-built_in">String</span>
    }


characterDecoder : Decoder Model
characterDecoder =
    succeed Model
        |: (<span class="hljs-string">"name"</span> := <span class="hljs-built_in">string</span>)
        |: (<span class="hljs-string">"films"</span> := <span class="hljs-built_in">list</span> <span class="hljs-built_in">string</span>)</code></pre>

<p>The <code>|:</code> comes from the <code>elm-community/elm-json-extra</code> package, and feels like a better way to parse a json than the standard library.</p>
<p>So now I have the decoder. Let&#39;s go back to Main and implement the <code>getCharacter</code> command for init:</p>
<pre><code class="hljs">import Http

(...)

getCharacter url =
    Http<span class="hljs-class">.get</span> Character<span class="hljs-class">.characterDecoder</span> url</code></pre>

<p>As soon as we define the <code>init</code> as <code>init = ( InitialScreen, getCharacter &quot;http://swapi.co/api/people/1/&quot; )</code> we&#39;ll receive the following message from the compiler:</p>
<pre><code class="hljs">The argument to <span class="hljs-function"><span class="hljs-keyword">function</span></span> `<span class="hljs-function"><span class="hljs-keyword">program</span></span>` is causing a mismatch. - <span class="hljs-function"><span class="hljs-keyword">Function</span></span> `<span class="hljs-function"><span class="hljs-keyword">program</span></span>` is expecting the argument to be:

    { init : ( Model, Cmd a )

(...)

But it is:

    { init : ( Model, Platform.Task Http.Error <span class="hljs-type">Character</span>.Model )

(...)</code></pre>

<p>That means <code>getCharacter</code> is not returning a command, it&#39;s returning a <code>Task</code>. A task is actually a <em>representation</em> of an action that has not happened, and may or may not fail. To run the task, we need to feed it to the <code>Task.perform</code> function:</p>
<pre><code class="hljs">getCharacter url =
    url
        <span class="hljs-string">|&gt; Http.get Character.characterDecoder</span>
        <span class="hljs-string">|&gt; Task.perform FetchFail LoadFilms</span></code></pre>

<p>Now the task will run, and it&#39;s going to return a <code>Msg</code> of type <code>FetchFail Http.Error</code> if it fails, or a <code>LoadFilms Character.Model</code> if it succeeds. These two types should be part of the <code>Msg</code> that is sent to the update function:</p>
<pre><code class="hljs"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Msg</span></span>
    = <span class="hljs-type">LoadFilms</span> <span class="hljs-type">C</span>
    | <span class="hljs-type">FetchFail</span> <span class="hljs-type">Http</span>.<span class="hljs-type">Error</span></code></pre>

<p>We also need to handle those two messages in our update function. Elm architecture, once more, reminds us that we haven&#39;t planned all the possible application states: we need an error state, and a &quot;I have a character and I&#39;m waiting for the films&quot; state:</p>
<pre><code class="hljs">type Model
    = InitialScreen
    | ErrorScreen
    | WaitingForFilms C
    | FilmsFromCharacter C (List F)
    | CharactersFromFilm F (List C)


type Msg
    = LoadFilms C
    | FetchFail Http.Error


<span class="hljs-operator"><span class="hljs-keyword">update</span> msg <span class="hljs-keyword">model</span> =
    <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
        FetchFail _ -&gt;
            ( ErrorScreen, Cmd.<span class="hljs-keyword">none</span> )

        LoadFilms <span class="hljs-keyword">c</span> -&gt;
            ( WaitingForFilms <span class="hljs-keyword">c</span>, Cmd.<span class="hljs-keyword">none</span> )


<span class="hljs-keyword">view</span> <span class="hljs-keyword">model</span> =
    <span class="hljs-keyword">case</span> <span class="hljs-keyword">model</span> <span class="hljs-keyword">of</span>
        InitialScreen -&gt;
            simpleMessage <span class="hljs-string">"Loading amazing characters and films..."</span>

        ErrorScreen -&gt;
            simpleMessage <span class="hljs-string">"Sorry, there was an error. Please try again!"</span>

        WaitingForFilms <span class="hljs-keyword">c</span> -&gt;
            <span class="hljs-keyword">div</span> [ twoColumns ]
                [ <span class="hljs-built_in">Character</span>.<span class="hljs-keyword">view</span> <span class="hljs-keyword">c</span>
                , simpleMessage <span class="hljs-string">"Loading Films..."</span>
                ]

(...)</span></code></pre>

<h2 id="good-tools-nudge-you-in-the-right-direction">Good Tools Nudge You in the Right Direction</h2>
<p>I&#39;d like to express once again how awesome Elm is to have pointed out that alternative application states were needed. I &quot;naively&quot; thought only two screens were needed, and in reality I needed five :)</p>
<p>The concept of a tool &quot;nudging&quot; you to better practices was first introduced to me in a Rich Hickey, inventor of Clojure, video (any video of him is well worth your time!).</p>
<p>This also led me to conclude that Javascript is always nudging us in the <em>wrong</em> direction. Rich Hickey, for example, made Clojure so that, if you are in a hurry, you can work with immutable variables. You have to go out of your way to mutate values using that tool, and that&#39;s good, because mutations are a big source of unnecessary complexity.</p>
<p>Compare that to Javascript: it&#39;s always easier to mutate everything, change variables outside the function scope, write functions that are impure... So that means that you are nudged <em>towards application complexity</em> when using Javascript!</p>
<p>Elm, on the other hand, is always nudging me towards writing good code. I feel not only that I&#39;m writing code in a clean way, as I do with Clojure, but I&#39;m also building <em>the whole application</em> in a clean and complete way. I feel I&#39;m building every view necessary for every state the application will be in, and every error will be properly treated.</p>
<p>That&#39;s an awesome feeling. :)</p>
<h2 id="almost-finishing-our-application-">Almost Finishing Our Application...</h2>
<p>We are almost there! First of all let&#39;s implement the function that, given a character, it gets all the corresponding films.</p>
<p><em>Important:</em> We&#39;ll use the <code>Task.sequence</code> to batch all the tasks, but this is definitely not the best way to do it; these requests could and should be parallel. I invite you to suggest a better way to do it in the comments!</p>
<pre><code class="hljs">-- Film<span class="hljs-built_in">.</span>elm

<span class="hljs-keyword">type</span> alias Model =
    { title : <span class="hljs-built_in">String</span>
    , episode_id : Int
    , characters : <span class="hljs-built_in">List</span> <span class="hljs-built_in">String</span>
    }


filmDecoder : Decoder Model
filmDecoder =
    succeed Model
        |: (<span class="hljs-string">"title"</span> := <span class="hljs-built_in">string</span>)
        |: (<span class="hljs-string">"episode_id"</span> := int)
        |: (<span class="hljs-string">"characters"</span> := <span class="hljs-built_in">list</span> <span class="hljs-built_in">string</span>)</code></pre>

<pre><code class="hljs"><span class="hljs-comment">-- Main.elm</span>
type Msg
    = LoadFilms C
    | FetchFail Http.Error
    | ToFilmsFromCharacter C (List F)

<span class="hljs-operator"><span class="hljs-keyword">update</span> msg <span class="hljs-keyword">model</span> =
    <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>

(...)

        LoadFilms <span class="hljs-keyword">c</span> -&gt;
            ( WaitingForFilms <span class="hljs-keyword">c</span>, getFilmsFromCharacter <span class="hljs-keyword">c</span> )

        ToFilmsFromCharacter <span class="hljs-keyword">c</span> fs -&gt;
            ( FilmsFromCharacter <span class="hljs-keyword">c</span> fs, Cmd.<span class="hljs-keyword">none</span> )

(...)</span></code></pre>

<p>There&#39;s only one detail missing from our components: they need to produce a message when clicked. I implemented it so each component would send a message with its model, so the update function would be able to use the list of films&#39; or characters&#39; urls:</p>
<pre><code class="hljs">-- Character<span class="hljs-class">.elm</span>
import Html<span class="hljs-class">.Events</span> exposing (onClick)

(...)

view : Model -&gt; Html<span class="hljs-class">.Html</span> Model
view model =
    <span class="hljs-tag">div</span>
        [ onClick model
        , mainStyle
        ]
        [ <span class="hljs-tag">div</span> [ nameStyle ] [ text model<span class="hljs-class">.name</span> ] ]</code></pre>

<p>The type signature leaves it very clear: our view receives a Model, and returns an Html that produces messages of type Model. Good.</p>
<p>Now, when we use those views in our Main view, we need to add information to them in order to produce a valid message. For instance, if we click a character, it will send a message of type <code>Character.Model</code> (or <code>C</code>). But our application will only understand a message of type <code>LoadFilms C</code>. So we need to call the Character view function and <em>map</em> the message it sends with the <code>LoadFilms</code> tag. It&#39;s easier to demonstrate than to explain:</p>
<pre><code class="hljs">msgMap =
    <span class="hljs-type">Html</span>.<span class="hljs-type">App</span>.<span class="hljs-built_in">map</span>

view model =
    <span class="hljs-keyword">case</span> model of

(...)

    <span class="hljs-type">WaitingForFilms</span> <span class="hljs-built_in">c</span> -&gt;
            div [ twoColumns ]
                [ msgMap <span class="hljs-type">LoadFilms</span> (<span class="hljs-type">Character</span>.view <span class="hljs-built_in">c</span>)
                , simpleMessage <span class="hljs-string">"Loading Films..."</span>
                ]

    <span class="hljs-type">FilmsFromCharacter</span> <span class="hljs-built_in">c</span> fs -&gt;
            <span class="hljs-keyword">let</span>
                filmsViews =
                    fs
                        |&gt; <span class="hljs-type">List</span>.<span class="hljs-built_in">map</span> <span class="hljs-type">Film</span>.view
                        |&gt; <span class="hljs-type">List</span>.<span class="hljs-built_in">map</span> (msgMap <span class="hljs-type">LoadCharacters</span>)
            <span class="hljs-keyword">in</span>
                div [ twoColumns ]
                    [ msgMap <span class="hljs-type">LoadFilms</span> (<span class="hljs-type">Character</span>.view <span class="hljs-built_in">c</span>)
                    , div [] filmsViews
                    ]

(...)</code></pre>

<p>From now on, it&#39;s a &quot;complete the puzzle&quot; game. Just fill in the blanks asked by the compiler one by one, and the application will be ready and working.</p>
<h2 id="next-steps">Next Steps</h2>
<p>I can see two clear next steps for the app: making the requests parallel, and using animations for the transitions between the application states. As I said before, any ideas are welcome.</p>
<p><a href="http://lucasmreis.github.io/star-wars-elm/">Here&#39;s the working app</a>!</p>
<p><a href="https://github.com/lucasmreis/learning-elm/tree/master/part-3/app/elm">And here&#39;s the complete code</a>.</p>
<h2 id="conclusions">Conclusions</h2>
<p>Elm is awesome. The fact that the compiler asks you to take care of the union types in a pattern match, makes it very difficult to forget something. Actually, after compiling the code, the application worked perfectly on the first shot. I was looking for reliability, and I found it!</p>
<p>There&#39;s a new component that I was not aware of before, that became clearer with this new exercise: the psychological impact of a strong compiler. Whenever your code is not compilable, solving issues feels like <em>solving puzzles</em>, and actually <em>building something</em>  And, every time it compiles and we refresh the Elm Reactor window, we see <em>something working</em>.</p>
<p>With Javascript I feel like things are always breaking and I have to fi them little by little. Runtime errors generate frustration, and even when we solve them, they still bring thoughts like <em>did I really stop it from breaking? Will it break in production in some unexpected way? Did I really deal with all the possible cases?</em></p>
<p>Of course this is a personal observation, but I felt I should note it in case it resonates with other people facing the same struggles.</p>
<p>So, that was Part 3. Feel free to post any questions you might have!</p>
]]></description>
            <guid isPermaLink="false">Learning Elm, part 3</guid>
            <pubDate>Thu, 09 Jun 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Learning Elm, part 2]]></title>
            <description><![CDATA[<p><em>This is part 2 of a series:</em></p>
<ul>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-2/">Part 1: Understanding The Benefits Of A Simple Architecture</a></li>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-3/">Part 3: Building A Real Application</a></li>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-4/">Part 4: Property Based Testing And Better Modelling</a></li>
</ul>
<p>As I stated in part 1 of this series, I started learning Elm in a quest for more reliability in web front end programming. I implemented an algorithm, a parser, and things went very well.</p>
<p>Now let&#39;s build a simple application with user interaction. I want to see if I can still feel the same &quot;reliability&quot; I felt when I was only implementing a function.</p>
<p>It turns out Elm has a standard way of structuring apps baked into the language, the Elm Architecture. It&#39;s very simple, and has <em>already</em> influenced front end programming as a whole, mainly through the Redux library. We&#39;ll explore a simple version of the architecture in this post.</p>
<h2 id="the-spec">The Spec</h2>
<p>The specifications for our web app are:</p>
<ol>
<li>The user will input an abbreviation of a card</li>
<li>The application will spell out the card and render it</li>
</ol>
<p>We&#39;ll use the parser built in part 1 for that. Let&#39;s start.</p>
<h2 id="the-initial-boilerplate">The Initial Boilerplate</h2>
<p>First of all, of course, we need to install Elm. For a Mac, the cleanest path seems to be <code>brew cask install elm-platform</code>.</p>
<p>Next, running <code>elm package install</code> in the desired directory installs the language core, and creates an <code>elm-package.json</code> file. That file is the equivalent of <code>package.json</code> for the Elm world.</p>
<p>The easiest way to start developing is by editing the code in an editor (I&#39;ve been using <a href="https://github.com/sbrink/vscode-elm">VS Code</a> for Elm and it feels great), and running <code>elm-reactor</code> in the project directory.</p>
<p>Elm Reactor starts a server locally. Opening it in the browser shows a navigation page for the project. By clicking in any file, it compiles and runs the Elm code - super simple!</p>
<p>Now we have everything setup to start building our first Elm app.</p>
<h2 id="the-layout">The Layout</h2>
<p>Let&#39;s start by coding the layout. We will use a &quot;standard&quot; library called <code>elm-html</code>. It uses a virtual-dom technique to render the view, and we declare it as code:</p>
<pre><code class="hljs">module Main exposing (..)

import Html exposing (<span class="hljs-tag">div</span>, <span class="hljs-tag">input</span>, <span class="hljs-tag">p</span>, text)


main =
    <span class="hljs-tag">div</span>
        []
        [ <span class="hljs-tag">input</span> [] []
        , <span class="hljs-tag">p</span> [] [ text <span class="hljs-string">"Seven of Club"</span> ]
        ]</code></pre>

<p>Every Html node is a function of two parameters: attributes and the children nodes. So, the above code produces the following html:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">input</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Seven of Club<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span></code></pre>

<p>It takes a little time to get used to it, but it&#39;s actually very simple. We could style it with CSS, but for the sake of learning, let&#39;s do it inside Elm:</p>
<pre><code class="hljs">module Main exposing (..)

import Html exposing (<span class="hljs-tag">div</span>, <span class="hljs-tag">input</span>, <span class="hljs-tag">p</span>, text)
import Html<span class="hljs-class">.Attributes</span> exposing (style, placeholder)


main =
    <span class="hljs-tag">div</span> [ mainStyle ]
        [ <span class="hljs-tag">input</span>
            [ inputStyle
            , placeholder <span class="hljs-string">"Type your card..."</span>
            ]
            []
        , <span class="hljs-tag">p</span> [ cardStyle ] [ text <span class="hljs-string">"Seven of Club"</span> ]
        ]


mainStyle =
    style
        [ ( <span class="hljs-string">"font-family"</span>, <span class="hljs-string">"-apple-system, system, sans-serif"</span> )
        , ( <span class="hljs-string">"margin"</span>, <span class="hljs-string">"10px"</span> )
        , ( <span class="hljs-string">"padding"</span>, <span class="hljs-string">"40px"</span> )
        , ( <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> )
        , ( <span class="hljs-string">"flex-direction"</span>, <span class="hljs-string">"column"</span> )
        , ( <span class="hljs-string">"align-items"</span>, <span class="hljs-string">"stretch"</span> )
        , ( <span class="hljs-string">"background-color"</span>, <span class="hljs-string">"#fafafa"</span> )
        , ( <span class="hljs-string">"border"</span>, <span class="hljs-string">"lightgray solid 1px"</span> )
        ]


inputStyle =
    style
        [ ( <span class="hljs-string">"border"</span>, <span class="hljs-string">"#fafafa solid"</span> )
        , ( <span class="hljs-string">"border-bottom"</span>, <span class="hljs-string">"lightgray solid 1px"</span> )
        , ( <span class="hljs-string">"font-size"</span>, <span class="hljs-string">"2em"</span> )
        , ( <span class="hljs-string">"color"</span>, <span class="hljs-string">"rgba(0,0,0,0.75)"</span> )
        , ( <span class="hljs-string">"background-color"</span>, <span class="hljs-string">"#fafafa"</span> )
        ]


cardStyle =
    style
        [ ( <span class="hljs-string">"font-size"</span>, <span class="hljs-string">"2em"</span> )
        , ( <span class="hljs-string">"color"</span>, <span class="hljs-string">"rgba(0,0,0,0.75)"</span> )
        ]</code></pre>

<p>That&#39;s our layout. :)</p>
<h2 id="the-elm-architecture">The Elm Architecture</h2>
<p>Now let&#39;s get into how an Elm application is supposed to be structured.</p>
<p>Elm apps use a centralized state pattern, which I&#39;ve <a href="http://lucasmreis.github.io/blog/centralized-state-design-patterns/">written about in this blog</a>. It&#39;s a simple &quot;loop&quot; described as such:</p>
<pre><code class="hljs">Model &gt; <span class="hljs-keyword">View</span> &gt; <span class="hljs-keyword">Update</span> &gt; Model &gt; <span class="hljs-keyword">View</span> &gt; ...</code></pre>

<p>First you describe a model of your app. It is the skeleton, the data you need to render the application.</p>
<p>The view is then a function of the model. It takes the data and renders it.</p>
<p>After rendering, the application &quot;waits&quot; for user interaction or any other event. When that happens, it triggers the update function. The update function is a function that receives the old model and data of the event, and returns a new model. This model is then rendered, and the loop continues.</p>
<p>Elm gives us a function that does all the &quot;plumbing&quot; for us, and it&#39;s called <code>Html.App.program</code>. We&#39;ll use a simpler version of it, because that&#39;s everything we need for our small app, and it&#39;s called <code>beginnerProgram</code>. With it, you only need to define your model, update and view and the program does the heavy work for you:</p>
<pre><code class="hljs">main =
    Html.beginnerProgram
        { model = init <span class="hljs-string">""</span>
        , <span class="hljs-built_in">view</span> = <span class="hljs-built_in">view</span>
        , <span class="hljs-keyword">update</span> = <span class="hljs-keyword">update</span>
        }</code></pre>

<p>Now let&#39;s define <code>init</code>,  <code>view</code> and <code>update</code>.</p>
<h2 id="the-model">The Model</h2>
<p>The user interacts through an input. That means we need a String in our model to hold it. We do not need anything else, since the other changing part of our view is simply a function of that String.</p>
<pre><code class="hljs"><span class="hljs-keyword">type</span> <span class="hljs-title">alias</span> <span class="hljs-title">Model</span> =
    <span class="hljs-built_in">String</span>


init : <span class="hljs-built_in">String</span> -&gt; Model
init <span class="hljs-keyword">str</span> =
    <span class="hljs-keyword">str</span></code></pre>

<p>That&#39;s all the model we need for our spec, and a function to initialize it.</p>
<h2 id="the-view">The View</h2>
<p>The view will be a function of our model. Let&#39;s use our layout as a starting point:</p>
<pre><code class="hljs"><span class="hljs-atom">view</span> <span class="hljs-atom">model</span> =
    <span class="hljs-atom">div</span> [ <span class="hljs-atom">mainStyle</span> ]
        [ <span class="hljs-atom">input</span>
            [ <span class="hljs-atom">inputStyle</span>
            , <span class="hljs-atom">placeholder</span> <span class="hljs-string">"Type your card..."</span>
            ]
            []
        , <span class="hljs-atom">p</span> [ <span class="hljs-atom">cardStyle</span> ] [ <span class="hljs-atom">text</span> <span class="hljs-string">"Seven of Club"</span> ]
        ]</code></pre>

<p>So, our view still does not use the model. Remember that we need to render the model string after parsing it, so let&#39;s do it:</p>
<pre><code class="hljs">import CardParser

(...)

view model =
  let
    card =
      CardParser<span class="hljs-class">.spellCard</span> model
  <span class="hljs-keyword">in</span>
    <span class="hljs-tag">div</span>
      [ mainStyle ]
      [ <span class="hljs-tag">input</span>
          [ inputStyle
          , placeholder <span class="hljs-string">"Type your card..."</span>
          ]
          []
      , <span class="hljs-tag">p</span> [ cardStyle ] [ text card ]
      ]</code></pre>

<p>Add a generic update function to the code to see the page rendered:</p>
<pre><code class="hljs"><span class="hljs-operator"><span class="hljs-keyword">update</span> msg <span class="hljs-keyword">model</span> =
    <span class="hljs-keyword">model</span></span></code></pre>

<p>And we can see our app working! Change the initial value of the model in the beginnerProgram function and see the difference in the parsed string. Good work! Now let&#39;s make the app respond to some user interaction.</p>
<h2 id="the-update">The Update</h2>
<p>The update function is also simple: as the user types something in the input field, it changes the model. Html.App will make sure our new model is then rendered through the view function.</p>
<p>The update mechanism works through message passing. The view sends messages that are processed by the update function, and then it produces a new model:</p>
<pre><code class="hljs"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Msg</span></span>
    = <span class="hljs-type">ChangeText</span> <span class="hljs-type">String</span>


<span class="hljs-title">update</span> : <span class="hljs-type">Msg</span> -&gt; <span class="hljs-type">Model</span> -&gt; <span class="hljs-type">Model</span>
<span class="hljs-title">update</span> msg model =
    <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
        <span class="hljs-type">ChangeText</span> newText -&gt;
            newText</code></pre>

<p>Now we need to send those messages on user input:</p>
<pre><code class="hljs">import Html<span class="hljs-class">.Events</span> exposing (onInput)

(...)

view model =
    let
        card =
            CardParser<span class="hljs-class">.spellCard</span> model
    <span class="hljs-keyword">in</span>
        <span class="hljs-tag">div</span> [ mainStyle ]
            [ <span class="hljs-tag">input</span>
                [ inputStyle
                , placeholder <span class="hljs-string">"Type your card..."</span>
                , onInput ChangeText -- HERE!!!
                ]
                []
            , <span class="hljs-tag">p</span> [ cardStyle ] [ text card ]
            ]</code></pre>

<p>Refresh your Elm Reactor page and play with the input now. That&#39;s it, our work is done!</p>
<h2 id="but-specs-change-">But Specs Change...</h2>
<p>Don&#39;t they always? :)</p>
<p>Our app now needs <em>two inputs</em> that work the same way. The first thing that pops into our head is making a component of our current app, and then showing two of them. Let&#39;s do it.</p>
<p>Let&#39;s first create a new file called <code>ParserComponent.elm</code>, and move all the model, view and update code there. Our Main module will look like:</p>
<pre><code class="hljs">module Main exposing (..)

import Html exposing (beginnerProgram)
import ParserComponent exposing (Model, Msg, init, view, <span class="hljs-operator"><span class="hljs-keyword">update</span>)


<span class="hljs-keyword">main</span> =
    Html.beginnerProgram
        { <span class="hljs-keyword">model</span> = ParserComponent.init <span class="hljs-string">""</span>
        , <span class="hljs-keyword">view</span> = ParserComponent.<span class="hljs-keyword">view</span>
        , <span class="hljs-keyword">update</span> = ParserComponent.<span class="hljs-keyword">update</span>
        }</span></code></pre>

<p>And our app will work the same way. Now, to have two of the same components, let&#39;s define a new model, view and update for our app:</p>
<pre><code class="hljs">type <span class="hljs-type">alias</span> Model =
    { firstParser : ParserComponent.Model
    , secondParser : ParserComponent.Model
    }


init <span class="hljs-keyword">first</span> <span class="hljs-keyword">second</span> =
    Model <span class="hljs-keyword">first</span> <span class="hljs-keyword">second</span></code></pre>

<p>First of all, our new model is comprised of two ParserComponents models. Ok. Now how will we update them? We will <em>tag</em> every message that is sent from each component, and then treat each of them in a new update function:</p>
<pre><code class="hljs">type Msg
    = First ParserComponent.Msg
    | Second ParserComponent.Msg

<span class="hljs-operator"><span class="hljs-keyword">update</span> msg <span class="hljs-keyword">model</span> =
 <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
   <span class="hljs-keyword">First</span> <span class="hljs-keyword">m</span> -&gt;
     { <span class="hljs-keyword">model</span> | firstParser = ParserComponent.<span class="hljs-keyword">update</span> <span class="hljs-keyword">m</span> <span class="hljs-keyword">model</span>.firstParser}

   <span class="hljs-keyword">Second</span> <span class="hljs-keyword">m</span> -&gt;
     { <span class="hljs-keyword">model</span> | secondParser = ParserComponent.<span class="hljs-keyword">update</span> <span class="hljs-keyword">m</span> <span class="hljs-keyword">model</span>.secondParser}</span></code></pre>

<p>So, now our messages can be sent by the first or second component, and we&#39;ll tag each with <code>First</code> and <code>Second</code>. Then, a <code>First</code> message will update the <code>firstParser</code> portion of our model, and a <code>Second</code> message will update the <code>secondParser</code> portion of our model.</p>
<p>Now let&#39;s see how to actually tag those messages in the new view:</p>
<pre><code class="hljs">view model =
    <span class="hljs-tag">div</span> []
        [ Html<span class="hljs-class">.map</span> First
            (ParserComponent<span class="hljs-class">.view</span> model.firstParser)
        , Html<span class="hljs-class">.map</span> Second
            (ParserComponent<span class="hljs-class">.view</span> model.secondParser)
        ]</code></pre>

<p>By using the <code>Html.map</code> we tag, with the first parameter, every message that is sent by the view rendered in the second parameter.</p>
<p>We are rendering a ParserComponent view with the <code>firstParser</code> portion of the model, and another with the <code>secondParser</code>, and we are tagging all the messages sent by the first with <code>First</code>, and all the messages sent by the second with <code>Second</code>.</p>
<p>Refresh again the Reactor page and there you have it - two independently working parser components.</p>
<h2 id="but-the-specs-can-change-again-">But The Specs Can Change Again...</h2>
<p>To test even more how easy and safe it is to change our Elm code, let&#39;s change our spec once more. Let&#39;s say each component has now to parse a <em>list of cards</em>, separated by comma.</p>
<p>We can achieve that by <em>only changing the view function of the component</em>:</p>
<pre><code class="hljs">sentence card =
    p [ cardStyle ] [ <span class="hljs-built_in">text</span> card ]

view model =
    let
        cards =
            model
                |&gt; <span class="hljs-keyword">String</span>.<span class="hljs-built_in">split</span> <span class="hljs-string">","</span>
                |&gt; List.<span class="hljs-built_in">map</span> <span class="hljs-keyword">String</span>.<span class="hljs-built_in">trim</span>
                |&gt; List.<span class="hljs-built_in">map</span> CardParser.spellCard
    in
        div [ mainStyle ]
            [ input
                [ inputStyle
                , placeholder <span class="hljs-string">"Type your card..."</span>
                , onInput ChangeText
                ]
                []
            , div [] (List.<span class="hljs-built_in">map</span> sentence cards)
            ]</code></pre>

<p>And it just works.</p>
<h2 id="a-comment-on-difficulties">A Comment On Difficulties</h2>
<p>Up until now, I can think of two main difficulties people would find in Elm: the application architecture that it enforces and the syntax itself.</p>
<p>The architecture is simple, but it&#39;s very different from the classic MVC from Angular and Backbone. Lately the trend in Javascript has been React + Flux, so, if you are using Redux or any other similar framework, you should have no problem understanding Elm. If you are used to the classic MVC pattern, things are going to take a little more time to sink in.</p>
<p>The syntax is very restrictive, and this can be frustrating to some developers who are used to imperative programming. But as soon as I started changing code, refactoring, extracting components, and changing specs, I could feel that the &quot;restrictiveness&quot; pays off. I feel that the language forces you to think a little bit more before writing code, and then makes refactoring easier and simpler.</p>
<h2 id="conclusions">Conclusions</h2>
<p>My initial objective when I started learning Elm was investigate ways to have more reliable front end code. Up until now everything is going smoothly, I had no runtime error after the code got compiled, and I have a lot of trust that the code is doing what it&#39;s supposed to do. It&#39;s also still fun!</p>
<p>In part 3 I plan to make a simple application that makes http requests, and check if code is still as simple as it&#39;s now.</p>
<p>By the way, here&#39;s the <a href="https://github.com/lucasmreis/learning-elm">final code</a>.</p>
]]></description>
            <guid isPermaLink="false">Learning Elm, part 2</guid>
            <pubDate>Sat, 21 May 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Learning Elm, part 1]]></title>
            <description><![CDATA[<p><em>This is part 1 of a series:</em></p>
<ul>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">Part 2: Understanding The Benefits Of A Strong Type System</a></li>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-3/">Part 3: Building A Real Application</a></li>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-4/">Part 4: Property Based Testing And Better Modelling</a></li>
</ul>
<p>A big concern when working with Javascript is <em>reliability</em>. Reliability in the sense of being completely sure about what a piece of code does, and knowing that changing one part won&#39;t break another part. A key concept is <em>error feedback cycle</em>: how soon can you catch errors in your code?</p>
<p>There are a lot of ways to deal with that. &quot;Linters&quot; and comprehensive tests are a good start, and they are already a reality for most serious projects today. Using functional programming concepts like pure functions can also help a lot by simplifying your tests, and make it easier to reason about your project.</p>
<p>Another trend I see is using <em>types</em>, mostly through TypeScript and Facebook Flow. They claim that, by programming with types, you can have a compiler that helps you get the code right. Not only that, the compiler will catch a lot of errors early in the process, so the error feedback cycle gets much shorter.</p>
<p>So I decided to experiment with a typed language that compiles to Javascript. In a continuum of less to more code reliability (enforced or not by types), I compiled these players:</p>
<ol>
<li>Plain Javascript</li>
<li>Facebook Flow</li>
<li>TypeScript</li>
<li>PureScript</li>
<li>Elm</li>
</ol>
<p>Elm is the most &quot;hardcore typed language&quot; of the list, meaning that you can&#39;t even call Javascript code from Elm and vice-versa - you have to communicate through message passing. On the other hand, Elm would be the language that would provide the most &quot;type benefits&quot; of the list.</p>
<p>That&#39;s why I decided to start my investigations on reliability with Elm. Let&#39;s start by implementing a relatively simple algorithm, and then we&#39;ll move on to more real-life situations.</p>
<h2 id="the-spec">The Spec</h2>
<p>I will write an algorithm that spells out a playing card abbreviation. Some examples:</p>
<pre><code class="hljs"><span class="hljs-string">"3S"</span> -&gt; <span class="hljs-string">"Three of Spade"</span>
<span class="hljs-string">"10H"</span> -&gt; <span class="hljs-string">"Ten of Heart"</span>
<span class="hljs-string">"QC"</span> -&gt; <span class="hljs-string">"Queen of Club"</span>
<span class="hljs-string">"AD"</span> -&gt; <span class="hljs-string">"Ace of Diamonds"</span>
<span class="hljs-string">"3T"</span> -&gt; <span class="hljs-string">"-- unknown card --"</span></code></pre>

<p>I will write the algorithm using the <a href="http://elm-lang.org/examples/hello-html">Try Elm website</a>. Now let&#39;s start!</p>
<h2 id="modelling-with-types">Modelling With Types</h2>
<p>I&#39;ve read a lot about types in Haskell, OCaml and F#, but never had the chance to program anything using that kind of strong type system. I&#39;ve been using dynamic languages (Javascript and Clojure) for the last few years, so it feel a little weird to think of types first.</p>
<p>Disclaimer: I&#39;ll try to be as practical as I can. I&#39;ll try not to say &quot;Monad&quot; like everybody knows what it means, for instance :) An intermediate developer should be ok. If you have any questions, please feel free to ask in the comments.</p>
<p>Back to the problem, I&#39;ve come with the following initial representation of the cards:</p>
<pre><code class="hljs">type Value = Jack |<span class="hljs-string"> Queen </span>|<span class="hljs-string"> King </span>|<span class="hljs-string"> Ace </span>|<span class="hljs-string"> Num Int
type Suit = Club </span>|<span class="hljs-string"> Diamond </span>|<span class="hljs-string"> Spade </span>|<span class="hljs-string"> Heart</span></code></pre>
Both types are *union types*. That means that a Suit can either be a Club, Diamond, Spade or Heart. And a Value can be a Jack, a Queen, a King, an Ace or a Num with an integer. So, a Num 2 or Num 5 is a valid Value.

That seems like a nice model for our problem. Now let's implement the functions that print a card.

## Printing a Card

I'll first print a Suit. It's a no brainer:

<pre><code class="hljs"><span class="hljs-built_in">print</span>Suit suit = toString suit</code></pre>

<p>I&#39;m testing it by replacing the following values in the last line:</p>
<pre><code class="hljs"><span class="hljs-import"><span class="hljs-keyword">import</span> Html <span class="hljs-keyword">exposing</span> <span class="hljs-container">(text)</span></span>

<span class="hljs-comment">-- code (...)</span>

<span class="hljs-title">main</span> =
  <span class="hljs-type">Spade</span>
    |&gt; printSuit
    |&gt; text</code></pre>

<p>The <code>|&gt;</code> operator chains function calls. In the above line I get Spade, call <code>printSuit</code> with it as a parameter, then get the result of that computation and call the function <code>text</code> with it. It shows &quot;Spade&quot; in the output screen, so it works! :)</p>
<p>To print a Value, calling <code>toString</code> is not enough. I need to handle the <code>Num Int</code> case differently. I&#39;ll use <em>pattern matching</em> to do that:</p>
<pre><code class="hljs">printValue <span class="hljs-keyword">value</span> =
  case <span class="hljs-keyword">value</span> <span class="hljs-keyword">of</span>
    <span class="hljs-type">Num</span> <span class="hljs-number">2</span> -&gt;
      <span class="hljs-string">"Two"</span>

    <span class="hljs-type">Num</span> <span class="hljs-number">3</span> -&gt;
      <span class="hljs-string">"Three"</span>

    <span class="hljs-type">Num</span> <span class="hljs-number">4</span> -&gt;
      <span class="hljs-string">"Four"</span>

    <span class="hljs-type">Num</span> <span class="hljs-number">5</span> -&gt;
      <span class="hljs-string">"Five"</span>

    <span class="hljs-type">Num</span> <span class="hljs-number">6</span> -&gt;
      <span class="hljs-string">"Six"</span>

    <span class="hljs-type">Num</span> <span class="hljs-number">7</span> -&gt;
      <span class="hljs-string">"Seven"</span>

    <span class="hljs-type">Num</span> <span class="hljs-number">8</span> -&gt;
      <span class="hljs-string">"Eight"</span>

    <span class="hljs-type">Num</span> <span class="hljs-number">9</span> -&gt;
      <span class="hljs-string">"Nine"</span>

    <span class="hljs-type">Num</span> <span class="hljs-number">10</span> -&gt;
      <span class="hljs-string">"Ten"</span>

    _ -&gt;
      toString <span class="hljs-keyword">value</span></code></pre>

<p>A little boring, but I went through every case possible - unless someone enters a number less than 2 or more than 10. I&#39;ll deal with that in the function that actually creates the card.</p>
<p>To print the whole card, I&#39;ll make a function that concatenates a list that consists of: the value string, <code>&quot; of &quot;</code> and the suit string. I&#39;ll represent a card as a tuple <code>(Value, Suit)</code>:</p>
<pre><code class="hljs"><span class="hljs-built_in">print</span>Card (value, suit) =
  [<span class="hljs-built_in">print</span>Value value, <span class="hljs-string">" of "</span>, <span class="hljs-built_in">print</span>Suit suit] |&gt; String.concat

main =
  (Num <span class="hljs-number">10</span>, Spade)
    |&gt; <span class="hljs-built_in">print</span>Card
    |&gt; text

-- Ten of Spade</code></pre>

<p>The code above works, and I can be sure that all the combinations of Value and Suit will print well. That&#39;s really good.</p>
<p>I&#39;ll add another layer of safety and documentation by writing the type signatures of the functions. I catch myself writing &quot;type signatures&quot; as comments even to my Javascript code from time to time, and it helps when dealing with a piece of code months later. I&#39;m starting to believe that having a compiler that ensures that your type signatures are in sync with the implementations can help a lot with maintainability.</p>
<p><code>printCard</code> signature is: <code>printCard : (Value, Suit) -&gt; String</code>, but I think we can be more expressive if it is <code>printCard : Card -&gt; String</code>. That is possible with Elm, by writing a <em>type alias</em>:</p>
<pre><code class="hljs"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">Card</span> = <span class="hljs-container">(<span class="hljs-type">Value</span>, <span class="hljs-type">Suit</span>)</span></span>

(...)

<span class="hljs-title">printCard</span> : <span class="hljs-type">Card</span> -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">printCard</span> (value, suit) =
  [printValue value, <span class="hljs-string">" of "</span>, printSuit suit] |&gt; <span class="hljs-type">String</span>.concat

<span class="hljs-title">main</span> =
  (<span class="hljs-type">Num</span> <span class="hljs-number">10</span>, <span class="hljs-type">Spade</span>)
    |&gt; printCard
    |&gt; text

<span class="hljs-comment">-- Ten of Spade</span></code></pre>

<p>So, if I have a valid card, I can print it. Nice. Now let&#39;s parse the original abbreviation string.</p>
<h2 id="parsing-a-suit-and-a-value-from-a-string">Parsing A Suit And A Value From A String</h2>
<p>First I&#39;ll parse the suit. My first take is:</p>
<pre><code class="hljs">parseSuit : Char<span class="hljs-function"> -&gt;</span> Suit
parseSuit char =
  <span class="hljs-keyword">case</span> char <span class="hljs-keyword">of</span>
    <span class="hljs-string">'C'</span><span class="hljs-function"> -&gt;</span> Club
    <span class="hljs-string">'D'</span><span class="hljs-function"> -&gt;</span> Diamond
    <span class="hljs-string">'S'</span><span class="hljs-function"> -&gt;</span> Spade
    <span class="hljs-string">'H'</span><span class="hljs-function"> -&gt;</span> Heart</code></pre>

<p>When I compile it - even before calling this function anywhere - the compiler screams an error. This is the message I get:</p>
<pre><code class="hljs">MISSING PATTERNS
This `<span class="hljs-keyword">case</span>` does <span class="hljs-operator">not</span> have branches <span class="hljs-keyword">for</span> all possibilities.

<span class="hljs-number">11</span>| <span class="hljs-keyword">case</span> <span class="hljs-keyword">char</span> <span class="hljs-operator">of</span>
<span class="hljs-number">12</span>| <span class="hljs-string">'C'</span> -&gt; Club
<span class="hljs-number">13</span>| <span class="hljs-string">'D'</span> -&gt; Diamond
<span class="hljs-number">14</span>| <span class="hljs-string">'S'</span> -&gt; Spade
<span class="hljs-number">15</span>| <span class="hljs-string">'H'</span> -&gt; Heart
You need <span class="hljs-built_in">to</span> account <span class="hljs-keyword">for</span> <span class="hljs-operator">the</span> following values:

 &lt;values besides <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'H'</span>, <span class="hljs-operator">and</span> <span class="hljs-string">'S'</span>&gt;

Add <span class="hljs-operator">a</span> branch <span class="hljs-built_in">to</span> cover this pattern!

If you are seeing this error <span class="hljs-keyword">for</span> <span class="hljs-operator">the</span> <span class="hljs-keyword">first</span> <span class="hljs-built_in">time</span>, check out these hints:
&lt;<span class="hljs-keyword">https</span>://github.com/elm-lang/elm-compiler/blob/<span class="hljs-number">0.16</span><span class="hljs-number">.0</span>/hints/missing-patterns.md&gt;
The recommendations about wildcard patterns <span class="hljs-operator">and</span> `Debug.crash` are important!</code></pre>

<p>Oh my god, now that&#39;s an error message! First of all, the subject of the error is already outstanding: I coded that the function receives a Char as a parameter, and I did not handle all the Char cases. That means the compiler is preventing me from having code that behaves unexpectedly. What would be the return value if an <code>&#39;X&#39;</code> was passed? That case needs to be handled.</p>
<p>But, better than that, I really like how <em>didatic</em> the message was. Not only does it give some tips, it gives a link to a page teaching the subject! I&#39;ve read that <a href="https://twitter.com/czaplic?lang=en">Evan Czaplicki</a>, the language designer, is working hard on making the error messages better. Good job!</p>
<p>By reading that link, I learned that the best way to deal with this in this case is by using a Maybe type. Maybe is native to Elm, and represented by:</p>
<pre><code class="hljs">type Maybe <span class="hljs-literal">a</span>
  = Just <span class="hljs-literal">a</span>
  | Nothing</code></pre>

<p>Maybe represents a value that may or may not exist. So I&#39;ll make the assumption that if the Char inputted by the user is not one of the four, the Suit will not exist and will be represented by a Nothing:</p>
<pre><code class="hljs">parseSuit : Char<span class="hljs-function"> -&gt;</span> Maybe Suit
parseSuit s =
  <span class="hljs-keyword">case</span> s <span class="hljs-keyword">of</span>
    <span class="hljs-string">'C'</span><span class="hljs-function"> -&gt;</span> Just Club
    <span class="hljs-string">'D'</span><span class="hljs-function"> -&gt;</span> Just Diamond
    <span class="hljs-string">'S'</span><span class="hljs-function"> -&gt;</span> Just Spade
    <span class="hljs-string">'H'</span><span class="hljs-function"> -&gt;</span> Just Heart
    _<span class="hljs-function"> -&gt;</span> Nothing

main =
  <span class="hljs-string">'C'</span>
    |&gt; parseSuit
    |&gt; toString
    |&gt; text

-- Just Club</code></pre>

<p>The best part of using <em>a maybe</em> is that the functions that deal with the value returned by the parsers <em>will have to deal with the fact that they may not exist</em>. This will be enforced by the compiler, and is one way of making sure we have to explicitly deal with errors or unexpected behaviors in the code. I&#39;ll talk more about that later. Let&#39;s now write the Value parser.</p>
<p>A simple implementation would be:</p>
<pre><code class="hljs">parseValue : <span class="hljs-built_in">String</span> <span class="hljs-subst">-&gt; </span>Maybe Value
parseValue v =
  <span class="hljs-keyword">case</span> v of
    <span class="hljs-string">"J"</span> <span class="hljs-subst">-&gt;
      </span>Just Jack

    <span class="hljs-string">"Q"</span> <span class="hljs-subst">-&gt;
      </span>Just Queen

    <span class="hljs-string">"K"</span> <span class="hljs-subst">-&gt;
      </span>Just King

    <span class="hljs-string">"A"</span> <span class="hljs-subst">-&gt;
      </span>Just Ace

    _ <span class="hljs-subst">-&gt;
      </span><span class="hljs-built_in">String</span><span class="hljs-built_in">.</span>toInt v</code></pre>

<p>But the compiler screams that <code>String.toInt</code> does not return a Maybe Value. It returns a Result String Int which is described by <code>type Result error value = Ok value | Err error</code>. Let&#39;s extract this case to a different function so we can manage better <code>toInt</code>:</p>
<pre><code class="hljs"><span class="hljs-title">parseNumValue</span> : <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Value</span>
<span class="hljs-title">parseNumValue</span> v =
  <span class="hljs-keyword">case</span> <span class="hljs-type">String</span>.toInt v <span class="hljs-keyword">of</span>
    <span class="hljs-type">Ok</span> num -&gt;
      <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">2</span> &amp;&amp; num &lt;= <span class="hljs-number">10</span>) <span class="hljs-keyword">then</span>
        <span class="hljs-type">Just</span> (<span class="hljs-type">Num</span> num)
      <span class="hljs-keyword">else</span>
        <span class="hljs-type">Nothing</span>

    <span class="hljs-type">Err</span> _ -&gt;
      <span class="hljs-type">Nothing</span>


<span class="hljs-title">parseValue</span> : <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Value</span>
<span class="hljs-title">parseValue</span> v =
  <span class="hljs-keyword">case</span> v <span class="hljs-keyword">of</span>
    <span class="hljs-string">"J"</span> -&gt;
      <span class="hljs-type">Just</span> <span class="hljs-type">Jack</span>

    <span class="hljs-string">"Q"</span> -&gt;
      <span class="hljs-type">Just</span> <span class="hljs-type">Queen</span>

    <span class="hljs-string">"K"</span> -&gt;
      <span class="hljs-type">Just</span> <span class="hljs-type">King</span>

    <span class="hljs-string">"A"</span> -&gt;
      <span class="hljs-type">Just</span> <span class="hljs-type">Ace</span>

    _ -&gt;
      parseNumValue v

<span class="hljs-title">main</span> =
  <span class="hljs-string">"10"</span>
    |&gt; parseValue
    |&gt; toString
    |&gt; text

<span class="hljs-comment">-- Just (Num 10)</span></code></pre>

<p>This is one of the most interesting parts of the code we are writing. <code>parseNumValue</code> is the function that <em>guarantees</em> that a card will have a minimum value of 2 and a maximum of 10. This together with wrapping it in a Maybe, and using the Card type, is a guarantee that, whenever I have a Card variable, it&#39;s going to be a valid Card. There&#39;s no way to represent an invalid card, or to process an invalid card at some point of the code.</p>
<p>Now we can parse a Value and a Suit. The next step is parsing the whole abbreviation, like <code>&quot;10H&quot;</code> or <code>&quot;KS&quot;</code>.</p>
<h2 id="parsing-an-abbreviation-string">Parsing An Abbreviation String</h2>
<p>We need to separate the abbreviation string into a value string and a suit character. Now this is a fun function:</p>
<pre><code class="hljs">divideCardString : <span class="hljs-built_in">String</span> <span class="hljs-subst">-&gt; </span>(Maybe <span class="hljs-built_in">String</span>, Maybe Char)
divideCardString str =
  <span class="hljs-keyword">let</span>
    chars = <span class="hljs-built_in">String</span><span class="hljs-built_in">.</span>toList str

    suit = chars
      |&gt; <span class="hljs-built_in">List</span><span class="hljs-built_in">.</span>reverse
      |&gt; <span class="hljs-built_in">List</span><span class="hljs-built_in">.</span>head

    value = chars
      |&gt; <span class="hljs-built_in">List</span><span class="hljs-built_in">.</span>reverse
      |&gt; <span class="hljs-built_in">List</span><span class="hljs-built_in">.</span>tail
      |&gt; Maybe<span class="hljs-built_in">.</span><span class="hljs-built_in">map</span> <span class="hljs-built_in">List</span><span class="hljs-built_in">.</span>reverse
      |&gt; Maybe<span class="hljs-built_in">.</span><span class="hljs-built_in">map</span> <span class="hljs-built_in">String</span><span class="hljs-built_in">.</span>fromList

  <span class="hljs-keyword">in</span>
    (value, suit)

main =
  <span class="hljs-string">"AH"</span>
    |&gt; divideCardString
    |&gt; toString
    |&gt; text

-- (Just <span class="hljs-string">"A"</span>, Just <span class="hljs-string">'H'</span>)</code></pre>

<p>Let&#39;s break it into parts. First, there&#39;s the <code>let</code> keyword. It is used to compute temporary variables that will be returned after the <code>in</code> keyword.</p>
<p>The first variable is <code>chars</code>. It&#39;s the List representation of the input string. It&#39;s inferred as a List of Char.</p>
<p>To compute the next variables, I did not choose the most efficient way, and that can be &quot;homework&quot; for the reader :) <code>suit</code> is the head of the reverse of the list; in other words, it&#39;s the last Char. Note that <code>List.head</code> returns a Maybe, because the list may be empty!</p>
<p><code>value</code> is the rest of the string. It&#39;s the tail of the reverse of the list, reversed again, and transformed in a String again. That&#39;s definitely not performant, but fun :) <code>List.tail</code> returns a Maybe List, so, to apply <code>List.reverse</code> and <code>String.formList</code>, I had to use <code>Maybe.map</code>. Maybe.map is the way to apply a function to the value inside a Maybe.</p>
<p>Now the function that takes this tuple and returns a Maybe Card:</p>
<pre><code class="hljs">parseCardTuple : <span class="hljs-function"><span class="hljs-params">(Maybe String, Maybe Char)</span> -&gt;</span> Maybe Card
parseCardTuple (value, suit) =
  <span class="hljs-keyword">case</span> ( value |&gt; Maybe.andThen parseValue, suit |&gt; Maybe.andThen parseSuit ) <span class="hljs-keyword">of</span>
    <span class="hljs-function"><span class="hljs-params">(Just v, Just s)</span> -&gt;</span>
      Just (v, s)

    _<span class="hljs-function"> -&gt;</span>
      Nothing

main =
  (Just <span class="hljs-string">"7"</span>, Just <span class="hljs-string">'D'</span>)
    |&gt; parseCardTuple
    |&gt; toString
    |&gt; text

-- Just ((Num <span class="hljs-number">7</span>,Diamond))</code></pre>

<p><code>Maybe.andThen</code> is used when using <code>Maybe.map</code> returns a Maybe of a Maybe. <code>andThen</code> is for Maybes what <code>flatten</code> is for Arrays :)</p>
<p>The nice part of this function is that we called functions inside the <code>case of</code> syntax. So, if both parses are successful, I&#39;ll return a Just Card. If anything goes wrong, be it that there was no String to begin with, or one of the parses returned Nothing, our function itself will return Nothing.</p>
<p>Now our algorithm is ready! Let&#39;s glue all the parts together.</p>
<h2 id="the-final-function">The Final function</h2>
<p>The final function is just a composition of the ones we just built:</p>
<pre><code class="hljs">spellCard : <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span>
spellCard <span class="hljs-keyword">str</span> =
  <span class="hljs-keyword">str</span>
    |&gt; divideCardString
    |&gt; parseCardTuple
    |&gt; printCard</code></pre>

<p>It does not compile. The compiler tells us that <code>parseCardTuple</code> returns a Maybe Card, and <code>printCard</code> was expecting a Card. We already know how to solve it, we just change it to <code>Maybe.map printCard</code>. The problem is that the function would still return a Maybe String, and we want to extract a String from it.</p>
<p>The <code>Maybe</code> module has a function for that: <code>Maybe.withDefault</code>. It accepts a default value and a Maybe. If the Maybe is a Just, it returns the value inside the Just. If it&#39;s a Nothing, it returns the default value. Here is the official implementation of <a href="https://github.com/elm-lang/core/blob/master/src/Maybe.elm#L51"><code>Maybe.withDefault</code></a>:</p>
<pre><code class="hljs"><span class="hljs-title">withDefault</span> : a -&gt; <span class="hljs-type">Maybe</span> a -&gt; a
<span class="hljs-title">withDefault</span> <span class="hljs-default"><span class="hljs-keyword">default</span> maybe =</span>
  <span class="hljs-keyword">case</span> maybe <span class="hljs-keyword">of</span>
    <span class="hljs-type">Just</span> value -&gt; value
    <span class="hljs-type">Nothing</span> -&gt; <span class="hljs-default"><span class="hljs-keyword">default</span></span></code></pre>

<p>Using it, our final function is described as:</p>
<pre><code class="hljs">spellCard : String -&gt; String
spellCard str =
  str
    <span class="hljs-string">|&gt; divideCardString</span>
    <span class="hljs-string">|&gt; parseCardTuple</span>
    <span class="hljs-string">|&gt; Maybe.map printCard</span>
    <span class="hljs-string">|&gt; Maybe.withDefault "</span>-- unknown card --<span class="hljs-string">"</span>


main =
  <span class="hljs-string">"AH"</span>
    <span class="hljs-string">|&gt; spellCard</span>
    <span class="hljs-string">|&gt; text</span>

-- Ace of Heart</code></pre>

<p>It&#39;s done!</p>
<h2 id="but-specs-change-">But Specs Change...</h2>
<p>And we have to deal with it. One of the promises of strong type systems is that they make the code much easier and safer to change / refactor. I work daily with a big Javascript application, and I think that&#39;s one of the most painful points now. Changing any part of the code requires a lot of attention, and a lot of faith in the tests. Just changing a function is never the answer, and we have to be extra careful not to insert &quot;hidden bugs&quot; by creating new unexpected cases.</p>
<p>Let&#39;s suppose we want to include the Joker card:</p>
<pre><code class="hljs"><span class="hljs-string">"J"</span> -&gt; <span class="hljs-string">"Joker"</span></code></pre>

<p>The first thing I notice is that our model is not sufficient anymore. A card is not a tuple of value and suit; now we also have a joker. I&#39;m gonna change the <code>Card</code> type, and run the compiler to see what it says:</p>
<pre><code class="hljs"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Card</span> = <span class="hljs-type">OrdinaryCard</span> <span class="hljs-type">Value</span> <span class="hljs-type">Suit</span> | <span class="hljs-type">Joker</span></span></code></pre>

<p>The compiler complains that <code>printCard</code> does not print a Card, it prints a tuple. Let&#39;s change it:</p>
<pre><code class="hljs">printCard : <span class="hljs-type">Card</span> -&gt; <span class="hljs-type">String</span>
printCard card =
  case card <span class="hljs-keyword">of</span>
    <span class="hljs-type">OrdinaryCard</span> <span class="hljs-keyword">value</span> suit -&gt;
      [printValue <span class="hljs-keyword">value</span>, <span class="hljs-string">" of "</span>, printSuit suit] |&gt; <span class="hljs-type">String</span>.concat

  <span class="hljs-type">Joker</span> -&gt;
    <span class="hljs-string">"Joker"</span></code></pre>

<p>The other error the compiler caught was that <code>parseCardTuple</code> does not return a Card. Now it&#39;s time to pause a little and think about the parsers.</p>
<p>The Joker abbreviation is only a <code>&quot;J&quot;</code>, so it does not make sense to call <code>divideCardString</code> with it! If I have a <code>&quot;J&quot;</code>, I should return a Just Joker. To do that, I&#39;m gonna implement a new function:</p>
<pre><code class="hljs">parseCardString : <span class="hljs-built_in">String</span> -&gt; Maybe Card
parseCardString <span class="hljs-keyword">str</span> =
  case <span class="hljs-keyword">str</span> of
    <span class="hljs-string">"J"</span> -&gt;
      Just Joker

    _ -&gt;
      <span class="hljs-keyword">str</span>
        |&gt; divideCardString
        |&gt; parseCardTuple</code></pre>

<p>It handles the case <code>&quot;J&quot;</code> separately, and calls our previous function if it&#39;s not a Joker. Now we only have to change <code>parseCardTuple</code> to return an OrdinaryCard instead of the tuple in case of success:</p>
<pre><code class="hljs">parseCardTuple : <span class="hljs-function"><span class="hljs-params">(Maybe String, Maybe Char)</span> -&gt;</span> Maybe Card
parseCardTuple (value, suit) =
  <span class="hljs-keyword">case</span> ( value |&gt; Maybe.andThen parseValue, suit |&gt; Maybe.andThen parseSuit ) <span class="hljs-keyword">of</span>
    <span class="hljs-function"><span class="hljs-params">(Just v, Just s)</span> -&gt;</span>
      Just (OrdinaryCard v s) -- <span class="hljs-keyword">not</span> a tuple

  _<span class="hljs-function"> -&gt;</span>
    Nothing</code></pre>

<p>And change <code>spellCard</code>:</p>
<pre><code class="hljs">spellCard : <span class="hljs-keyword">String</span> -&gt; <span class="hljs-keyword">String</span>
spellCard <span class="hljs-built_in">str</span> =
  <span class="hljs-built_in">str</span>
    |&gt; parseCardString
    |&gt; Maybe.<span class="hljs-built_in">map</span> printCard
    |&gt; Maybe.withDefault <span class="hljs-string">"-- unknown card --"</span>

main =
  <span class="hljs-string">"J"</span>
    |&gt; spellCard
    |&gt; <span class="hljs-built_in">text</span>

-- Joker</code></pre>

<p>That was very easy, and I really liked the compiler&#39;s help.</p>
<h2 id="first-impressions-of-elm">First Impressions Of Elm</h2>
<p>It&#39;s a simple algorithm, and it&#39;s just a pure function. I still can&#39;t tell if a big web application Elm codebase will feel the same way, so let&#39;s all take these conclusions with a grain of salt - it&#39;s just a first impression.</p>
<p>First: the code really feels <em>reliable</em>. Even though I do not have any unit tests, I&#39;m sure it works as expected, with no errors or difficult-to-spot runtime exceptions. In a more serious setting, I would write three or four unit tests and that&#39;s it. Reliability is probably the number one factor that&#39;s making me research other front end languages, and Elm&#39;s strong type system seems to be a clean path towards that.</p>
<p>Second: the code feels <em>maintainable</em>. I may have spent a little more time implementing the first version of the function than I would with Javascript. But I found that implementing the new spec was very easy and direct, maintaining the reliability feeling I had when I started coding the function.</p>
<p>Third: it was <em>fun</em>. Fun is sometimes overlooked when talking about technologies, but it should not be. Not only does it help keep the engineers engaged, it&#39;s usually a good signal that we are dealing with a smart and productive tool. No one finds using a dumb and clumsy tool fun, am I right? :)</p>
<h2 id="next-steps">Next Steps</h2>
<p>I really liked this first contact with Elm, and I&#39;m going to continue investigating it.</p>
<p>As a next step, I will implement a web app that uses our function. I&#39;ll have to deal with Elm&#39;s tooling outside the online REPL, and I&#39;ll have to deal with asynchronous events from user interaction.</p>
<p>Then I&#39;ll implement a web app that communicates with a server. I&#39;, curious to see how easy it&#39;ll be to write &quot;impure&quot; code in Elm.</p>
<p>If you have had any experiences with Elm, good or bad, feel free to post it in the comments section!</p>
<h2 id="the-final-code">The Final Code</h2>
<p>You can copy and paste the following code to the online REPL and play a little bit with Elm:</p>
<pre><code class="hljs">import Html exposing (text)
import <span class="hljs-built_in">String</span>

<span class="hljs-keyword">type</span> <span class="hljs-title">Value</span> = Jack | Queen | King | Ace | Num Int
<span class="hljs-keyword">type</span> <span class="hljs-title">Suit</span> = Club | Diamond | Spade | Heart
<span class="hljs-keyword">type</span> <span class="hljs-title">Card</span> = OrdinaryCard Value Suit | Joker


parseSuit : Char -&gt; Maybe Suit
parseSuit s =
  case s of
    <span class="hljs-string">'C'</span> -&gt; Just Club
    <span class="hljs-string">'D'</span> -&gt; Just Diamond
    <span class="hljs-string">'S'</span> -&gt; Just Spade
    <span class="hljs-string">'H'</span> -&gt; Just Heart
    _ -&gt; Nothing


parseNumValue : <span class="hljs-built_in">String</span> -&gt; Maybe Value
parseNumValue v =
  case <span class="hljs-built_in">String</span>.toInt v of
    <span class="hljs-built_in">Ok</span> num -&gt;
      <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">2</span> &amp;&amp; num &lt;= <span class="hljs-number">10</span>) then
        Just (Num num)
      <span class="hljs-keyword">else</span>
        Nothing

    <span class="hljs-built_in">Err</span> _ -&gt;
      Nothing


parseValue : <span class="hljs-built_in">String</span> -&gt; Maybe Value
parseValue v =
  case v of
    <span class="hljs-string">"J"</span> -&gt;
      Just Jack

    <span class="hljs-string">"Q"</span> -&gt;
      Just Queen

    <span class="hljs-string">"K"</span> -&gt;
      Just King

    <span class="hljs-string">"A"</span> -&gt;
      Just Ace

    _ -&gt;
      parseNumValue v


divideCardString : <span class="hljs-built_in">String</span> -&gt; (Maybe <span class="hljs-built_in">String</span>, Maybe Char)
divideCardString <span class="hljs-keyword">str</span> =
  <span class="hljs-keyword">let</span>
    chars = <span class="hljs-built_in">String</span>.toList <span class="hljs-keyword">str</span>

    suit = chars
      |&gt; List.reverse
      |&gt; List.head

    value = chars
      |&gt; List.reverse
      |&gt; List.tail
      |&gt; Maybe.map List.reverse
      |&gt; Maybe.map <span class="hljs-built_in">String</span>.fromList

  <span class="hljs-keyword">in</span>
    (value, suit)


parseCardTuple : (Maybe <span class="hljs-built_in">String</span>, Maybe Char) -&gt; Maybe Card
parseCardTuple (value, suit) =
  case (value `Maybe.andThen` parseValue, suit `Maybe.andThen` parseSuit) of
    (Just v, Just s) -&gt;
      Just (OrdinaryCard v s) -- not a tuple

    _ -&gt;
      Nothing


parseCardString : <span class="hljs-built_in">String</span> -&gt; Maybe Card
parseCardString <span class="hljs-keyword">str</span> =
  case <span class="hljs-keyword">str</span> of
    <span class="hljs-string">"J"</span> -&gt;
      Just Joker

    _ -&gt;
      <span class="hljs-keyword">str</span>
        |&gt; divideCardString
        |&gt; parseCardTuple


printSuit : Suit -&gt; <span class="hljs-built_in">String</span>
printSuit suit = toString suit


printValue : Value -&gt; <span class="hljs-built_in">String</span>
printValue value =
  case value of
    Num <span class="hljs-number">2</span> -&gt;
      <span class="hljs-string">"Two"</span>

    Num <span class="hljs-number">3</span> -&gt;
      <span class="hljs-string">"Three"</span>

    Num <span class="hljs-number">4</span> -&gt;
      <span class="hljs-string">"Four"</span>

    Num <span class="hljs-number">5</span> -&gt;
      <span class="hljs-string">"Five"</span>

    Num <span class="hljs-number">6</span> -&gt;
      <span class="hljs-string">"Six"</span>

    Num <span class="hljs-number">7</span> -&gt;
      <span class="hljs-string">"Seven"</span>

    Num <span class="hljs-number">8</span> -&gt;
      <span class="hljs-string">"Eight"</span>

    Num <span class="hljs-number">9</span> -&gt;
      <span class="hljs-string">"Nine"</span>

    Num <span class="hljs-number">10</span> -&gt;
      <span class="hljs-string">"Ten"</span>

    _ -&gt;
      toString value


printCard : Card -&gt; <span class="hljs-built_in">String</span>
printCard card =
  case card of
    OrdinaryCard value suit -&gt;
      [printValue value, <span class="hljs-string">" of "</span>, printSuit suit] |&gt; <span class="hljs-built_in">String</span>.concat

  Joker -&gt;
    <span class="hljs-string">"Joker"</span>


spellCard : <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span>
spellCard <span class="hljs-keyword">str</span> =
  <span class="hljs-keyword">str</span>
    |&gt; parseCardString
    |&gt; Maybe.map printCard
    |&gt; Maybe.withDefault <span class="hljs-string">"-- unknown card --"</span>


main =
  <span class="hljs-string">"J"</span>
    |&gt; spellCard
    |&gt; text</code></pre>]]></description>
            <guid isPermaLink="false">Learning Elm, part 1</guid>
            <pubDate>Fri, 22 Apr 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Should We Leave Javascript In Front End Programming?]]></title>
            <description><![CDATA[<p>I recently &quot;inherited&quot; a Javascript project at work. It was only &quot;a medium-sized React app&quot;, so we all thought it would be easy to get it up and running, and for us to start being productive - even though the application&#39;s only author was not there to help.</p>
<p>But unfortunately, it was not easy.  It took a couple of hours for the build to work, and a couple of days until I could make any production-ready changes. The difficulties I encountered in this process made me think about the technology choices we have to make in programming.</p>
<p>For instance, I always thought I knew the answer to this question: <em>Should we implement the next front end project in Javascript?</em></p>
<h2 id="my-original-answer">My Original Answer</h2>
<p><strong>Yes.</strong> I believed a hundred percent that, even though there were some really interesting language choices on the radar, we should choose Javascript. Simply because <em>that&#39;s what every developer in the market knows</em>, and <em>there&#39;s already a lot of libraries / frameworks that I can choose from</em>. Summing up, the main reason is <em>familiarity</em>, both with the syntax and the tools.</p>
<p>And that&#39;s what seems to have changed in front end web programming.</p>
<h2 id="javascript-is-not-one-language-anymore">Javascript Is Not One Language Anymore</h2>
<p>First of all, let me explain what I mean by &quot;Javascript is not one language anymore&quot;. I work on a really big front end project that still uses ES5 for most of the code, Angular 1.x as the framework, and Ramda as the main util library. Here is an example of a common piece of code:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> onPress = pCompose(
  pCatch(MetricService.logEvent(<span class="hljs-string">'payment:error'</span>)),
  MetricService.logEvent(<span class="hljs-string">'payment:success'</span>),
  StateService.change(<span class="hljs-string">'payment'</span>),
  prop(<span class="hljs-string">'data'</span>),
  $http,
  PaymentApiService.requestObj,
  MetricService.logEvent(<span class="hljs-string">'payment:submit'</span>));</code></pre>

<p>This is a good ES5 / Ramda / Angular piece of code. (<code>pCompose</code> and <code>pCatch</code> are not from Ramda library, but they are pretty self explanatory :) ).</p>
<p>That piece of code written today could look like:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> onPress = <span class="hljs-keyword">async</span> id =&gt; {
  MetricService.logEvent(<span class="hljs-string">'payment:submit'</span>, id)
  <span class="hljs-keyword">const</span> cartReq = PaymentApiService.requestObj(id)
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> { data } = <span class="hljs-keyword">await</span> axios(cartReq)
    StateService.change(<span class="hljs-string">'payment'</span>, data)
    MetricService.logEvent(<span class="hljs-string">'payment:success'</span>, data)
  } <span class="hljs-keyword">catch</span> (err) {
    MetricService.logEvent(<span class="hljs-string">'payment:error'</span>, err)
  }
}</code></pre>

<p>Which is also a perfectly good ES7 piece of code. And it&#39;s completely different, in a lot of aspects.</p>
<p>Some examples of differences in Javascript code: ES5 callbacks are very different from ES6 promises that are very different from ES7 async functions. &quot;For&quot; loops are very different from Lodash code, that is different from Ramda or Trine code too. Mutable objects, ImmutableJS, ES7 object spread operator... The list goes on.</p>
<p>So, no two projects I&#39;ve ever encountered were alike in those terms. They are always some chosen combination of practices and technologies, usually with very different styles mixed in because of external dependencies.</p>
<p>We can conclude that Javascript projects tend to be fundamentally different from each other, and tend to be messy as they grow.</p>
<h2 id="new-technologies-are-better">New Technologies Are Better</h2>
<p>ES6 and ES7 are bringing some really good features to the language. But to use them in a production environment, we will have to rely on &quot;transpiling&quot; tools like Babel. This is bringing <em>Javascript development</em> itself closer to <em>other front end languages development</em>. And there are <a href="https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js">a lot of those</a>.</p>
<p>The thing is, these other languages do a lot of things better than Javascript. For example, TypeScript adds a thin layer of types that can save a lot of headaches when your code base gets larger. ClojureScript has some very simple and performant wrappers around React, that work well with channels and goroutines for async work. Elm&#39;s cleverly designed compiler almost guarantees no runtime error will happen.  </p>
<p>With this information in mind, we can ask <em>the question</em> one more time: should we implement the next front end project in Javascript?</p>
<h2 id="opportunity-cost">Opportunity Cost</h2>
<p>The way this question should <em>always</em> be answered is with an opportunity cost analysis. In our case, it could be divided in three steps:</p>
<p><strong>1. Which problems in the code base would I like to solve?</strong></p>
<p>We need to understand our application&#39;s needs. Does it deal with a lot of async work? Is it heavy on user interaction? Does it need to run on very different platforms?</p>
<p><strong>2. Are there tools that will help me with those problems better than Javascript?</strong></p>
<p>The next step is trying to find solutions to these problems, and tools that implement those solutions. Powerful type systems, flexible async patterns, performant rendering, these are all important solutions that should be considered. Make a list of languages / tools that could help each problem.</p>
<p><strong>3. What are the costs of using these tools in relation to using the most up-to-date Javascript?</strong></p>
<p>What is the learning curve? How active is the community? Does it have a big ecosystem? How about native Javascript interop?</p>
<p>The answers to these questions define how costly the adoption of technology will be. An example: although ClojureScript has a decent sized community and ecosystem, these are nothing compared to Javascript, so there&#39;s an opportunity cost in choosing this tool.</p>
<p>And that&#39;s where the analysis enters: we have to weigh the benefits, and see if they outweigh the costs in relation to using Javascript, always basing your analysis on the most up-to-date Javascript version, which means you&#39;ll have to have a &quot;transpiling&quot; build phase, and learn some new concepts anyway.</p>
<p>Sometimes we would prefer small changes - like starting to use TypeScript. Changing from Babel to TypeScript compiler is a small cost, and that can bring a project to a higher level.</p>
<p>Sometimes small changes can only bring us so far, and a bigger learning curve cost of, let&#39;s say, refactoring to Elm, can lead to so much improvement to the final code that the time invested is worth it.</p>
<p>With this in mind, is it still the case that we should always use Javascript for a front end web project?</p>
<h2 id="my-new-answer">My New Answer</h2>
<p><strong>Probably yes.</strong> And I think with a little time the answer will shift to a more certain &quot;no&quot;.  :)</p>
<p>Today (even though this is changing) Javascript is still the &quot;simple way to start doing something&quot; tool. We all have browsers that can understand Javascript, and they have awesome debugging tools. Adding a build tool and using Babel is still simpler than most front end language development workflows.</p>
<p>An important observation: if we want to develop for mobile, React Native is the best &quot;non-native&quot; choice. So it makes sense that, if we want to reuse code or even knowledge in mobile projects, Javascript is the chosen tool.</p>
<p>But this is changing fast. I really believe that in about a year or two, Javascript&#39;s only strength will be the ecosystem. Tools like <a href="https://github.com/bhauman/lein-figwheel">figwheel</a> for ClojureScript, and <a href="https://github.com/elm-lang/elm-reactor">elm-reactor</a> for Elm are already considered superior to native Javascript dev tools.</p>
<p>Having worked with Clojure before, I&#39;ve already felt the benefits of using a superior language to solve a problem. I plan to start doing small projects in different languages this year, and write about them on this blog. I would really like to here about other developers experiences with compile-to-js languages, so feel free to post it in the comments!</p>
]]></description>
            <guid isPermaLink="false">Should We Leave Javascript In Front End Programming?</guid>
            <pubDate>Tue, 22 Mar 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Centralized State Design Patterns]]></title>
            <description><![CDATA[<p>Front end programming is difficult. We are still figuring out how to best deal with it, and the quantity of frameworks and libraries that appear and disappear every week is one of the consequences.</p>
<p>At some point, Facebook launched the <a href="https://facebook.github.io/react/">React</a> framework, which seemed to have &quot;solved&quot; the rendering part of front end programming. We&#39;re all getting used to React&#39;s syntax and virtual DOM algorithm, and it seems like a good pattern, from both performance and productivity perspectives.</p>
<p>But we&#39;re still a little bit lost when it comes to managing the information being rendered. At first everyone was using React with the MV-something patterns available in Angular or Backbone. Then Facebook itself started talking about Flux and its unidirectional approach, and we started to see a lot of Flux-inspired frameworks being released.</p>
<p>At the same time, in the &quot;parallel world&quot; of <a href="https://github.com/clojure/clojurescript">ClojureScript</a>, something very interesting was happening. The first big React wrapper for ClojureScript was <a href="https://github.com/omcljs/om">Om</a>, and it featured an intriguing <em>centralized state</em> concept.</p>
<p>It was new for me, and the first thing I and a lot of people thought was, <em>but isn&#39;t anything global really bad? Especially global state???</em> Now, months later, the centralized state concept is proving itself very powerful and simple, especially with libraries such as <a href="https://github.com/Yomguithereal/baobab">Baobab</a>, and, in particluar, <a href="http://rackt.org/redux/">Redux</a> becoming the new standard. (<a href="https://github.com/moreartyjs/moreartyjs">Morearty</a> seems to have been the first, but didn&#39;t gain as much traction as the others).</p>
<p>In the last year I&#39;ve studied and implemented projects with some of these frameworks, and even implemented a centralized state from scratch a couple of times. In this post, I will talk about the two design patterns you&#39;ll probably come across when working with a centralized state.</p>
<h2 id="update-listeners">Update Listeners</h2>
<p>I call the first design pattern the <em>Update Listeners</em> pattern. This pattern is used by the <a href="https://reagent-project.github.io/">Reagent</a> framework, and by <a href="https://github.com/Yomguithereal/baobab">Baobab</a> in the javascript world. I&#39;ve <a href="http://lucasmreis.github.io/blog/a-more-functional-approach-to-angular/">written about this before</a>, and it&#39;s the pattern I use in my daily work.</p>
<p>The application state resides in a single tree object. Different UI components can <em>listen</em> to updates on different nodes of the tree, and the component is re-rendered every time that node is updated.</p>
<p><img src="../assets/update-listeners.jpg" alt="Update Listeners Illustration"></p>
<p><strong>PROS:</strong> The main benefit of this pattern is that once the listeners are setup, the components are rendered automatically when the state is updated. That means that the UI is always reflecting the current state.</p>
<p>In terms of architecture, it&#39;s also a very interesting pattern because it makes it very clear which information from the state is being used in each visual component of the application.</p>
<p>Another <em>pro</em> is that the parent component does not need to have all the information that the child component needs to be rendered. This means that if I have a &quot;post&quot; component with &quot;comments&quot; child components, I only need to pass the comments&#39; IDs to each component. They themselves will gather the necessary information to be rendered using the listeners.</p>
<p><strong>CONS:</strong> Because of the code for the listeners, the components make assumptions about the how the state object works, and how the information itself is structured.</p>
<p>The <a href="https://github.com/Yomguithereal/baobab-react">baobab-react</a> project illustrates some of the ways that components can properly listen to changes in the main tree, and you can see how the components become dependent on the implementation of the application state object.</p>
<p>Because of this, the code of the components is not very generic, nor is it reusable, and the code of the application as a whole gets very tied to the library or framework used to handle the state.</p>
<h2 id="manual-render">Manual Render</h2>
<p>This pattern is used by the <a href="https://github.com/levand/quiescent">Quiescent</a> framework, and I also used it when I wrote about <a href="http://lucasmreis.github.io/blog/using-csp-as-application-architecture/">CSP as an application architecture</a>.</p>
<p>The application state resides in a simple data structure, usually a javascript object. The whole UI is a function that accepts this state object as a parameter and renders it. The developer calls the function &quot;manually&quot;; in other words, the UI does <em>not</em> react to changes in the application state.</p>
<p><img src="../assets/manual-render.jpg" alt="Manual Render Illustration"></p>
<p><strong>PROS:</strong> The first immediate benefit is that the majority of your components will be <em>stateless</em>. That means they will be easier to reason about, and it&#39;s going to be easier to reuse them in different contexts and even different applications.</p>
<p>Also, having more control over when rendering takes place can make rendering itself more effective and performant. A common way of dealing with this is taking advantage of <code>requestAnimationFrame</code> so there are no unecessary calls to <code>React.render</code> (as I have done <a href="http://lucasmreis.github.io/blog/using-csp-as-application-architecture/">here</a>).</p>
<p><strong>CONS:</strong> One con of working with stateless components is that you have to pass every single piece of information and every callback to the components, every time you use them. This can lead to more confusing code than simple <code>&lt;UserProfile id={userId} /&gt;</code>.</p>
<p>Not only that, if a stateless component needs a different piece of data, let&#39;s say the user&#39;s profile picture url, <em>the container component will have to pass this new piece of data</em>. Sometimes this can lead to multiple components needing to change because of one small change in a child component.</p>
<p>Another common and important problem is, now that rendering is manual, we could forget to fire the render function, which would put our UI out of sync with the application state.</p>
<h2 id="conclusions">Conclusions</h2>
<p>First question is: which one is better? From my personal experience, the <em>Update Listeners</em> pattern really saved our lives once :) We had a big Angular application, with state distributed all over the code, and every new feature added a lot of complexity to it. Now it&#39;s much simpler and easier to both add new features and debug the code.</p>
<p>On the other hand, we&#39;re thinking of rewriting/refactoring four other applications. React is being considered as the view framework, and we want components to be as shareable as possible. So, all the components receive data and callbacks as props, and make no assumptions on how the application is handling state. For this situation, the <em>Manual Render</em> seems like a better approach.</p>
<p>It&#39;s the usual but true conclusion: both design patterns have strengths and weaknesses, and each will work well depending on the situation.</p>
<h2 id="last-thoughts">Last Thoughts</h2>
<p>Not all state may belong to the centralized state tree. Animation state, for instance, seems to be better stored locally, in a React component&#39;s <code>state</code>. I&#39;m still trying to figure out how to better deal with these situations, and where they would fit in these patterns.</p>
<p>This categorization is a work in progress. If you have seen centralized state being used in a different way, or have any other &quot;pros&quot; and &quot;cons&quot;, please feel free to share! Any disagreement with the &quot;pros&quot; and &quot;cons&quot; listed here? I would love to hear from you! :)</p>
]]></description>
            <guid isPermaLink="false">Centralized State Design Patterns</guid>
            <pubDate>Wed, 13 Jan 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[ES6 Destructuring Improves Readability]]></title>
            <description><![CDATA[<p>Destructuring is one of the most powerful new features of javascript. It makes it easier to write more concise code, without compromising readability. This week I figured out that destructuring is also very good for documenting functions in javascript, and I want to share this thought with you.</p>
<p>For those not familiar with destructuring, I suggest <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Mozilla website</a> as a good starting point.</p>
<p>The situation is: you are reading code written by another developer (and I include in this grouping any code that you yourself wrote more than one month ago). Suddenly, there&#39;s this function call:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> cart = getCart(cartId, <span class="hljs-number">3</span>);</code></pre>

<p>It seems like it&#39;s a simple function that &quot;gets&quot; the cart with the id <code>cartId</code>. Awesome. But one detail creeps you out: what does the <code>3</code> mean? It could literally be anything. There&#39;s no clue in the function call as to what it means,and you&#39;ll have to open another file with the function declaration to find out.</p>
<p>One way to remedy this situation is accepting a <em>config object</em> as a parameter of the function:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> cart = getCart({cartId: cartId, retries: <span class="hljs-number">3</span>});</code></pre>

<p>And now we understand that our function gets a cart and retries three times if an error occurs.</p>
<p>But now let&#39;s take a look at the function declaration:</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCart</span>(<span class="hljs-params">config</span>) </span>{
  <span class="hljs-comment">// ...</span>
}</code></pre>

<p>When we look at this declaration, we have no clue as to what parameters the function actually receives. We have to look inside the function code to see which properties of <code>config</code> are being used, which is not optimal. In the recent past, the best way to deal with this was declaring variables in the beginning of the function, which is very verbose:</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCart</span>(<span class="hljs-params">config</span>) </span>{
  <span class="hljs-keyword">const</span> cartId = config.cartId;
  <span class="hljs-keyword">const</span> retries = config.retries;
  <span class="hljs-comment">// ...</span>
}</code></pre>

<p>So there were two situations: using a usual list of parameters, which compromised the readability of function <em>calls</em>, and using a <code>config</code> object, which compromised the readability of function <em>declarations</em>.</p>
<p>You see where this is going, right? By using destructuring, we can use an object as a parameter, without these problems:</p>
<pre><code class="hljs js"><span class="hljs-comment">// declaration</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCart</span>(<span class="hljs-params">{cartId, retries}</span>) </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// call</span>
<span class="hljs-keyword">const</span> cart = getCart({cartId: cartId, retries: <span class="hljs-number">3</span>});</code></pre>

<p>It may seem like a minor issue, but it saves a lot of time in the long run! You look at the function declaration and you know which parameters it expects. You look at a function call and you understand what the values being passed mean.</p>
<p>A nice situation where destructuring becomes a very useful documentation tool is React. After version <code>v0.14</code>, stateless components were introduced. They are simple components, declared as functions. An example would be:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> LoginForm = ({
  username,
  password,
  onForgetPassword,
  onSubmit}) =&gt;
    <span class="hljs-comment">//...</span></code></pre>

<p>Smooth, isn&#39;t it? :)</p>
]]></description>
            <guid isPermaLink="false">ES6 Destructuring Improves Readability</guid>
            <pubDate>Tue, 15 Dec 2015 00:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>