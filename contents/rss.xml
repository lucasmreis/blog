<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[Lucas Reis' Blog]]></title>
        <description><![CDATA[In this blog, I'll write about some of the things that I have found useful and helpful to my programming.]]></description>
        <link>http://lucasmreis.github.io/blog/</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Sat, 04 Feb 2017 00:45:38 GMT</lastBuildDate>
        <atom:link href="http://lucasmreis.github.io/blog/rss.xml" rel="self" type="application/rss+xml"/>
        <language><![CDATA[English]]></language>
        <managingEditor><![CDATA[Lucas Reis]]></managingEditor>
        <webMaster><![CDATA[Lucas Reis]]></webMaster>
        <item>
            <title><![CDATA[Type Driven Domain Modelling, part 2]]></title>
            <description><![CDATA[<p><em>This is part 2 of a series:</em></p>
<ul>
<li><a href="http://lucasmreis.github.io/blog/type-driven-domain-modelling-part-1/">Part 1: Types And Property Testing</a></li>
</ul>
<p>We wrote our initial domain in part 1. The user produces an event called <code>AddToBasket</code>, with a product and a quantity. Then we wrote a function that takes a list of events, and produces a read model to send to the client to be rendered.</p>
<p>In this second part we&#39;ll add <em>promotions</em> to products, and make sure total calculations are right!</p>
<h2 id="spec">Spec</h2>
<p>In the second part of the series, we&#39;ll add what I call <em>quantity promotions</em>: they are the classic &quot;buy N for X&quot;. For instance, an item costs $3, but we can buy 2 for $5. This is the promotion we&#39;re going to model in this post.</p>
<h2 id="modelling-a-promotion">Modelling A Promotion</h2>
<p><em>The starting point for this code is <a href="https://github.com/lucasmreis/basket-promotions-kata/blob/master/BasketPromotions/DomainPart1.fs">here</a>.</em></p>
<p>First, let&#39;s start with the Promotion itself, and add it to the Product type:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Promotion</span> </span>= {
    promoQty: Qty
    promoPrice: Price
}

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Product</span> </span>= {
    sku: Sku
    price: Price
    promotion: Promotion option
}</code></pre>

<p>It&#39;s modeled as an Option, since not all products have a promotion.</p>
<p>With that in mind, we need to change the <code>buildLine</code> function to account for promotions. Let&#39;s build a function to calculate the total of a line, given a product and a quantity:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> lineTotal quantity product =
    <span class="hljs-keyword">match</span> product.promotion <span class="hljs-keyword">with</span>
    | None -&gt; quantity * product.price
    | Some promotion -&gt; <span class="hljs-number">0</span> <span class="hljs-comment">// implement it!</span>

<span class="hljs-keyword">let</span> buildLine product quantity = {
    productSku = product.sku
    quantity = quantity
    lineTotal = lineTotal quantity product
}</code></pre>

<p>Everything is working up to this point, but one thing bothers me: because both <code>Qty</code> and <code>Price</code> are aliases for <code>int</code>, the inferred types are often confused:</p>
<p><img src="../assets/wrong-inferring.png" alt="Wrong Inferring"></p>
<p>We could fix this particular case by &quot;forcing&quot; a <code>Qty</code> type to <code>quantity</code>, but I think there&#39;s a bigger message here: quantity and price are <em>not</em> the same thing!</p>
<p>Within our domain, there is one property of quantity that can help us model it: <em>it&#39;s never negative</em>. Another property is that it has to be able to do some arithmetic; we need to be able to sum and divide quantities at least.</p>
<p>Looking through the <a href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/primitive-types">primitives of F#</a>, I found one that can help us: <em>unsigned ints</em>! I think that <code>uint16</code> is a good choice, since it&#39;s a integer with a 0 - 65535 range. As a bonus, it also has all the arithmetic between <code>uint16</code> implemented:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Sku</span> </span>= string
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Price</span> </span>= int
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Qty</span> </span>= uint16

<span class="hljs-keyword">let</span> createQty (n : int) : Qty =
    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> (uint16 <span class="hljs-number">0</span>) <span class="hljs-keyword">else</span> (uint16 n)</code></pre>

<p>I also created a little helper to create a <code>Qty</code> from an <code>int</code>, just because. :)</p>
<h2 id="calculating-totals">Calculating Totals</h2>
<p>Now, we can right away see an error in the <code>lineTotal</code> call, since it is inferring that it takes a <code>Price</code>, and not a <code>Qty</code>. Before fixing it, I can see that we&#39;re gonna need an important functionality: we need to be able to multiply a quantity by a price! And it needs to return a price. This is a key function in our domain, so let&#39;s implement it:</p>
<pre><code class="hljs"><span class="hljs-comment">// super cool custom operator!</span>
<span class="hljs-keyword">let</span> (*) (qty : Qty) (price : Price) : Price =
    <span class="hljs-keyword">int</span> qty * price

<span class="hljs-keyword">let</span> lineTotal quantity product =
    <span class="hljs-keyword">match</span> product.promotion with
    <span class="hljs-params">| None -&gt; quantity * product.price
    |</span> <span class="hljs-literal">Some</span> promotion -&gt; <span class="hljs-number">0</span> <span class="hljs-comment">// implement it!</span></code></pre>

<p>Much cleaner. Now, the difficult part: actually calculating the total of a line, when the product is promoted. Let&#39;s do some TDD-ish programming, since it&#39;s easy to make some mistakes in calculations like these. First, a stub of the function itself:</p>
<pre><code class="hljs fsharp"><span class="hljs-comment">// Domain.fs</span>
<span class="hljs-keyword">let</span> promotedTotal quantity price promotion = <span class="hljs-number">0</span>

<span class="hljs-comment">// Tests.fs</span>
(...)

testProperty <span class="hljs-string">"promoted line total"</span> &lt;| <span class="hljs-keyword">fun</span> (N : Qty) -&gt;
    <span class="hljs-keyword">let</span> promoQty = N + (createQty <span class="hljs-number">2</span>)
    <span class="hljs-keyword">let</span> promotion = { promoQty = promoQty ; promoPrice = <span class="hljs-number">7</span> }
    <span class="hljs-keyword">let</span> promoted = promotedTotal promoQty <span class="hljs-number">10</span> promotion

    <span class="hljs-keyword">let</span> notPromoQty = N + (createQty <span class="hljs-number">1</span>)
    <span class="hljs-keyword">let</span> notPromoted = promotedTotal notPromoQty <span class="hljs-number">10</span> promotion

    <span class="hljs-keyword">let</span> promotedExpected = <span class="hljs-number">7</span>
    <span class="hljs-keyword">let</span> notPromotedExpected = notPromoQty * <span class="hljs-number">10</span>

    Expect.equal promoted promotedExpected <span class="hljs-string">"same price as promotion"</span>
    Expect.equal notPromoted notPromotedExpected <span class="hljs-string">"multiplied by regular price"</span></code></pre>

<p>I also had to correct the other tests to work with the new <code>Product</code> and <code>Price</code> types. The final version of the test file is <a href="https://github.com/lucasmreis/basket-promotions-kata/blob/master/BasketPromotions/Tests.fs">here</a>. Fixing these errors is very direct, since it only involves &quot;getting rid of the red underlinings&quot; that Ionide + the compiler signal. It&#39;s never - ever - that easy in JS, or any other dynamic language for that matter. It&#39;s a much more stressful activity, and stressful activities drain your energy.</p>
<p>The test is simple: if I have a promotion &quot;buy N for $7&quot;, if I add N to the basket, my total is 7. If I add N - 1, my total is (N - 1) * unit price. (I use <code>N + (createQty 2)</code> here to guarantee that I don&#39;t have any unwanted zeros).</p>
<p>Now, the implementation:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> promotedTotal quantity price promotion =
    <span class="hljs-keyword">let</span> promotedQty = quantity / promotion.promoQty
    <span class="hljs-keyword">let</span> promotedTotal = promotedQty * promotion.promoPrice

    <span class="hljs-keyword">let</span> notPromotedQty = quantity % promotion.promoQty
    <span class="hljs-keyword">let</span> notPromotedTotal = notPromotedQty * price

    promotedTotal + notPromotedTotal

<span class="hljs-keyword">let</span> lineTotal quantity product =
    <span class="hljs-keyword">match</span> product.promotion <span class="hljs-keyword">with</span>
    | None -&gt; quantity * product.price
    | Some promotion -&gt; promotedTotal quantity product.price promotion</code></pre>

<p>Run the Expecto tests, and there we have it! Working totals :)</p>
<h2 id="experimenting-with-the-domain">Experimenting With The Domain</h2>
<p>Even though the project has no compile errors and the tests are ok, it&#39;s still good practice to experiment with the types and functions. At the very least you will be able to rest easy seeing that everything is working, right?</p>
<p>A good way of doing this is by creating a script file, including our Domain module, and just sending code to F# Interactive. For instance, I created a <code>Experiments.fsx</code> file, with the following contents:</p>
<pre><code class="hljs fsharp">#load <span class="hljs-string">"Domain.fs"</span>

<span class="hljs-keyword">open</span> Domain

<span class="hljs-keyword">let</span> productA = {
    sku = <span class="hljs-string">"a"</span>
    price = <span class="hljs-number">1</span>
    promotion = None
}

<span class="hljs-keyword">let</span> productB = {
    sku = <span class="hljs-string">"b"</span>
    price = <span class="hljs-number">2</span>
    promotion = Some {
        promoQty = createQty <span class="hljs-number">3</span>
        promoPrice = <span class="hljs-number">5</span>
    }
}

<span class="hljs-keyword">let</span> events = [
    AddToBasket(productA, createQty <span class="hljs-number">5</span>)
    AddToBasket(productB, createQty <span class="hljs-number">7</span>)
    AddToBasket(productA, createQty <span class="hljs-number">4</span>)
]

<span class="hljs-keyword">let</span> myBasket = List.fold update empty events</code></pre>

<p>I created a couple of products, one with a promotion. Then I created a series of events, and built a basket with it. With Ionide it&#39;s easy to run:</p>
<p><img src="../assets/ionide-fsi-send-file.png" alt="FSI Send File"></p>
<p>Now we can play with different products and events, and check the results!</p>
<h2 id="conclusions">Conclusions</h2>
<p>Changing F# code is so smooth, it&#39;s almost fun. And this is a good thing - it&#39;s a sign that it does not <em>drain a lot of energy</em> from the developer. We can focus on the models and algorithms without using a lot of energy with silly errors from the changes we&#39;re making.</p>
<p>Whenever we do a lot of cognitive-intense work, we get tired. There&#39;s no escape to that. And when we get tired, we make mistakes. In the projects I&#39;ve worked on, I think 90% of the simple errors that were deployed to production were deployed by tired developers. So, that&#39;s another positive contribution from F# and its tooling and ecosystem to a project&#39;s <em>safety</em>, in the sense that <em>no unwanted accidents happen in production</em>.</p>
<p>The final code for the domain is <a href="https://github.com/lucasmreis/basket-promotions-kata/blob/master/BasketPromotions/Domain.fs">here</a>, and the final code for the tests are <a href="https://github.com/lucasmreis/basket-promotions-kata/blob/master/BasketPromotions/Tests.fs">here</a>.</p>
<h2 id="next-steps">Next Steps</h2>
<p>Imagine we want not only to show the calculated totals, but we also want to show to our users <em>how much they are saving</em> on each line, and in the basket as a whole. I&#39;ll cover this in Part 3 of this series!</p>
]]></description>
            <guid isPermaLink="false">Type Driven Domain Modelling, part 2</guid>
            <pubDate>Wed, 01 Feb 2017 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Type Driven Domain Modelling, part 1]]></title>
            <description><![CDATA[<p><em>This is part 1 of a series:</em></p>
<ul>
<li><a href="http://lucasmreis.github.io/blog/type-driven-domain-modelling-part-2/">Part 2: Evolving Models</a></li>
</ul>
<p>A while ago I saw this tweet:</p>
<div style="display: flex; justify-content: center">
  <blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Every system tends towards complexity, slowness and difficulty<br>Staying simple, fast and easy-to-use is a battle that must be fought everyday</p>&mdash; Guillermo Rauch (@rauchg) <a href="https://twitter.com/rauchg/status/813529770059186176">December 26, 2016</a></blockquote>
  <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>

<p>I work daily in big javascript projects, so I get where Guillermo is coming from. Javascript doesn&#39;t have types, and doesn&#39;t enforce immutability, so the following things tend to happen in almost every project I&#39;ve come across:</p>
<ol>
<li>The first version is (most of the time) clean and simple. Well chosen libraries being used with the best practices.</li>
<li>As a project grows, big refactorings begin to become more and more &quot;dangerous&quot;. There&#39;s always the risk of having a runtime error that was not caught in dev, and will be caught in production.</li>
<li>New changes, then, become small refactorings, mostly <em>thin layers of code</em> over previous code. A lot of null / undefined testing takes place, unit tests are corrected, and new ones are written.</li>
</ol>
<p>These thin layers of code end up adding bits of complexity to the code. At first it&#39;s manageable, but, months later, the project starts getting more and more difficult to change. The worst effect on these projects is losing <em>reliability</em> and <em>safety</em>: we are not sure the application does what we want it to do, and we are not sure if any hidden bugs will make it to production.</p>
<p>Of course, there are tools to help us deal with this complexity. We&#39;ve been using Typescript at work for a while now, and it has been great. But, from <a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">my previous</a> <a href="http://lucasmreis.github.io/blog/does-elm-harmonize-with-f/#/">experiments here</a> <a href="http://lucasmreis.github.io/blog/from-elm-to-fable/">in the blog</a>, I still think that a &quot;stronger typed&quot; language could help much more to avoid this type of complexity-piling.</p>
<p>So, in this post series, I&#39;ll model a simple e-commerce basket using F#. Then I&#39;ll change the specs and add features of this model, and try to maintain reliability and simplicity in the code. Let&#39;s start!</p>
<h2 id="specs">Specs</h2>
<p>Let&#39;s keep the first spec simple: the user can add a quantity of a product to his basket, he should have access to the current state of the basket, with a calculated total.</p>
<p>The next version should contemplate what I&#39;ll call <em>quantity promotions</em>; it&#39;s the classic <em>buy 3 pay $10</em>, <em>buy 2 pay 5</em> kind of promotion.</p>
<p>On version 3, not only the final price should be shown to the user, but it should also show the price <em>without considering the promotions</em>, and how much discount was given in that product.</p>
<p>On version 4, and final version (maybe?), we should also tell the user, for each line &quot;if you buy another 2 of these, you&#39;ll have an added discount of X!&quot;. This tip will be based in the quantity promotions of each product.</p>
<h2 id="initial-setup">Initial Setup</h2>
<p>I&#39;ll use <a href="https://code.visualstudio.com/">VS Code</a> editor with the <a href="https://github.com/ionide/ionide-vscode-fsharp">Ionide</a> extension to start a new project. I chose to start an &quot;Expecto&quot; project, since it already has a test file configured:</p>
<div style="display: flex">
  <div style="padding-right: 10px">
    <img src="../assets/ionide-new-project.png" alt="Ionide: New Project" style="box-shadow: 5px 5px 14px 0px #999" />
  </div>
  <div>
    <img src="../assets/ionide-expecto.png" alt="Ionide: Expecto" style="box-shadow: 5px 5px 14px 0px #999" />
  </div>
</div>

<p>After the project is created, we need to create a new file. I created a <code>Domain.fs</code> file inside the project folder, together with the <code>Main.fs</code> and <code>Tests.fs</code> that were there. Now - and this is particular to F# - the file needs to be <em>added to the project</em>. In every F# project, we need to specify not only the files to be compiled, but the <em>order in which they should be compiled</em>. That may sound weird and too old-school, but today I agree that <a href="https://fsharpforfunandprofit.com/posts/cyclic-dependencies/">its a good thing</a>, since it helps to avoid circular dependencies among other problems.</p>
<p>So, to add it, open the <code>.fsproj</code> file in the project folder. It&#39;s a big messy XML, I know :) The file ordering is easy to do, though. Just search for the <code>Main.fs</code> file, and you&#39;ll find this XML node:</p>
<pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Compile</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"Tests.fs"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Compile</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"Main.fs"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">None</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"App.config"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span></code></pre>

<p>The <code>Domain.fs</code> file needs to be compiled before the other files, so we only need to change the config to:</p>
<pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Compile</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"Domain.fs"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Compile</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"Tests.fs"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Compile</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"Main.fs"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">None</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"App.config"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span></code></pre>

<p>This way our file is going to be compiled first, and we can use it in the tests and in the main function.</p>
<h2 id="starting-with-the-domain">Starting With The Domain</h2>
<p>Now we can start to code our model in the <code>Domain.fs</code> file:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">module</span> Domain

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Product</span> </span>= {
    sku: string
    price: int
}

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Event</span> </span>=
    | AddToBasket <span class="hljs-keyword">of</span> Product * int</code></pre>

<p>The first thing I don&#39;t like about this modelling is that we&#39;re using <code>int</code> for the price, and we&#39;re also using <code>int</code> for the quantity in the event. The latter is especially bad, since it&#39;s not clear that it means the quantity of products added to the basket. One way of making it better and more explicit would be:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Sku</span> </span>= string
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Price</span> </span>= int
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Qty</span> </span>= int

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Product</span> </span>= {
    sku: Sku
    price: Price
}

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Event</span> </span>=
    | AddToBasket <span class="hljs-keyword">of</span> Product * Qty</code></pre>

<p>Much better, right?</p>
<p><em>Observation</em>: I&#39;m using int as the price unit because I know that in the first specs I only have to sum and subtract prices. In these situations, I think an integer representing cents are enough. Things get hairy when dividing money, and other more complex conversions. When our model needs that, we will probably need to change from <code>int</code> to something else.</p>
<h2 id="the-basket-read-model">The Basket Read Model</h2>
<p>The user should have access to the current state of the basket, and to the total he or she will have to pay. Let&#39;s first define a <em>line</em>, which is a combination of a sku, a quantity and a total price:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Line</span> </span>= {
    productSku: Sku
    quantity: Qty
    lineTotal: Price
}</code></pre>

<p>Now, the basket read model can be defined as a list of lines and a total to be paid:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Basket</span> </span>= {
    lines: Line list
    total: Price
}</code></pre>

<p>I consider these to be good initial types. Let&#39;s start with these, and make changes when we see the need.</p>
<p>The basket will be built by an <code>update</code> function, that takes a basket and an event as parameters, and returns an updated basket:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> empty = { lines = [] ; total = <span class="hljs-number">0</span> }

<span class="hljs-comment">// wrong implementation so</span>
<span class="hljs-comment">// we can write our test;</span>
<span class="hljs-comment">// this is our main function!</span>
<span class="hljs-keyword">let</span> addToBasket product basket = empty

<span class="hljs-keyword">let</span> update basket event =
    <span class="hljs-keyword">match</span> event <span class="hljs-keyword">with</span>
    | AddToBasket(product, quantity) -&gt;
        addToBasket product basket</code></pre>

<h2 id="the-first-tests">The First Tests</h2>
<p>Before starting the tests, let&#39;s think about some properties of our basket. One good property is <em>if there&#39;s only one line in our basket, it&#39;s total must be the same as the basket&#39;s total</em>. Let&#39;s write a test that makes sure this property holds.</p>
<p>First, we need to install <code>Expecto.FsCheck</code>, which is the library that let&#39;s Expecto run <a href="http://lucasmreis.github.io/blog/learning-elm-part-4/">property based tests</a>. With the <code>paket.dependencies</code> file opened, run the <em>Add Nuget Package</em> command to install the package:</p>
<div style="display: flex">
  <div style="padding-right: 10px">
    <img src="../assets/ionide-add-nuget.png" alt="Ionide: Add Nuget" style="box-shadow: 5px 5px 14px 0px #999" />
  </div>
  <div>
    <img src="../assets/ionide-expecto-fscheck.png" alt="Ionide: Expecto FsCheck" style="box-shadow: 5px 5px 14px 0px #999" />
  </div>
</div>

<p>Now that the package is installed, we need to add the dependency in the project. Open the <code>paket.references</code> file, and add <code>Expecto.FsCheck</code> to the list of dependencies. Then run the install command from Paket:</p>
<div style="display: flex">
  <div style="padding-right: 10px">
    <img src="../assets/ionide-paket-references.png" alt="Ionide: Paket References" style="box-shadow: 5px 5px 14px 0px #999" />
  </div>
  <div>
    <img src="../assets/ionide-paket-install.png" alt="Ionide: Paket Install" style="box-shadow: 5px 5px 14px 0px #999" />
  </div>
</div>

<p>Now, in the <code>Tests.fs</code> file, let&#39;s write the following test:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">open</span> Domain

<span class="hljs-meta">[&lt;Tests&gt;]</span>
<span class="hljs-keyword">let</span> tests =
    testList <span class="hljs-string">"basket promotions"</span> [
        testProperty <span class="hljs-string">"total of single line"</span> &lt;| <span class="hljs-keyword">fun</span> (quantity : Qty ) (price : Price) -&gt;
            <span class="hljs-keyword">let</span> prod = { sku = <span class="hljs-string">"a"</span> ; price = price }
            <span class="hljs-keyword">let</span> event = AddToBasket(prod, quantity)
            <span class="hljs-keyword">let</span> basket = update empty event

            <span class="hljs-keyword">let</span> lineTotal = basket.lines.Head.lineTotal
            <span class="hljs-keyword">let</span> basketTotal = basket.total

            Expect.equal lineTotal basketTotal <span class="hljs-string">"must be the same as basket total"</span>
    ]</code></pre>

<p>That&#39;s the first property to our model that we&#39;re going to test. Another property is <em>whenever a new product is added, if it&#39;s already in the basket, the number of lines stays the same</em>:</p>
<pre><code class="hljs">testProperty <span class="hljs-string">"adding product multiple times downto the basket"</span> &lt;| <span class="hljs-function"><span class="hljs-title">fun</span> <span class="hljs-params">(N : <span class="hljs-type">uint16</span> )</span></span> -&gt;
    let prod = { sku = <span class="hljs-string">"sku"</span> ; price = <span class="hljs-number">10</span> }
    let event = AddToBasket(prod, <span class="hljs-number">1</span>)
    let basket =
        [<span class="hljs-number">1.</span>.(int N + <span class="hljs-number">1</span>)]
        |&gt; List.map (<span class="hljs-function"><span class="hljs-keyword">fun</span> _ -&gt; event)</span>
        |&gt; List.fold update empty

    Expect.equal basket.lines.Length <span class="hljs-number">1</span> <span class="hljs-string">"must have one line"</span></code></pre>

<p>Note the use of <code>N : uint16</code> in the parameter. I chose it because of the range: it goes from 0 to 65535, so it&#39;s never negative, and it has a reasonable range for this application. Calling <code>(int N + 1)</code> converts it to the desired type and range.</p>
<p>And, of course, the property <em>if we add N different products, our basket will have N lines</em>:</p>
<pre><code class="hljs fsharp">testProperty <span class="hljs-string">"adding multiple products to the basket"</span> &lt;| <span class="hljs-keyword">fun</span> (N : uint16 ) -&gt;
    <span class="hljs-keyword">let</span> prod (num : int) = { sku = <span class="hljs-string">"sku"</span> + num.ToString() ; price = <span class="hljs-number">10</span> }
    <span class="hljs-keyword">let</span> event (num : int) = AddToBasket(prod num, <span class="hljs-number">1</span>)
    <span class="hljs-keyword">let</span> basket =
        [<span class="hljs-number">1.</span>.(int N + <span class="hljs-number">1</span>)]
        |&gt; List.map event
        |&gt; List.fold update empty

    Expect.equal basket.lines.Length (int N + <span class="hljs-number">1</span>) <span class="hljs-string">"must have N lines"</span></code></pre>

<p>These tests seem enough to make sure the function is reliable. If you have any ideas for other basket properties that could be tested, or even some unit tests that seem important, please let me know in the comments!</p>
<h2 id="the-function">The Function</h2>
<p>The <code>addToBasket</code> function should be straightforward: it should add a line with the selected quantity and sku and the calculated total. Then it should calculate the basket total by summing the line totals. The only &quot;gotcha&quot; is that, if the product is already in the basket, the corresponding line should be updated.</p>
<p>So, I&#39;ll start with two helper functions:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> buildLine product quantity = {
    productSku = product.sku
    quantity = quantity
    lineTotal = quantity * product.price
}

<span class="hljs-keyword">let</span> basketTotal lines =
    lines
    |&gt; List.map (<span class="hljs-keyword">fun</span> l -&gt; l.lineTotal)
    |&gt; List.sum</code></pre>

<p>Now, for the actual function, I&#39;ll use this strategy: I&#39;ll <em>transform</em> the Line list so that a line with the same sku as the product being added gets updated. If this transformed list is different than the original line list, that means that the product was already in the basket! If the transformed list is the same, that means we only need to append a new line to the list:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> addToBasket product quantity basket =
    <span class="hljs-keyword">let</span> transformLine line =
        <span class="hljs-keyword">if</span> line.productSku = product.sku
        <span class="hljs-keyword">then</span> buildLine product (line.quantity + quantity)
        <span class="hljs-keyword">else</span> line

    <span class="hljs-keyword">let</span> transformedLines =
        basket.lines
        |&gt; List.map transformLine

    <span class="hljs-keyword">let</span> productAlreadyInBasket =
        transformedLines &lt;&gt; basket.lines

    <span class="hljs-keyword">let</span> lines =
        <span class="hljs-keyword">if</span> productAlreadyInBasket
        <span class="hljs-keyword">then</span> transformedLines
        <span class="hljs-keyword">else</span> (buildLine product quantity)::basket.lines

    { basket <span class="hljs-keyword">with</span> lines = lines ; total = basketTotal lines }</code></pre>

<p>Now run the Expecto tests, and voil√°! Everything is working :)</p>
<h2 id="conclusions">Conclusions</h2>
<p>It&#39;s incredible how reliable your code can feel when it&#39;s written in a strong typed language with some property tests. This is a trait of ML-type languages like F#, Haskell, Ocaml and Elm, and I think this is the the direction we should look in when looking for reliability and safety.</p>
<p>Speaking on F# in particular, it&#39;s a very &quot;agile&quot; developing experience. Good type inferring, with the tooling that Ionide provides, makes it very easy and quick to experiment with different ways of writing the same thing, while still maintaining correctness through types.</p>
<p>Another good surprise was Expecto, and how easy it was to setup, write and run the tests - even the property based ones.</p>
<p>The final code can be found <a href="https://github.com/lucasmreis/basket-promotions-kata/blob/master/BasketPromotions/Domain.fs">here</a>, and the tests <a href="https://github.com/lucasmreis/basket-promotions-kata/blob/master/BasketPromotions/Tests.fs">here</a>.</p>
<h2 id="next-steps">Next Steps</h2>
<p>Now that we have a simple model working, it&#39;s time to change the specs and add new features. In my next update I&#39;ll add promotions to the products. Stay tuned!</p>
<p>And, as always, I&#39;m constantly learning - and would love to know if some of you have any ideas on how to better implement these specs, or if there&#39;s any library or framework that I&#39;m missing and would make my life easier. Thanks in advance :)</p>
]]></description>
            <guid isPermaLink="false">Type Driven Domain Modelling, part 1</guid>
            <pubDate>Thu, 26 Jan 2017 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[From Elm To Fable]]></title>
            <description><![CDATA[<p>A few months ago I started a <a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">quest to gain reliability in frontend development</a>. I chose Elm as my starting point, from this list:</p>
<ol>
<li>Plain Javascript</li>
<li>Facebook Flow</li>
<li>TypeScript</li>
<li>PureScript</li>
<li>Elm</li>
</ol>
<p>This was a ranking from &quot;not reliable&quot; to &quot;reliable&quot; frontend languages, mainly taking <em>types</em> into consideration. After programming with Elm a bit (and fiding it awesome :) ), I started looking for <a href="http://lucasmreis.github.io/blog/does-elm-harmonize-with-f/#/">other languages with similar characteristics</a>. That was when I found F#, and I&#39;m really impressed by it.</p>
<p>It turns out that there is an F# to JS compiler called <a href="http://fable.io/">Fable</a>. In the ranking, it would be between Typescript and Purescript, because it trades a bit of its &quot;safety&quot; for an easier Javascript interop.</p>
<p>In this post I&#39;ll &quot;convert&quot; the <a href="http://lucasmreis.github.io/blog/learning-elm-part-3/">star wars app I wrote in Elm</a> to Fable, and then I&#39;ll refactor it. Along the way, I&#39;ll compare the experience to both Elm and regular Javascript workflows.</p>
<p>For this post, I&#39;ll presume some familiarity with Elm or other ML languages, mainly that you understand how <em>discriminated unions</em> and <em>pattern matching</em> work. I wrote about these subjects in <a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">part one of the Learning Elm series</a>. Scott Wlaschin has one of the best blogs on typed functional programming that I&#39;ve come across, and has written a <a href="https://fsharpforfunandprofit.com/posts/discriminated-unions/">great article on F# discriminated unions</a>.</p>
<p>Let&#39;s get started!</p>
<h2 id="starting-a-new-fable-project">Starting A New Fable Project</h2>
<p>Elm is very &quot;beginner friendly&quot; - <em>it has always been one of its main goals</em>. This makes it very easy to start out playing with the language, be it with <a href="http://elm-lang.org/try">Try Elm online</a> or using <a href="https://github.com/elm-lang/elm-reactor">Elm Reactor</a> locally. Fable works more like a regular Javascript transpiler; so we need to do the initial pumbling, and then run our project through a local server.</p>
<p>Fortunately, it&#39;s simple. This is what I did: first, I wrote an index.html file that imports a <code>build/bundle.js</code> script:</p>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">'Content-Type'</span> <span class="hljs-attr">content</span>=<span class="hljs-string">'text/html; charset=utf-8'</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Star Wars - Fable<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"build/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<p>Then I globally installed the Fable compiler, and locally installed the <code>fable-core</code> and <code>fable-compiler</code> packages in the project:</p>
<pre><code class="hljs bash">$ npm install -g fable-compiler
$ npm init
$ npm install --save fable-core fable-compiler</code></pre>

<p>Before writing the first F# file, please install the <a href="http://ionide.io/">Ionide extension</a> to VS Code or Atom. It is very powerful, and makes the developing experience very pleasurable. The compiler realtime help is even <em>better</em> than Elm&#39;s! I&#39;ll talk more about this in the conclusion.</p>
<p>Now we can write a F# file, let&#39;s say in <code>src/Main.fsx</code>:</p>
<pre><code class="hljs fsharp">#r <span class="hljs-string">"../node_modules/fable-core/Fable.Core.dll"</span>

<span class="hljs-keyword">open</span> Fable.Import.Browser

console.log(<span class="hljs-string">"It's working!"</span>)</code></pre>

<p>I&#39;ll explain the syntax soon. Now we can build the project by using the <code>fable</code> command with some arguments:</p>
<pre><code class="hljs bash">$ fable src/Main.fsx --outDir ./build --rollup</code></pre>

<p>I&#39;m saying &quot;build the <code>src/Main.fsx</code> file, and save the output in the <code>./build</code> directory, and bundle it using the <a href="http://rollupjs.org/">Rollup bundler!</a>&quot;.</p>
<p>Now, as a last step, to run the built project, choose your favorite simple local server to serve the index.html. I&#39;ve been using <code>http-server</code> and haven&#39;t had any problems:</p>
<pre><code class="hljs bash">$ npm install -g http-server
$ http-server</code></pre>

<p>Just head to <code>http://localhost:8080</code> and we&#39;re running! :)</p>
<h2 id="the-fsx-file">The .fsx File</h2>
<p>The <code>Main.fsx</code> file is a F# script. That&#39;s the format we&#39;re going to use in this project. Let me explain our initial script:</p>
<ul>
<li>Usually in the beginning of the file, the external dependencies are listed. This is how regular F# dll&#39;s are imported:</li>
</ul>
<pre><code class="hljs fsharp">#r <span class="hljs-string">"../node_modules/fable-core/Fable.Core.dll"</span></code></pre>

<p>(If we want to import another .fsx file or a regular .fs F# file we will use the <code>#load</code> command)</p>
<ul>
<li>Then import the modules that&#39;ll be used:</li>
</ul>
<pre><code class="hljs fsharp"><span class="hljs-keyword">open</span> Fable.Import.Browser</code></pre>

<p>This module imports the browser API, like <code>window</code> or <code>console</code>.</p>
<ul>
<li>Now you can write the application code:</li>
</ul>
<pre><code class="hljs fsharp">console.log(<span class="hljs-string">"It's working!"</span>)</code></pre>

<p>That&#39;s everything that&#39;s on an fsx file. Now let&#39;s implement the Star Wars app using Fable.</p>
<h2 id="the-spec">The Spec</h2>
<p>As a reminder, let me rewrite here the application spec:</p>
<blockquote>
<p>The spec is simple: a Star Wars character &quot;card&quot; appears on the left, and corresponding film &quot;cards&quot;, representing the films of the character, are shown on the right.</p>
<p>Clicking on a film &quot;card&quot; displays it on the left, and a list of the characters that appear in the film are shown on the right. And so on.</p>
</blockquote>
<p><img src="../assets/swspec.jpg" alt="Characters And Films"></p>
<p><em>Characters cards will be yellow, and film cards will be blue. By clicking on a card, it changes from one screen to the other.</em></p>
<h2 id="the-chosen-framework">The Chosen Framework</h2>
<p><a href="https://github.com/fable-compiler">Fable&#39;s github page</a> also houses two frameworks: <a href="https://github.com/fable-compiler/fable-elmish">Fable Elmish</a> and <a href="http://fable.io/fable-arch/">Fable Arch</a>. Even though Elmish sounded like the one I would be more familiar with because of previous Elm experience, I chose Arch because it has better documentation - or at least a clear list of sample apps :)</p>
<p>To use it, just install it as you would any npm library:</p>
<pre><code class="hljs bash">$ npm install --save fable-arch</code></pre>

<p>An observation: Fable documentation, in general, is still not great. In fact, it&#39;s almost nonexistent if we compare to Elm or to a lot of Javascript libraries and frameworks. But the samples provided are really good and helpful, and I found them the best source for learning Fable in the first moments.</p>
<p>Another thing worth mentioning: there&#39;s a <a href="https://gitter.im/fable-compiler/Fable">Gitter channel</a> dedicated to Fable. I asked a couple of questions there, and was promptly answered. The people who actually make Fable and the frameworks are there, and they are really trying to help everyone!</p>
<h2 id="the-character-and-film-modules">The Character And Film Modules</h2>
<p>First let&#39;s write the Character and Film modules. They only contain Model and View code. Let&#39;s start with the Character model:</p>
<pre><code class="hljs fsharp">#r <span class="hljs-string">"../node_modules/fable-core/Fable.Core.dll"</span>

<span class="hljs-keyword">module</span> Character =
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Model</span> </span>=
        { name: string
          films: string list }</code></pre>

<p>That is straightforward. Only small syntax differences from Elm, like not needing a comma or writing <code>string list</code> instead of <code>List String</code>.</p>
<p>Now the Character view:</p>
<pre><code class="hljs fsharp">#load <span class="hljs-string">"../node_modules/fable-arch/Fable.Arch.Html.fs"</span>

<span class="hljs-keyword">open</span> Fable.Arch.Html

(...)

    <span class="hljs-keyword">let</span> mainStyle =
        Style
            [ <span class="hljs-string">"background-color"</span>, <span class="hljs-string">"rgba(230, 126, 34,1.0)"</span>
              <span class="hljs-string">"width"</span>, <span class="hljs-string">"200px"</span>
              <span class="hljs-string">"height"</span>, <span class="hljs-string">"200px"</span>
              <span class="hljs-string">"color"</span>, <span class="hljs-string">"white"</span>
              <span class="hljs-string">"font-family"</span>, <span class="hljs-string">"-apple-system, system, sans-serif"</span>
              <span class="hljs-string">"margin"</span>, <span class="hljs-string">"20px 0px 0px 20px"</span>
              <span class="hljs-string">"cursor"</span>, <span class="hljs-string">"pointer"</span> ]

    <span class="hljs-keyword">let</span> nameStyle =
        Style
            [ <span class="hljs-string">"padding"</span>, <span class="hljs-string">"20px"</span>
              <span class="hljs-string">"font-size"</span>, <span class="hljs-string">"18px"</span> ]

    <span class="hljs-keyword">let</span> view model =
        div
            [ mainStyle ; onMouseClick (<span class="hljs-keyword">fun</span> _ -&gt; model) ]
            [ div [ nameStyle ] [ text model.name ] ]</code></pre>

<p>The model code is very similar to the Elm version, but there&#39;s something important to be said here: <em>in F#, all code should be written in compile order</em>. That means that if you use a function or variable in another function, that should be declared earlier in the file. This is different from Elm, and from Javascript (if you declare a function with the <code>function</code> keyword). It seems this is a source of some debate in the F# community, since in regular F# projects you even need to specify the order that the files should be compiled! I have no problem with it. I tend to prefer that the <code>view</code> function comes before the style variables, but I also see that forcing things to be in order can be beneficial to the understanding of the code.</p>
<p>The Film module is then very similar:</p>
 <pre><code class="hljs fsharp"><span class="hljs-keyword">module</span> Film =
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Model</span> </span>=
        { title: string
          episodeId: int
          characters: string list }

    <span class="hljs-keyword">let</span> mainStyle =
        Style
            [ <span class="hljs-string">"background-color"</span>, <span class="hljs-string">"rgba(52, 152, 219,1.0)"</span>
              <span class="hljs-string">"width"</span>, <span class="hljs-string">"200px"</span>
              <span class="hljs-string">"height"</span>, <span class="hljs-string">"200px"</span>
              <span class="hljs-string">"color"</span>, <span class="hljs-string">"white"</span>
              <span class="hljs-string">"font-family"</span>, <span class="hljs-string">"-apple-system, system, sans-serif"</span>
              <span class="hljs-string">"margin"</span>, <span class="hljs-string">"20px 0px 0px 20px"</span>
              <span class="hljs-string">"cursor"</span>, <span class="hljs-string">"pointer"</span> ]

    <span class="hljs-keyword">let</span> nameStyle =
        Style
            [ <span class="hljs-string">"padding"</span>, <span class="hljs-string">"20px"</span>
              <span class="hljs-string">"font-size"</span>, <span class="hljs-string">"18px"</span> ]

    <span class="hljs-keyword">let</span> numberStyle =
        Style
            [ <span class="hljs-string">"padding"</span>, <span class="hljs-string">"20px 20px 0px 20px"</span>
              <span class="hljs-string">"font-size"</span>, <span class="hljs-string">"60px"</span> ]

    <span class="hljs-keyword">let</span> view model =
        div
            [ mainStyle ; onMouseClick (<span class="hljs-keyword">fun</span> _ -&gt; model) ]
            [ div [ numberStyle ] [ text (model.episodeId.ToString()) ]
              div [ nameStyle ] [ text model.title ] ]</code></pre>

<h2 id="the-application-model-and-view">The Application Model And View</h2>
<p>Let&#39;s now define the application model:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Model</span> </span>=
    | InitialScreen
    | LoadingFilms <span class="hljs-keyword">of</span> Character.Model
    | LoadingCharacters <span class="hljs-keyword">of</span> Film.Model
    | FilmsFromCharacter <span class="hljs-keyword">of</span> Character.Model * Film.Model list
    | CharactersFromFilm <span class="hljs-keyword">of</span> Film.Model * Character.Model list
    | ErrorScreen</code></pre>

<p>The application model is a discriminated union, and I just adapted the syntax from the original Elm version. </p>
<p>Let&#39;s convert the views one by one. First <code>InitialScreen</code>:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> messageStyle =
    Style
        [ <span class="hljs-string">"margin"</span>, <span class="hljs-string">"20px 0px 0px 20px"</span>
          <span class="hljs-string">"width"</span>, <span class="hljs-string">"200px"</span>
          <span class="hljs-string">"height"</span>, <span class="hljs-string">"200px"</span>
          <span class="hljs-string">"font-family"</span>, <span class="hljs-string">"-apple-system, system, sans-serif"</span>
          <span class="hljs-string">"color"</span>, <span class="hljs-string">"rgba(149, 165, 166,1.0)"</span>
          <span class="hljs-string">"font-size"</span>, <span class="hljs-string">"18px"</span> ]

<span class="hljs-keyword">let</span> messageView t =
    div [ messageStyle ] [ text t ]

<span class="hljs-keyword">let</span> view model =
    <span class="hljs-keyword">match</span> model <span class="hljs-keyword">with</span>
    | InitialScreen -&gt;
        messageView <span class="hljs-string">"Loading amazing characters and films..."</span>

    | _ -&gt; 
        div [] []</code></pre>

<p>To render the view, we need to call the run <code>createApp</code>. That&#39;s a little different from Elm&#39;s <code>Program</code>:</p>
<pre><code class="hljs fsharp">#load <span class="hljs-string">"../node_modules/fable-arch/Fable.Arch.App.fs"</span>
#load <span class="hljs-string">"../node_modules/fable-arch/Fable.Arch.Virtualdom.fs"</span>

(...)

<span class="hljs-keyword">open</span> Fable.Arch
<span class="hljs-keyword">open</span> Fable.Arch.App.AppApi

(...)

<span class="hljs-keyword">let</span> update model msg = model , []

<span class="hljs-keyword">let</span> initialModel = InitialScreen

createApp initialModel view update Virtualdom.createRender
|&gt; withStartNodeSelector <span class="hljs-string">"#app"</span>
|&gt; start</code></pre>

<p><code>createApp</code> is direct: it needs an initial model, a view function, an update function, and a <em>renderer</em>. The renderer is the engine which will render your application view to the browser dom. Currently we can only use <code>virtual-dom</code>, which is a very fast and mature library, but it seems that <a href="https://github.com/fable-compiler/fable-arch/issues/33">a React renderer is also in the works</a>.</p>
<p>We need to install <code>virtual-dom</code> in our project:</p>
<pre><code class="hljs bash">$ npm install --save virtual-dom</code></pre>

<p>Everything is looking good, right? But try compiling it. It doesn&#39;t, and outputs the following error:</p>
<pre><code class="hljs bash">‚ñ∂ fable src/Main.fsx --outDir build --rollup
fable-compiler 0.7.17: Start compilation...
Compiled fable-arch/Fable.Arch.Html.js at 11:35:51 PM
Compiled fable-arch/Fable.Arch.App.js at 11:35:51 PM
Compiled fable-arch/Fable.Arch.Virtualdom.js at 11:35:51 PM
Compiled src/Main.js at 11:35:51 PM
Bundling...
[BUNDLE ERROR] <span class="hljs-string">'h'</span> is not exported by node_modules/virtual-dom/index.js (imported by build/fable-arch/Fable.Arch.Virtualdom.js). For <span class="hljs-built_in">help</span> fixing this error see https://github.com/rollup/rollup/wiki/Troubleshooting<span class="hljs-comment">#name-is-not-exported-by-module</span>
(...)</code></pre>

<p>We&#39;re using Rollup to bundle the files. It turns out that Rollup works well with ES6 modules, but may break when using regular CommonJS modules. Since some libraries are written using CommonJS, we need to deal with these cases properly.</p>
<p>We need to configure Rollup to see the <code>virtual-dom</code> module and it&#39;s exported functions, so let me introduce you to the <code>fableconfig.json</code> file.</p>
<p>Instead of calling <code>fable src/Main.fsx --outDir ./build --rollup</code> every time, we can put the compiling configuration inside <code>fableconfig.json</code>. For example, if we have this config:</p>
<pre><code class="hljs json">{
 <span class="hljs-attr">"outDir"</span>: <span class="hljs-string">"build"</span>,
 <span class="hljs-attr">"projFile"</span>: <span class="hljs-string">"./src/Main.fsx"</span>,
 <span class="hljs-attr">"sourceMaps"</span>: <span class="hljs-literal">true</span>
}</code></pre>

<p>We can just run <code>fable</code> or <code>fable --watch</code> in the terminal and get the same output plus a sourcemap.</p>
<p>Now we can add the Rollup CommonJS configuration:</p>
<pre><code class="hljs json">{
  <span class="hljs-attr">"outDir"</span>: <span class="hljs-string">"build"</span>,
  <span class="hljs-attr">"projFile"</span>: <span class="hljs-string">"./src/Main.fsx"</span>,
  <span class="hljs-attr">"sourceMaps"</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">"rollup"</span>: {
    <span class="hljs-attr">"plugins"</span>: [
      [<span class="hljs-string">"commonjs"</span>, {
        <span class="hljs-attr">"namedExports"</span>: {
          <span class="hljs-attr">"virtual-dom"</span>: [ <span class="hljs-string">"h"</span>, <span class="hljs-string">"create"</span>, <span class="hljs-string">"diff"</span>, <span class="hljs-string">"patch"</span> ]
        }
      }]
    ]
  }
}</code></pre>

<p>This step is a small complication in our build system. It&#39;s definitely more complex than anything related to an Elm project build, but, on the other hand, it&#39;s the effect of using a very good and used <em>Javascript</em> tool. Efficient bundles are a central and important issue in frontend projects, and since we cannot escape it, I actually like that we are using a good tool for that.</p>
<h2 id="messages-and-the-rest-of-the-views">Messages And The Rest Of The Views</h2>
<p>Before building the other views, let&#39;s define the application Messages. As a reminder: a message is a description of a user action or an event that happens in the application. It is a model of the state <em>transitions</em>. Converting the original messages we have:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Msg</span> </span>=
    | LoadCharacters <span class="hljs-keyword">of</span> Film.Model
    | ToCharactersFromFilm <span class="hljs-keyword">of</span> Film.Model * Character.Model list
    | LoadFilms <span class="hljs-keyword">of</span> Character.Model
    | ToFilmsFromCharacter <span class="hljs-keyword">of</span> Character.Model * Film.Model list
    | FetchFail</code></pre>

<p>Now let&#39;s write one more case for the main view function: </p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> view model =
    <span class="hljs-keyword">match</span> model <span class="hljs-keyword">with</span>
    | InitialScreen -&gt;
        messageView <span class="hljs-string">"Loading amazing characters and films..."</span>

    | LoadingFilms ch -&gt;
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ Character.view ch
              messageView (<span class="hljs-string">"Loading "</span> + ch.name + <span class="hljs-string">" films..."</span>) ]</code></pre>

<p><code>LoadingFilms</code> shows one character and is waiting for the related films to load. If you hover on the <code>view</code> function declaration - or if you are using Ionide, it&#39;s already showing - you&#39;ll see that the function type signature is:</p>
<pre><code class="hljs fsharp">Model -&gt; DomNode&lt;Character.Model&gt;</code></pre>

<p>That means that <code>view</code> is a function that receives a Model and sends messages of type <code>Character.Model</code>. This occurs because of the attribute <code>onMouseClick (fun _ -&gt; model)</code> we wrote in the <code>Character.view</code> that we are calling in this function.</p>
<p>The thing is, we want to send messages of the type <code>Msg</code> we just defined. An error occurs if we add the <code>FilmsFromCharacter</code> case, that calls <code>Film.view</code>:</p>
<pre><code class="hljs fsharp">(...)

    | FilmsFromCharacter (ch, fs) -&gt;
        <span class="hljs-keyword">let</span> filmsView = List.map Film.view fs
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ Character.view ch
              div [] filmsView ]</code></pre>

<pre><code class="hljs bash">$ fable
[ERROR] F<span class="hljs-comment"># project contains errors:</span>
Type mismatch. Expecting a
    <span class="hljs-string">'DomNode&lt;Character.Model&gt; list'</span>    
but given a
    <span class="hljs-string">'DomNode&lt;Film.Model&gt; list'</span>    
The <span class="hljs-built_in">type</span> <span class="hljs-string">'Character.Model'</span> does not match the <span class="hljs-built_in">type</span> <span class="hljs-string">'Film.Model'</span></code></pre>

<p>So, <code>Film.view</code> sends messages of type <code>Film.Model</code>. These are not compatible with <code>Character.Model</code>, which was the message being sent by the function before we wrote the case. This is a great example of the power of F#&#39;s type inference; I don&#39;t know if you noticed, but we haven&#39;t written any type signature so far :) It&#39;s rarely needed in F#, and I still feel the same type power and safety that I felt in Elm. </p>
<p>To make sure that our main <code>view</code> only produces messages of type <code>Msg</code>, we need to <em>map</em> both the Character&#39;s and Film&#39;s <code>view</code> functions to produce it:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> mappedCharacterView model =
    <span class="hljs-keyword">let</span> characterView = Character.view model
    Html.map LoadFilms characterView

<span class="hljs-keyword">let</span> mappedFilmView model =
    <span class="hljs-keyword">let</span> filmView = Film.view model
    Html.map LoadCharacters filmView</code></pre>

<p>Now, just for fun, let&#39;s refactor <code>mappedCharacterView</code>. First of all, we can identify a <em>pipeline</em> there: we transform our model with the <code>view</code> function and then we map it to <code>LoadFilms</code> message. That translates directly to code:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> mappedCharacterView model =
    model
    |&gt; Character.view
    |&gt; Html.map LoadFilms</code></pre>

<p>Which is already simple and clear. There&#39;s another F# operator, the <code>&gt;&gt;</code>. It composes two functions into another one, in the same order as <code>|&gt;</code>. The next rewrite has the same behavior:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> mappedCharacterView model =
    <span class="hljs-keyword">let</span> transform = Character.view &gt;&gt; Html.map LoadFilms
    transform model</code></pre>

<p>When I see a function like that, I immediately think that <code>model</code> and <code>transform</code> are temporary variables that do not add a lot to readability. So I think this is a nice case where a <a href="http://lucasmreis.github.io/blog/pointfree-javascript/">point free function</a> is simple:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> mappedCharacterView =
    Character.view &gt;&gt; Html.map LoadFilms

<span class="hljs-keyword">let</span> mappedFilmView =
    Film.view &gt;&gt; Html.map LoadCharacters</code></pre>

<p>And now we can convert all the views of the application:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> view model =
    <span class="hljs-keyword">match</span> model <span class="hljs-keyword">with</span>
    | InitialScreen -&gt;
        messageView <span class="hljs-string">"Loading amazing characters and films..."</span>

    | LoadingFilms ch -&gt;
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ mappedCharacterView ch
              messageView (<span class="hljs-string">"Loading "</span> + ch.name + <span class="hljs-string">" films..."</span>) ]

    | FilmsFromCharacter (ch, fs) -&gt;
        <span class="hljs-keyword">let</span> filmsView = List.map mappedFilmView fs
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ mappedCharacterView ch
              div [] filmsView ]

    | LoadingCharacters f -&gt;
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ mappedFilmView f
              messageView (<span class="hljs-string">"Loading "</span> + f.title + <span class="hljs-string">" characters..."</span>) ]

    | CharactersFromFilm (f, chs) -&gt;
        <span class="hljs-keyword">let</span> chsView = List.map mappedCharacterView chs
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ mappedFilmView f
              div [] chsView ]

    | ErrorScreen -&gt;
        messageView <span class="hljs-string">"An error ocurred. Please refresh the page and try again - and may the Force be with you!"</span></code></pre>

<p>The syntax is very clean. I like not having to use commas when changing lines, and don&#39;t mind the occasional parenthesis. I love Elm Format and how it formats your code automatically - F# doesn&#39;t have this, but I don&#39;t feel I lose a lot of time with code formatting to get a good look and feel.</p>
<p>Now we can try the views with &quot;mock&quot; application states, for instance:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> char:Character.Model =
    { name = <span class="hljs-string">"Luke Skywalker"</span> ; films = [] }

<span class="hljs-keyword">let</span> film:Film.Model =
    { title = <span class="hljs-string">"A New Hope"</span> ; episodeId = <span class="hljs-number">4</span> ; characters = [] }

<span class="hljs-keyword">let</span> initialModel =
    FilmsFromCharacter ( char , [ film ; film ; film ] )</code></pre>

<p>Run <code>fable &amp;&amp; http-server</code> and reload the browser, and you&#39;ll see it!</p>
<h2 id="the-update-function-and-async-work">The Update Function And Async Work</h2>
<p>Fable Arch resembles Elm in the sense that the <code>update</code> function returns a new model and a list of &quot;actions&quot;. Actions are functions that receive a <code>handler</code> callback parameter; <code>handler</code> is a function that receives a <code>Msg</code> and feeds it back to the update function.</p>
<p>Let&#39;s start with the initial work of the application: getting a character from the API, and transitioning from <code>Initial Screen</code> to <code>LoadingFilms of Character.Model</code>. </p>
<p>We&#39;ll get the entities from the <a href="https://swapi.co/">Star Wars API</a>, so we need to use the browser fetch function. There&#39;s a library called <a href="https://github.com/fable-compiler/fable-powerpack">fable-powerpack</a> that makes it easier to use both fetch and promises with fable:</p>
<pre><code class="hljs bash">$ npm install --save fable-powerpack</code></pre>

<p>And then we can use the following in our project:</p>
<pre><code class="hljs fsharp">#r <span class="hljs-string">"../node_modules/fable-powerpack/Fable.PowerPack.dll"</span>

(...)

<span class="hljs-keyword">open</span> Fable.PowerPack
<span class="hljs-keyword">open</span> Fable.PowerPack.Fetch

(...)

<span class="hljs-keyword">let</span> fetchEntity url =
    promise {
        <span class="hljs-keyword">let!</span> fetched = fetch url []
        <span class="hljs-keyword">let!</span> response = fetched.text()
        <span class="hljs-keyword">return</span> response }</code></pre>

<p><code>promise { ... }</code> is a F# <em>computation expression</em>. There&#39;s nothing like it in Elm - it&#39;s kind of an ES6 generator, or ES7 async/await. Inside the promise block, code is written sequentially, but runs asynchronously. If you define a promise variable using <code>let!</code>, it will wait for the promise to resolve <em>without blocking the thread</em>, and then continue running the code. The code above could be loosely translated to Javascript as:</p>
<pre><code class="hljs js"><span class="hljs-comment">// using promises:</span>
<span class="hljs-keyword">const</span> fetchEntity = url =&gt; fetch(url, {}).then(r =&gt; r.text())

<span class="hljs-comment">// using async/await:</span>
<span class="hljs-keyword">const</span> fetchEntity = url =&gt; {
  <span class="hljs-keyword">const</span> fetched = <span class="hljs-keyword">await</span> fetch(url, {})
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetched.text()
  <span class="hljs-keyword">return</span> response
}</code></pre>

<p>The only difference is that promises run as soon as they are defined, and computation expressions run only when they are actually used. I find this to be better behaviour, and more compatible with the more &quot;famous&quot; F#&#39;s <code>async { ... }</code>.</p>
<p>The inferred type is <code>string -&gt; Promise&lt;string&gt;</code>, but we want the function to return either a Character or a Film model. So we need <code>string -&gt; Character.Model</code> and <code>string -&gt; Film.Model</code> parse functions. So, inside the Film module:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">open</span> Fable.Core.JsInterop

(...)

<span class="hljs-keyword">module</span> Film =
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Model</span> </span>=
        { title: string
          episodeId: int
          characters: string list }

    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">ModelJSON</span> </span>=
        { title: string
          episode_id: int
          characters: string list }

    <span class="hljs-keyword">let</span> parse str =
        <span class="hljs-keyword">let</span> obj = ofJson&lt;ModelJSON&gt; str
        { title = obj.title
          episodeId = obj.episode_id
          characters = obj.characters }

    (...)</code></pre>

<p>I created a record type for the json, so I could use the function <code>ofJson&lt;&#39;a&gt;</code> to convert a string by finding the json keys that are equivalent to <code>&#39;a</code> keys. Then it builds a regular <code>Film.Model</code> with the result.</p>
<p>This function has the signature <code>string -&gt; Film.Model</code>, but if there&#39;s any error in the process, it <em>raises an exception</em>. I&#39;m not an exception fan (it&#39;s not explicit in the type signature!), but it&#39;ll work here because we&#39;ll put it inside a promise computation expression, and it will behave just like it would in Javascript: it will <em>reject</em>, and we&#39;ll treat it in a <code>Promise.catch</code> expression.</p>
<p>The Character module ended up being much simpler:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">module</span> Character =

    (...)

    <span class="hljs-keyword">let</span> parse = ofJson&lt;Model&gt;</code></pre>

<p>Since <code>Model</code> already mirrors the json schema of the API :)</p>
<p>We can now change our <code>fetchEntity</code> function to receive a parser:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> fetchEntity url parser =
    promise {
        <span class="hljs-keyword">let!</span> fetched = fetch url []
        <span class="hljs-keyword">let!</span> response = fetched.text()
        <span class="hljs-keyword">return</span> response |&gt; parser }</code></pre>

<p>And we can write the <code>getFirstCharacter</code> function that fetches the first character of the application:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> getFirstCharacter handler =
    fetchEntity <span class="hljs-string">"http://swapi.co/api/people/1/"</span> Character.parse
    |&gt; Promise.map LoadFilms
    |&gt; Promise.catch ( <span class="hljs-keyword">fun</span> _ -&gt; FetchFail )
    |&gt; Promise.map handler
    |&gt; ignore</code></pre>

<p>It receives <code>handler</code> as a parameter, which is a function that will receive a <code>Msg</code> and feed it back to the appication. <code>ignore</code> is just a function that returns <code>unit</code>, which is F#&#39;s &quot;void&quot;. </p>
<p>The handler is receiving both <code>LoadFilms</code> and <code>FetchFail</code> messages, so let&#39;s implement an initial update function that changes the application state properly, and also call <code>getCharacter</code> in <code>createApp</code>:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> update model msg =
    <span class="hljs-keyword">match</span> msg <span class="hljs-keyword">with</span>
    | LoadFilms ch -&gt; LoadingFilms ch , []
    | FetchFail -&gt; ErrorScreen , []
    | _ -&gt; model , []

(...)

createApp InitialScreen view update Virtualdom.createRender
|&gt; withStartNodeSelector <span class="hljs-string">"#app"</span>
|&gt; withInitMessage getFirstCharacter
|&gt; start</code></pre>

<p>If we run the application, we&#39;ll be able to see the initial screen transitioning to the next screen with real info from the API!</p>
<p>Now the last two functions: <code>getCharacters</code> and <code>getFilms</code>, that get all the related entities of a character or a film:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> getCharacters (film: Film.Model) handler =
    film.characters
    |&gt; List.map ( <span class="hljs-keyword">fun</span> url -&gt; fetchEntity url Character.parse )
    |&gt; Promise.Parallel
    |&gt; Promise.map ( <span class="hljs-keyword">fun</span> chs -&gt; ToCharactersFromFilm (film, List.ofArray chs) )
    |&gt; Promise.catch ( <span class="hljs-keyword">fun</span> _ -&gt; FetchFail )
    |&gt; Promise.map handler
    |&gt; ignore</code></pre>

<p>This function fetchs all the entities in parallel, waits for all the promises to resolve, builds a <code>ToCharactersFromFilm</code> message and calls <code>handler</code>.</p>
<p><code>getFilms</code> is almost mirrored:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> getFilms (character: Character.Model) handler =
    character.films
    |&gt; List.map ( <span class="hljs-keyword">fun</span> url -&gt; fetchEntity url Film.parse )
    |&gt; Promise.Parallel
    |&gt; Promise.map ( <span class="hljs-keyword">fun</span> fs -&gt; ToFilmsFromCharacter (character, List.ofArray fs) )
    |&gt; Promise.catch ( <span class="hljs-keyword">fun</span> _ -&gt; FetchFail )
    |&gt; Promise.map handler
    |&gt; ignore</code></pre>

<p>Now we&#39;ll finish our update (notice the side-effects listed!):</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> update model msg =
    <span class="hljs-keyword">match</span> msg <span class="hljs-keyword">with</span>
    | LoadCharacters f -&gt;
        LoadingCharacters f , [ getCharacters f ]

    | ToCharactersFromFilm ( f , chs ) -&gt;
        CharactersFromFilm ( f , chs ), []

    | LoadFilms ch -&gt;
        LoadingFilms ch , [ getFilms ch ]

    | ToFilmsFromCharacter ( ch , fs ) -&gt;
        FilmsFromCharacter ( ch , fs ), []

    | FetchFail -&gt;
        ErrorScreen , []</code></pre>

<p>And that&#39;s it - the application is up and running without any errors. That&#39;s the sensation you have only with a good compiled language: code running and working at the same time, from the very beginning.</p>
<p>The complete application <a href="https://github.com/lucasmreis/star-wars-fable/blob/master/src/MainFirst.fsx">can be found here</a>.</p>
<h2 id="bonus-refactoring-">Bonus: Refactoring!</h2>
<p>There&#39;s one thing that I really don&#39;t like in this solution: the amount of &quot;almost duplicate&quot; code related to Characters and Films. I feel I&#39;m writing everything twice. I think it came from thinking that Character and Film should be separate modules, and I could not figure out at the time a way to have &quot;generic&quot; modules or something of the sort. So I&#39;ll try now to make it better, and find a better abstraction for Character and Film that does not result in &quot;almost duplicate&quot; code.</p>
<p>I&#39;ll start by defining the models of the entities:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Url</span> </span>= string

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Details</span> </span>=
    | Character <span class="hljs-keyword">of</span> name: string
    | Film <span class="hljs-keyword">of</span> title: string * episode: string

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Entity</span> </span>=
    { related : Url list
      details : Details }</code></pre>

<p>An entity has a generic list of related entities, and a <code>Details</code> property that holds the actual characteristics of a film or a character. Now that we have a generic entity type, we can simplify the application model:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Model</span> </span>=
    | InitialScreen
    | Loading <span class="hljs-keyword">of</span> Entity
    | List <span class="hljs-keyword">of</span> Entity * Entity list
    | ErrorScreen</code></pre>

<p>And we can parse the json using the function:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">CharacterResponseJson</span> </span>=
    { name : string
      films : string list }

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">FilmResponseJson</span> </span>=
    { title : string
      episode_id : int
      characters : string list }

<span class="hljs-keyword">let</span> <span class="hljs-meta">[&lt;PassGenericsAttribute&gt;]</span> betterOfJson&lt;<span class="hljs-symbol">'a</span>&gt; text =
    <span class="hljs-keyword">try</span>
        <span class="hljs-keyword">let</span> json = ofJson&lt;<span class="hljs-symbol">'a</span>&gt; text
        Some json
    <span class="hljs-keyword">with</span> _ -&gt;
        None

<span class="hljs-keyword">let</span> parse text =
    <span class="hljs-keyword">let</span> chRecord = betterOfJson&lt;CharacterResponseJson&gt; text
    <span class="hljs-keyword">let</span> filmRecord = betterOfJson&lt;FilmResponseJson&gt; text
    <span class="hljs-keyword">match</span> chRecord , filmRecord <span class="hljs-keyword">with</span>
    | Some ch , _ -&gt;
        { related = ch.films
          details = Character ch.name }
    | _ , Some film -&gt;
        { related = film.characters
          details = Film ( film.title , film.episode_id.ToString() ) }
    | _ -&gt;
        failwith <span class="hljs-string">"could not parse entity"</span></code></pre>

<p>Let&#39;s pause a little to understand this function. First, I created the record types to reflect the information I&#39;m looking for in the API&#39;s json schema. Then, I created a function called <code>betterOfJson</code> which is just <code>ofJson</code> returning an <code>option</code>. We have to use the <code>[&lt;PassGenericsAttribute&gt;]</code> so this function works properly when transpiled to Javascript. No need to worry about how it works - the compiler tells you where you need to use it! :)</p>
<p>After that, the parse function is defined. It raises an exception if there&#39;s an error; which, again, I really do not like since it works as a &quot;hidden output&quot;, but we&#39;re going to use it inside a Promise, so it&#39;s not that bad.</p>
<p>In trying to make this function better, I learned another really amazing F# feature: <em>Partial Active Patterns</em>. I wanted to to have this function written somewhat like this:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> parse text =
    <span class="hljs-keyword">match</span> text <span class="hljs-keyword">with</span>
    | IsCharacter ch -&gt; ...
    | IsFilm film -&gt; ...
    | _ -&gt; failwith <span class="hljs-string">"could not parse entity"</span></code></pre>

<p>It turns out that there&#39;s a simple way to achieve that:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> (|IsCharacter|_|) text =
    betterOfJson&lt;CharacterResponseJson&gt; text

<span class="hljs-keyword">let</span> (|IsFilm|_|) text =
    betterOfJson&lt;FilmResponseJson&gt; text</code></pre>

<p>To build a Partial Active Pattern, you have to write a function that returns an <code>option</code>, and has this <code>(|PatternMatchCase|_|)</code> definition. Now you can use both <code>IsCharacter</code> and <code>IsFilm</code> in a pattern match:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> parse text =
    <span class="hljs-keyword">match</span> text <span class="hljs-keyword">with</span>
    | IsCharacter ch -&gt;
        { related = ch.films
          details = Character ch.name }
    | IsFilm film -&gt;
        { related = film.characters
          details = Film ( film.title , film.episode_id.ToString() ) }
    | _ -&gt;
        failwith <span class="hljs-string">"could not parse entity"</span></code></pre>

<p>This is much simpler. This is another feature of F# that makes it stand out.</p>
<p>I&#39;m still not 100% happy with an &quot;exception-throwing&quot; function. If someone knows of a better way to deal with JSON parsing, please let me know in the comment section!</p>
<p>Next, let&#39;s deal with the update part of the application. The messages can be simplified too:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Msg</span></span>
    = Load <span class="hljs-keyword">of</span> Entity
    | ToList <span class="hljs-keyword">of</span> Entity * Entity list
    | FetchFail</code></pre>

<p><code>getFirstCharacter</code> is very similar:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> fetchEntity (url:Url) =
    promise {
        <span class="hljs-keyword">let!</span> fetched = fetch url []
        <span class="hljs-keyword">let!</span> response = fetched.text()
        <span class="hljs-keyword">return</span> parse response }

<span class="hljs-keyword">let</span> getFirstCharacter handler =
    fetchEntity <span class="hljs-string">"http://swapi.co/api/people/2/"</span>
    |&gt; Promise.map Load
    |&gt; Promise.catch ( <span class="hljs-keyword">fun</span> _ -&gt; FetchFail )
    |&gt; Promise.map handler
    |&gt; ignore</code></pre>

<p>And now we only need one <code>getRelatedEntities</code> instead of <code>getCharacters</code> and <code>getFilms</code>:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> getRelatedEntities (entity:Entity) handler =
    List.map fetchEntity entity.related
    |&gt; Promise.Parallel
    |&gt; Promise.map ( <span class="hljs-keyword">fun</span> list -&gt; ToList ( entity , List.ofArray list ) )
    |&gt; Promise.catch ( <span class="hljs-keyword">fun</span> _ -&gt; FetchFail )
    |&gt; Promise.map handler
    |&gt; ignore</code></pre>

<p>And our <code>update</code> function became simpler:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> update model msg =
    <span class="hljs-keyword">match</span> msg <span class="hljs-keyword">with</span>
    | Load entity -&gt; Loading entity , [ getRelatedEntities entity ]
    | ToList ( entity , list ) -&gt; List ( entity , list ) , []
    | FetchFail -&gt; ErrorScreen , []</code></pre>

<p>From this point on, we only need to implement the view functions. This is the final <code>view</code> function (<code>messageView</code> and <code>entityView</code> were ommited for brevity, but <a href="https://github.com/lucasmreis/star-wars-fable/blob/master/src/Main.fsx#L94">can be found here</a>):</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> view model =
    <span class="hljs-keyword">match</span> model <span class="hljs-keyword">with</span>
    | InitialScreen -&gt;
        messageView <span class="hljs-string">"Loading amazing characters and films..."</span>

    | Loading entity -&gt;
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ mappedEntityView entity ; loadingMessageView entity ]

    | List ( entity , list ) -&gt;
        <span class="hljs-keyword">let</span> listView = List.map mappedEntityView list
        div [ Style [ <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ] ]
            [ mappedEntityView entity ; div [] listView ]

    | ErrorScreen -&gt;
        messageView <span class="hljs-string">"An error ocurred. Please refresh the page and try again - and may the Force be with you!"</span></code></pre>

<p>Much better, right? It&#39;s always a pleasure to refactor code using an ML language :)</p>
<h2 id="conclusions">Conclusions</h2>
<p>That&#39;s it - we have a completely refactored working version of the Star Wars app. <a href="https://github.com/lucasmreis/star-wars-fable">The complete code is here</a>, and <a href="https://lucasmreis.github.io/star-wars-fable/">the working app is here</a>.</p>
<p><a href="http://lucasmreis.github.io/blog/does-elm-harmonize-with-f/#final-conclusions">I&#39;ve compared Elm and F# before</a>, and this experiment compares both <em>in the same domain</em>: frontend web programming. Here are some of my thoughts on the outcome:</p>
<ul>
<li>Elm is much friendlier for beginners. It has one way to do almost everything, so there&#39;s not many decisions to make when implementing something - it has more of a &quot;puzzle&quot; feel to it. Also, tools like <a href="http://elm-lang.org/try">Try Elm</a> and <a href="https://github.com/elm-lang/elm-reactor">Elm Reactor</a> make it very simple and fast to begin coding and experimenting with the language.</li>
<li>On the other hand, Fable does not hide from you the fact that it&#39;s going to compile to Javascript, and because of that, you have a lot of freedom. For instance, I could immediately make the requests parallel, because promises work just like they do in JS. There was <a href="http://lucasmreis.github.io/blog/learning-elm-part-3/#almost-finishing-our-application-">no default way to do this</a> when I implemented the same app in Elm.</li>
<li>F#&#39;s <em>computation expressions</em> and <em>partial active patterns</em> are really powerful, and make the code more readable and elegant. Actually, it also makes it <em>simpler</em>. There&#39;s nothing like it in Elm.</li>
<li>F#, when used with the Ionide VS Code plugin, is probably the best coding experience I&#39;ve had to date. Elm comes close (and <code>elm-format</code> is great), but hovering in any variable to understand what it is in realtime is an amazing experience. And the type code lenses are really useful too.</li>
</ul>
<h2 id="next-steps">Next Steps</h2>
<p>I enjoyed the Fable experimentation. I&#39;ll continue to look at it, and probably try something with more JS interop to understand better how it would behave in a more real world scenario.</p>
<p>Elm still seems the sensible solution if you have a team of people that are <em>learning</em> functional programming. Elm has a lighter cognitive load, since there&#39;s almost only one way of doing it, and the defaults are very good, making it a great learning tool as well. </p>
<p>Teams looking for more freedom and power, on the other hand, can find it with Fable, while still maintaining most of the reliability and safety from an ML language.</p>
]]></description>
            <guid isPermaLink="false">From Elm To Fable</guid>
            <pubDate>Sat, 10 Dec 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Learning Elm, part 4]]></title>
            <description><![CDATA[<p>As I said in the conclusion of part 1 of this series, the function I wrote in <a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">that post</a> felt very <em>reliable</em>, in a way that&#39;s difficult to achieve with any javascript code.</p>
<p>As a reminder, here is the card type used in the code:</p>
<pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Value</span> = <span class="hljs-type">Jack</span> | <span class="hljs-type">Queen</span> | <span class="hljs-type">King</span> | <span class="hljs-type">Ace</span> | <span class="hljs-type">Num</span> <span class="hljs-type">Int</span>
<span class="hljs-keyword">type</span> <span class="hljs-type">Suit</span> = <span class="hljs-type">Club</span> | <span class="hljs-type">Diamond</span> | <span class="hljs-type">Spade</span> | <span class="hljs-type">Heart</span>
<span class="hljs-keyword">type</span> <span class="hljs-type">Card</span> = <span class="hljs-type">OrdinaryCard</span> <span class="hljs-type">Value</span> <span class="hljs-type">Suit</span> | <span class="hljs-type">Joker</span></code></pre>

<p>Looking at these types, a question arises: <em>how can I guarantee that I never end up with an invalid card?</em> By invalid card, I mean something like a thirteen of Clubs, or a minus five of Hearts.</p>
<h2 id="unit-testing">Unit Testing</h2>
<p>The &quot;unsafe&quot; part of the type is the type <code>Value</code>. It&#39;s created by the function <code>parseNumValue</code>, which has the type:</p>
<pre><code class="hljs elm"><span class="hljs-title">parseNumValue</span> : <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Value</span></code></pre>

<p>By testing the <code>parseNumValue</code> function, we&#39;ll be able to raise the reliability of the code as a whole.</p>
<p>Unit testing pure functions is very simple: we define some example cases of the function, and then define the expected return values. Let&#39;s use the library <code>elm-test</code> for our tests.</p>
<p>Installing Elm Test is easy, <a href="https://github.com/elm-community/elm-test#running-tests-locally">as described here</a>:</p>
<ol>
<li>Run <code>npm install -g elm-test</code> if you haven&#39;t already.</li>
<li><code>cd</code> into the project&#39;s root directory that has your <code>elm-package.json</code>.</li>
<li>Run <code>elm-test init</code>. It will create a <code>tests</code> directory inside this one, with some files in it.</li>
<li>Copy all the dependencies from <code>elm-package.json</code> into
<code>tests/elm-package.json</code>. These dependencies need to stay in sync, so make sure whenever you change your dependencies in your current
<code>elm-package.json</code>, you make the same change to <code>tests/elm-package.json</code>.</li>
<li>Run <code>elm-test</code>.</li>
<li>Edit <code>tests/Tests.elm</code> to introduce new tests.</li>
</ol>
<p>After writing the unit tests, this is how my <code>Tests.elm</code> file looks:</p>
<pre><code class="hljs elm"><span class="hljs-keyword">module</span> Tests <span class="hljs-keyword">exposing</span> (..)

<span class="hljs-keyword">import</span> Test <span class="hljs-keyword">exposing</span> (..)
<span class="hljs-keyword">import</span> Expect
<span class="hljs-keyword">import</span> Cards <span class="hljs-keyword">exposing</span> (..)


<span class="hljs-title">all</span> : <span class="hljs-type">Test</span>
<span class="hljs-title">all</span> =
    describe <span class="hljs-string">"parseNumValue"</span>
        [ test <span class="hljs-string">"cannot be less than 2"</span>
            &lt;| \() -&gt; <span class="hljs-type">Expect</span>.equal (parseNumValue <span class="hljs-string">"1"</span>) <span class="hljs-type">Nothing</span>
        , test <span class="hljs-string">"minimum of 2"</span>
            &lt;| \() -&gt; <span class="hljs-type">Expect</span>.equal (parseNumValue <span class="hljs-string">"2"</span>) (<span class="hljs-type">Just</span> (<span class="hljs-type">Num</span> <span class="hljs-number">2</span>))
        , test <span class="hljs-string">"maximum of 10"</span>
            &lt;| \() -&gt; <span class="hljs-type">Expect</span>.equal (parseNumValue <span class="hljs-string">"10"</span>) (<span class="hljs-type">Just</span> (<span class="hljs-type">Num</span> <span class="hljs-number">10</span>))
        , test <span class="hljs-string">"cannot be more than 10"</span>
            &lt;| \() -&gt; <span class="hljs-type">Expect</span>.equal (parseNumValue <span class="hljs-string">"11"</span>) <span class="hljs-type">Nothing</span>
        ]</code></pre>

<p>The syntax is direct: you describe a test suite, and then define the tests inside a list. I tested the &quot;corner cases&quot; of the function, to make sure that any value less than 2 or greater than 10 will not be parsed to a Card. I also like that tests in general also work as documentation to show how the function is supposed to behave.</p>
<p>So, unit tests raise reliability, but could they do better? What would happen if we call the <code>parseNumValue</code> function with the string &quot;100&quot;? Or the string &quot;-22&quot;? Is it possible to write more general tests, that answer the more powerful question <em>can I guarantee that only integers between 2 and 10 get converted to a Value, and no others</em>?</p>
<h2 id="property-based-testing">Property Based Testing</h2>
<p>Property Based Testing is very interesting because it allows you to test a whole set of values. For instance, let&#39;s pretend that we have at our disposal the set of all integers. If we transform them into strings, we have the perfect inputs for testing <code>parseNumValue</code>.</p>
<p>Elm Test has an easy way of doing property based tests. Instead of using the <code>test</code> function, you will use <code>fuzz</code> function, specify a &quot;fuzzer&quot;, and write your test using the generated value as a parameter:</p>
<pre><code class="hljs elm">(...)

<span class="hljs-keyword">import</span> Fuzz <span class="hljs-keyword">exposing</span> (..)

(...)

, fuzz int <span class="hljs-string">"parseNumValue"</span>
    &lt;| \number -&gt;
        <span class="hljs-keyword">let</span>
            parsed =
                number
                    |&gt; toString
                    |&gt; parseNumValue
        <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">case</span> parsed <span class="hljs-keyword">of</span>
                <span class="hljs-type">Just</span> (<span class="hljs-type">Num</span> v) -&gt;
                    <span class="hljs-type">Expect</span>.true
                        <span class="hljs-string">"Number should be &gt;= 2 and &lt;= 10 when Just Num v"</span>
                        (v &gt;= <span class="hljs-number">2</span> &amp;&amp; v &lt;= <span class="hljs-number">10</span>)

                _ -&gt;
                    <span class="hljs-type">Expect</span>.false
                        <span class="hljs-string">"Number should not be &gt;= 2 and &lt;= 10 when Nothing"</span>
                        (number &gt;= <span class="hljs-number">2</span> &amp;&amp; number &lt;= <span class="hljs-number">10</span>)</code></pre>

<p>This test is direct: it generates an <code>int</code> and passes it as a parameter to the testing function - that&#39;s why we&#39;re using <code>\number -&gt; ...</code>. Then we convert the number to a string and parse it with our <code>parseNumValue</code> function.</p>
<p>We are testing for the following: if the result of the parse is a <code>Just (Num v)</code>, then the number was something between two and ten. And, if the result is <code>Nothing</code>, the number was either smaller than 2 or greater than 10.  That is what we are asserting in the pattern matching section of the test.</p>
<p>How does it work? It&#39;s simple: <code>fuzz int</code> generates a bunch of random integers, and runs a test for each integer generated. That way, it&#39;s almost the same as writing a lot of <code>test</code> functions for a lot of integer values.</p>
<p><em>Observation</em>: during these tests, I found a little problem: the key values of 1, 2, 10 and 11 were <em>not</em> tested every time. That means I could have a false positive! The fuzz test would say everything is ok, but my function could have an error and I would end up with a <code>Just (Num 11)</code>. The solution to this could be raising the number of random integers tested, but I could not find a way to do it. If you have an idea of how to deal with this situation, please comment below it in the comments section!</p>
<p>In the end, I maintained the four unit tests that I knew were important cases, and added the fuzz test. <a href="https://github.com/lucasmreis/learning-elm/blob/master/part-4/tests/Tests.elm">Here&#39;s how the final test file looks</a>.</p>
<p>I believe the solution feels much more reliable with the addition of the property based tests. But one thing still bothers me: the fact that, if I do not use the parsers to build a card, I can still have an invalid card like <code>Just (Num 11)</code>.</p>
<h2 id="can-we-do-better-">Can We Do Better?</h2>
<p>Our cards have a small finite domain. Instead of having a <code>Num Int</code> case for the <code>Value</code> type, we could be explicit about every value possible:</p>
<pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Value</span>
    = <span class="hljs-type">Jack</span>
    | <span class="hljs-type">Queen</span>
    | <span class="hljs-type">King</span>
    | <span class="hljs-type">Ace</span>
    | <span class="hljs-type">Two</span>
    | <span class="hljs-type">Three</span>
    | <span class="hljs-type">Four</span>
    | <span class="hljs-type">Five</span>
    | <span class="hljs-type">Six</span>
    | <span class="hljs-type">Seven</span>
    | <span class="hljs-type">Eight</span>
    | <span class="hljs-type">Nine</span>
    | <span class="hljs-type">Ten</span>


<span class="hljs-keyword">type</span> <span class="hljs-type">Suit</span>
    = <span class="hljs-type">Club</span>
    | <span class="hljs-type">Diamond</span>
    | <span class="hljs-type">Spade</span>
    | <span class="hljs-type">Heart</span>


<span class="hljs-keyword">type</span> <span class="hljs-type">Card</span>
    = <span class="hljs-type">OrdinaryCard</span> <span class="hljs-type">Value</span> <span class="hljs-type">Suit</span>
    | <span class="hljs-type">Joker</span></code></pre>

<p>This modelling is very simple and direct, but it&#39;s also <em>powerful</em>. It is literally impossible to represent an invalid card. This is what <a href="https://vimeo.com/14313378">Yaron Minsky</a>, <a href="https://vimeo.com/162036084">Mark Seemann</a>, <a href="http://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/">Scott Wlaschin</a> and <a href="https://www.youtube.com/watch?v=IcgmSRJHu_8">Richard Feldman</a> mean when they say &quot;make illegal states unrepresentable&quot;. All these talks are amazing, and illustrate very well the benefits of having types that simply do not allow invalid models to be represented, and also cover techniques to achieve that.</p>
<p>And now we have a much more robust set of functions to parse and &quot;pretty print&quot; cards. (<a href="https://github.com/lucasmreis/learning-elm/blob/master/part-4/src/SafeCards.elm">The whole final code with the new types is here</a>).</p>
<h2 id="is-it-always-a-possibility-">Is It Always A Possibility?</h2>
<p>I tend to think that we were kind of &quot;lucky&quot; here, in the sense that a normal deck of cards has about nine numbered cards only. It&#39;s easier to enumerate every case in that sense, but I do not know if it would be practical to do that if the numbered cards were in the 2 - 100 range, for example.</p>
<p>I think that the simple way of dealing with it is to always first try to have all your modeling constraints through types. For example, imagine that the only way to have a user name is through logging in. That means that instead of:</p>
<pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">User</span> =
    { isLogged : <span class="hljs-type">Bool</span>
    , name : <span class="hljs-type">String</span>
    }</code></pre>

<p>You should have:</p>
<pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">User</span>
    = <span class="hljs-type">NotLogged</span>
    | <span class="hljs-type">Logged</span> <span class="hljs-type">String</span></code></pre>

<p>With the second modeling, you never have the risk of having a NotLogged user with a name. That means you <em>don&#39;t need a test to assure that a constructed user is invalid</em>. This is what I mean by powerful! :)</p>
<p>And what do I do if I can&#39;t model my domain that way? For example, what do I do if I have a deck of cards with numbered cards ranging from 2 to 1000? In this case, I think that testing your constructors with property based tests is the way to go.</p>
<p><em>Observation</em>: even when your typings make illegal states unrepresentable, unit and property based tests are still useful when testing <em>state transitions</em>. In our User example, it&#39;s useful to test if &quot;logging out function results in a NotLogged User&quot;. So, even though good type modeling lowers the need for tests, <em>tests are still useful for making your code reliable</em>.</p>
<p>One last remark: we could represent our 1000 card deck using only types if we could have a &quot;bounded integer&quot; type, such as, &quot;this is an integer larger than X and smaller than Y&quot;. This would be a type that is <em>dependent on values</em>, and it&#39;s not possible to do in Elm. Actually, it seems it&#39;s not possible to do in any mainstream language. :(</p>
<p><a href="http://stackoverflow.com/questions/9338709/what-is-dependent-typing">This stack overflow question</a> explains dependent typing very directly, and <a href="https://en.wikipedia.org/wiki/Dependent_type">here&#39;s a list of languages with dependent typing</a> so we can research more about it. <a href="http://www.idris-lang.org/example/">Idris</a> looks particularly nice!</p>
]]></description>
            <guid isPermaLink="false">Learning Elm, part 4</guid>
            <pubDate>Wed, 02 Nov 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Does Elm Harmonize With F#?]]></title>
            <description><![CDATA[<p>After <a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">experimenting with Elm</a>, I was hooked. I could feel that working with a smart type system brought both <em>reliability</em>, in the sense of &quot;it does what I want it to do&quot;, and <em>safety</em>, in the sense of &quot;it does not have bugs&quot;.</p>
<p>Elm&#39;s main focus is the front end (<a href="https://github.com/ElmCast/elm-node">even though</a> <a href="https://github.com/Fresheyeball/elm-http-server">some work</a> <a href="https://github.com/eeue56/servelm">is being done</a>), so a natural next question could be <em>What would using an Elm-like language in the server be like</em>? And by &quot;Elm-like&quot; I mean a language with immutable data structures as default, encouraging expressions over statements, and of course, having those cool discriminated unions we all learned to love. :)</p>
<p>After doing some quick research, my finalists were Haskell, Ocaml and F#. A former coworker was always saying good things about F#, and after seeing things like <a href="http://fsharp.github.io/FSharp.Data/">FSharp.Data</a>, <a href="https://developer.xamarin.com/guides/cross-platform/fsharp/fsharp_support_overview/">Xamarin</a> and <a href="https://fsharpforfunandprofit.com/">this amazing blog</a>, I decided to go with F#.</p>
<h2 id="setting-up">Setting Up</h2>
<p>The first week with F# was not easy. I was a little clueless about where to get started since I don&#39;t have a Windows machine. So, I downloaded Xamarin Studio, and used it for a couple of days. It&#39;s a good IDE with a so so editor, so I started looking for some alternatives.</p>
<p>Every F# project needs a <code>*.fsproj</code> config file, which is a big messy XML that is not meant to be changed by &quot;human beings&quot; (as opposed to the simpler <code>package.json</code> from Node or <code>elm-package.json</code> from Elm). But it turns out that the F# open source community has built some nice tools to deal with it. Summing up, install the <a href="http://ionide.io/">Ionide</a> extension to VS Code or Atom, and everything will be easier.</p>
<p>My programming workflow then became: start coding something, and &quot;send&quot; the code little by little to the REPL. Define some types, send to the REPL. Write a function, send to the REPL. Write some use cases, send to the REPL. It&#39;s the exact same workflow I used with Clojure, and it leads to a lot of early feedback and agility from the very beginning.</p>
<p>With F# up and running, I decided to implement a simple project to learn the language.</p>
<h2 id="the-project">The Project</h2>
<p>My wife was a girl scout when she was a kid. She told me about a common girl scout activity in the US, which is selling cookies door to door to raise money for their girl scout activities. I found that was a cool tradition, so I decided to implement a girl scout cookie selling dashboard! :)</p>
<p>The requirements are: each scout somehow send commands like &quot;Visit House&quot; or &quot;Sell 5 Cookies&quot; to the server. The server validates the command, and broadcast events like &quot;Maggie Just Visited A House&quot; or &quot;Lisa Just Sold 5 Cookies&quot; to the dashboards, that are updated in realtime and consolidate all the information.</p>
<h2 id="the-domain-model">The Domain Model</h2>
<p>Each scout can be modelled as a &quot;state machine&quot;. This is where these type systems really shine. F#, like Elm, has union types and pattern matching, so the code was pretty similar. For instance:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">ScoutState</span> </span>=
    | Walking
    | Visiting
    | HavingFun

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">ScoutCommand</span> </span>=
    | StartDay
    | VisitHouse
    | Sell <span class="hljs-keyword">of</span> int
    | HaveFun

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">ScoutEvent</span> </span>=
    | DayStarted
    | HouseVisited
    | Sold <span class="hljs-keyword">of</span> int
    | DayFinished

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">ScoutError</span> </span>=
    | ShouldBeHavingFun
    | ShouldBeWalking
    | ShouldBeVisiting</code></pre>

<p>A word about Commands and Events: when programming in Elm, &quot;everything&quot; that happened in the application was called a Message. The Update function understands the Messages, updates the state accordingly, and then emits or not new Messages.</p>
<p>When reading about F#, I came across lots of reading materials on Domain Driven Design (DDD), Event Sourcing and Command Query Responsibility Segregation (CQRS). One of the nice ideas I&#39;ve read is the <em>separation between Commands and Events</em> among the Messages.</p>
<p>Every time a user wants to change the domain, it issues a Command. If the Command actually changes the domain, an Event is generated. An Event represents things that actually happened to the domain. For example, if a scout issues a Command <code>Sell 3</code>, the server checks if it&#39;s a valid Command for the actual State, and if it&#39;s ok it issues an Event <code>Sold 3</code>. If it&#39;s not valid, let&#39;s say the scout was not visiting any house, it returns a <code>ShouldBeVisiting</code> error, and the State is not updated.</p>
<p>The cool part is that we can store all the Events, and query them at will. The present State is a replay of all the past Events! That&#39;s what Event Sourcing is all about, and I really recommend watching <a href="https://www.youtube.com/watch?v=8JKjvY4etTY">every video you can</a> <a href="https://www.youtube.com/watch?v=kZL41SMXWdM">from Greg Young</a>, <a href="https://www.youtube.com/watch?v=LDW0QWie21s">the &quot;father&quot; of the Event Sourcing pattern</a>.</p>
<p>With that in mind, this is the final state machine representation of the scouts:</p>
<p><img src="../assets/scouts-model.png" alt="Scout&#39;s Model"></p>
<p><a href="https://github.com/lucasmreis/AmazingCookies/blob/master/src/Domain/Domain.fs">The final code for the domain is here</a>.</p>
<h2 id="a-simple-event-store">A Simple Event Store</h2>
<p>The events produced by the server need to be stored somewhere. To continue the learning experience, I decided to implement the simplest in-memory event store I could think of. It should be able to store every event, broadcast them to listeners, and that&#39;s it.</p>
<p>Since the store actually stores data, and this data is accessed through methods, I thought that modelling the store as an <em>object</em> would be ok. Yes, it&#39;s the kind of object that we try to escape with functional programming, but it still has it uses :)</p>
<p>It was also good to see that &quot;object oriented programming&quot; with F# is very simple, and has almost no boilerplate. You just declare a type with <code>()</code> near the name, and declare &quot;members&quot; of the type. For instance:</p>
<pre><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">EventStore</span></span>() =
    <span class="hljs-keyword">let</span> eventList =
        <span class="hljs-keyword">new</span> ResizeArray&lt;String * ScoutEvent&gt;()

    <span class="hljs-keyword">member</span> this.Save(name, events) =
        events |&gt; List.iter (<span class="hljs-keyword">fun</span> e -&gt; eventList.Add(name, e))

    <span class="hljs-keyword">member</span> this.Get() =
        eventList</code></pre>

<p>When instanced with <code>let store = new EventStore()</code>, this object creates an array of <code>String * ScoutEvent</code> tuples. This will hold all the events produced by the application, together with the scout&#39;s name that produced the event.</p>
<p>F# has a very interesting feature called <em>computation expressions</em>. <a href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions">The docs</a> describe it as <em>a convenient syntax for writing computations that can be sequenced and combined using control flow constructs and bindings</em>. I do not know of an easier way to describe it, so let me show two examples, <code>async</code> and <code>seq</code>:</p>
<pre><code class="hljs fsharp"><span class="hljs-comment">// First example</span>

<span class="hljs-comment">// this works just like Javascript's async/await,</span>
<span class="hljs-comment">// or Clojure's core.async</span>
<span class="hljs-keyword">let</span> asyncFetchedDocument = async {
    <span class="hljs-keyword">let</span> url = <span class="hljs-string">"http://some-url.com/api"</span>

    <span class="hljs-comment">// this line will wait for the response without blocking the thread</span>
    <span class="hljs-keyword">let!</span> res = someAsyncFetchFunction url

    <span class="hljs-keyword">return</span> res.data }

<span class="hljs-keyword">let</span> fetchedDocument =
    Async.RunSynchronously asyncFetchedDocument


<span class="hljs-comment">// Second example</span>

<span class="hljs-comment">// this produces a lazy sequence</span>
<span class="hljs-keyword">let</span> lazySeq = seq {
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> .. <span class="hljs-number">5</span> <span class="hljs-keyword">do</span>
      <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>
        <span class="hljs-keyword">yield</span> i
        <span class="hljs-keyword">yield</span> -i }

<span class="hljs-keyword">let</span> list =
    Seq.toList lazySeq
<span class="hljs-comment">// =&gt; [2; -2; 4; -4]</span></code></pre>

<p>In the event store I wrote, I used a <code>query</code> computation expression to get all the events from a given name in the EventStore:</p>
<pre><code class="hljs fsharp">...

<span class="hljs-keyword">member</span> this.Get(name) =
    query {
        <span class="hljs-keyword">for</span> (n, ev) <span class="hljs-keyword">in</span> eventList <span class="hljs-keyword">do</span>
        where (n = name)
        select ev
    } |&gt; Seq.toList

...</code></pre>

<p>That&#39;s really cool, right? It feels like a strongly typed SQL :) I feel that Elm would strongly benefit from something like this.</p>
<p>So, to finish the EventStore, I needed a pub/sub to the saved events:</p>
<pre><code class="hljs fsharp">...

  <span class="hljs-keyword">let</span> saveEvent =
      <span class="hljs-keyword">new</span> Event&lt;'Key * 'Event&gt;()

  <span class="hljs-keyword">member</span> this.SaveEvent =
      saveEvent.Publish

  <span class="hljs-keyword">member</span> this.Save(name, events) =
      events |&gt; List.iter (<span class="hljs-keyword">fun</span> e -&gt; eventList.Add(name, e))
      events |&gt; List.iter (<span class="hljs-keyword">fun</span> e -&gt; saveEvent.Trigger((name, e)))

...</code></pre>

<p>The events are published at <code>SaveEvent</code>, and saving an event triggers the listeners. An example subscription would be:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> logger ev = printfn <span class="hljs-string">"-- EVENT: %A"</span> ev

store.SaveEvent.Add(logger)</code></pre>

<p><a href="https://github.com/lucasmreis/AmazingCookies/blob/master/src/EventStore/EventStore.fs">The complete EventStore, with generic typing, is here</a>.</p>
<h2 id="a-server">A Server</h2>
<p>Years ago I worked with C#, and wrote a server with ASP.NET MVC. In this project, I thought I was going to write the server using F#/C# &quot;interop&quot; (and I was not very happy about it :) ). Fortunately, I came across an &quot;F# native&quot; web server framework called <a href="https://suave.io/">Suave</a>. Suave in Portuguese means <em>smooth</em>, and that&#39;s exactly how it feels to write a server with this framework!</p>
<p>For instance, look at the final code for the server:</p>
<pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> app store =
    choose [
        path <span class="hljs-string">"/"</span>          &gt;=&gt; Files.sendFile <span class="hljs-string">"build/index.html"</span> <span class="hljs-keyword">true</span>
        path <span class="hljs-string">"/dashboard"</span> &gt;=&gt; Files.sendFile <span class="hljs-string">"build/dashboard.html"</span> <span class="hljs-keyword">true</span>
        path <span class="hljs-string">"/websocket"</span> &gt;=&gt; handShake (eventSocket store)
        path <span class="hljs-string">"/command"</span>   &gt;=&gt; POST &gt;=&gt; request(commandRequest store)
        ServerErrors.INTERNAL_ERROR <span class="hljs-string">"Sorry, route not valid!"</span> ]</code></pre>

<p>Really clear, right? Writing this server was very easy. The routes are defined through function composition, and Suave comes with some functions that define standard server behaviors, like <code>Filters.POST</code>, <code>Files.sendFile</code> and <code>ServerErrors.INTERNAL_ERROR</code>.</p>
<p>I found one problem while trying to make it work: <em>there&#39;s simply no documentation on working with websockets</em>. After googling it, the material I found was from a couple of StackOverflow questions, and <a href="https://github.com/SuaveIO/suave/blob/master/examples/WebSocket/Program.fs">this example from the project&#39;s github</a>.</p>
<p>It took some time, but, after a few hours, I was able to make it work. This is part of the final code for the socket code:</p>
<pre><code class="hljs fsharp">...

socket {
    <span class="hljs-keyword">let</span> loop = ref <span class="hljs-keyword">true</span>
    <span class="hljs-keyword">while</span> !loop <span class="hljs-keyword">do</span>
        <span class="hljs-keyword">let!</span> msg = webSocket.read()
        <span class="hljs-keyword">match</span> msg <span class="hljs-keyword">with</span>
        | (Ping, _, _) -&gt; <span class="hljs-keyword">do!</span> webSocket.send Pong [||] <span class="hljs-keyword">true</span>
        | (Close, _, _) -&gt;
            <span class="hljs-keyword">do!</span> webSocket.send Close [||] <span class="hljs-keyword">true</span>
            subscription.Dispose()
            loop := <span class="hljs-keyword">false</span>
        | _ -&gt; ()
    }</code></pre>

<p>It&#39;s a computation expression! Gotta love those.</p>
<p><a href="https://github.com/lucasmreis/AmazingCookies/tree/master/src/Server">The complete code for the server can be found here</a>.</p>
<h2 id="an-elm-dashboard">An Elm dashboard</h2>
<p>After implementing F#, it was time to return to Elm. The dashboard architecture was simple: the app listens for events through the native websockets implementation, and it drives the standard Elm architecture. This is what the final result looks like (notice I&#39;m using Postman to send the scout&#39;s commands to the server):</p>
<p><img src="../assets/event-source-a.gif" alt="Event Source A">
<img src="../assets/event-source-b.gif" alt="Event Source B"></p>
<p>One of the best parts of Elm is that the structure of the code does not seem to change from application to application. The &quot;framework&quot; is so close to the language itself, that one simply does not try to do things differently - I&#39;m not even sure it&#39;s possible. Because of that, we can focus more on the real complexity of the problem, and think less and less about implementation details.</p>
<p>The only different part from my <a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">earlier</a> <a href="http://lucasmreis.github.io/blog/learning-elm-part-2/">learning Elm</a> <a href="http://lucasmreis.github.io/blog/learning-elm-part-3/">series</a> is the websockets part. But it&#39;s really, really simple:</p>
<pre><code class="hljs"><span class="hljs-symbol">type</span> Msg
    = EventReceived <span class="hljs-keyword">String
</span>
<span class="hljs-keyword">subscriptions </span>: Model -&gt; <span class="hljs-keyword">Sub </span>Msg
<span class="hljs-keyword">subscriptions </span>model =
    WebSocket.listen scoutEventsServer EventReceived</code></pre>

<p>And now I only have to treat <code>EventReceived</code> messages in the <code>update</code> function.</p>
<p>Something I did not like: I felt like I had to repeat a lot of the code in the client and the server, mostly in the models. Mismatches between client and server models are a huge source of errors. Although I don&#39;t think it would happen here - after all, they are in the same project :) - I would have to update two pieces of code each time the model needed to change.</p>
<p><a href="https://github.com/lucasmreis/AmazingCookies/blob/master/src/Client/app/Dashboard.elm">The complete code for the dashboard is here</a>.</p>
<h2 id="final-conclusions">Final Conclusions</h2>
<p>In the end, I really enjoyed the experiment. Even though the languages appear similar, I could see a lot of differences between the two, mostly due to Elm being a language looking for reliability in a narrow scope, and F# looking for pragmatism in a much larger scope.</p>
<h3 id="ways-elm-is-superior-to-f">Ways Elm Is Superior To F</h3>
<ul>
<li><p><em>&quot;Only one way to code&quot;, and it&#39;s very well thought out.</em> After grasping the Elm architecture, I am able to concentrate more each time on the complexities of the problems themselves and less about incidental implementation complexities.</p>
</li>
<li><p><em>Elm is safer.</em> Elm&#39;s limitations to immutable data and pure functions make everything safer in general. It&#39;s difficult to think of a runtime error happening in an Elm app.</p>
</li>
<li><p><em>Elm-format diminishes the cognitive load</em>. Auto formatting is much more powerful than I thought it would be! It&#39;s one more tool that let&#39;s you focus on the important problems. If you spend some time using auto formatting with Elm and then go back to any other language without a formatter, you&#39;ll understand how much we gain when we are not thinking about code formatting.</p>
</li>
<li><p><em>Better type signature syntax</em>. When one needs to write a function type signature, nothing beats Elm&#39;s (and for that matter Haskell&#39;s) signatures. I like stating the types on a different line from the function itself, and I even use it as comments in some of my Javascript code, the way <a href="http://ramdajs.com/0.22.1/docs/#repeat">RamdaJS uses it in its docs</a>.</p>
</li>
</ul>
<h3 id="ways-f-is-superior-to-elm">Ways F# Is Superior To Elm</h3>
<ul>
<li><p><em>F# is not focused in a single problem</em>. This means you can use F# in almost any software domain, from web servers to web clients, from mobile apps to data science silos. So, knowledge gained in one domain, is knowledge brought to another.</p>
</li>
<li><p><em>F# is very pragmatic</em>. If you want to deal with async problems, you can choose from native implementations of goroutines, actors or observables. You can tackle a problem using many different paradigms, and you have the whole .NET ecosystem at you disposal. In this sense, it feels as pragmatic as Clojure to me, and that tends to help most of the time.</p>
</li>
<li><p><em>Type inferring</em>. It just works, sometimes it feels like magic, and almost never gets in your way. Just start writing the function, and the compiler starts helping you. <em>Obs:</em> I found that a very good type inferring has one drawback: reading code on a web page. When you read code in an editor, you can always hover your mouse and it gives you information, but when the tool is not there to help you, code can be a little to obscure to understand. That&#39;s not good when you are trying to understand a complicated piece of code on github.</p>
</li>
<li><p><em>Tooling / compiler gives you a lot of information during development</em>. Elm&#39;s error messages are a gem. They are amazingly helpful, but I feel that F#&#39;s compiler helps you <em>more</em> during development. You can basically hover your mouse over anything in your code and you get information about it.</p>
</li>
<li><p><em>Computation Expressions</em>. As I said before, it&#39;s a really simple and unified way of writing code that result in more complex behaviors.</p>
</li>
</ul>
<h2 id="things-i-learned-in-the-process">Things I Learned In The Process</h2>
<p>I learned some valuable lessons working on this project. First of all, on the language level, I learned a lot about how to use types better. ML-style languages make it easier to use types to actively make your code more reliable. I recommend reading <a href="http://blog.ploeh.dk/2016/02/10/types-properties-software/">this blog post series</a> as a masterclass in &quot;making illegal states unrepresentable&quot;. It&#39;s a very powerful and simple idea that consists of using the type system as way to maintain the application in a valid state 100% of the time. Another way of phrasing it is <a href="https://twitter.com/splodingsocks/status/776523774183301120">&quot;testing is good, but impossible is better&quot;</a> :)</p>
<p>And second, in the architecture level, I learned about Event Sourcing and CQRS. Today, I really believe that <em>using event logs as first class citizens is the way to go in most situations</em>. Even in this small project, I could feel the benefits: whenever I was coming up with a new way of visualizing the scouts information in the dashboard, I never had to change any schema, or any code in the backend. &quot;Read models&quot; are only different queries in the stored events.</p>
<p>I feel that in a lot of companies, our main storage consists of &quot;last states of a bunch of view models&quot;, and we spend a lot of money on different analytics, and log-managing tools to deal with the really important business questions. If these companies already stored events, and treated them as they treat their main data, an immense value would be generated at a much lower cost.</p>
<h2 id="next-steps">Next Steps</h2>
<p>The repeated code between client and server made me curious about trying something more &quot;unified&quot;, so I&#39;ll try some <a href="https://fable-compiler.github.io/">Fable</a> for frontend programming.</p>
<p>Also, I&#39;ll also try to use more Event Sourcing whenever I can :)</p>
]]></description>
            <guid isPermaLink="false">Does Elm Harmonize With F#?</guid>
            <pubDate>Fri, 09 Sep 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Learning Elm, part 3]]></title>
            <description><![CDATA[<p><em>This is part 3 of a series:</em></p>
<ul>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-2/">Part 1: Understanding The Benefits Of A Simple Architecture</a></li>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">Part 2: Understanding The Benefits Of A Strong Type System</a></li>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-4/">Part 4: Property Based Testing And Better Modelling</a></li>
</ul>
<p><em>Obs: the code in this post is not compatible with Elm version 0.18 on. I&#39;m planning on updating it soon!</em></p>
<p>It&#39;s time for some interaction with APIs! <em>Now</em> we can say that we&#39;re building an actual web application, and we&#39;ll really be putting Elm to the test.</p>
<p>So, why not implement a Star Wars themed app?</p>
<h2 id="spec">Spec</h2>
<p>The spec is simple: a Star Wars character &quot;card&quot; appears on the left, and corresponding film &quot;cards&quot;, representing the films of the character, are shown on the right.</p>
<p>Clicking on a film &quot;card&quot; displays it on the left, and a list of the characters that appear in the film are shown on the right. And it goes on.</p>
<p><img src="../assets/swspec.jpg" alt="Characters And Films"></p>
<p><em>Characters cards will be yellow, and film cards will be blue. By clicking on a card, it changes from one screen to the other.</em></p>
<h2 id="film-and-character-components">Film And Character Components</h2>
<p>I&#39;ll build both the Character and Film components in separate files. This is the initial implementation:</p>
<pre><code class="hljs">-- Character<span class="hljs-selector-class">.elm</span>

type alias Model =
    { name : String
    }


view model =
    <span class="hljs-selector-tag">div</span> [ mainStyle ]
        [ <span class="hljs-selector-tag">div</span> [ nameStyle ] [ text model<span class="hljs-selector-class">.name</span> ] ]

-- imports and styles omitted <span class="hljs-keyword">for</span> brevity...</code></pre>

<pre><code class="hljs">-- Film<span class="hljs-selector-class">.elm</span>

type alias Model =
    { title : String
    , episode_id : Int
    }


view model =
    let
        chapter =
            toString model<span class="hljs-selector-class">.episode_id</span>
    <span class="hljs-keyword">in</span>
        <span class="hljs-selector-tag">div</span> [ mainStyle ]
            [ <span class="hljs-selector-tag">div</span> [ numberStyle ]
                [ text chapter ]
            , <span class="hljs-selector-tag">div</span> [ nameStyle ]
                [ text model<span class="hljs-selector-class">.title</span> ]
            ]</code></pre>

<p>If these examples do not feel straightforward to you, refer back to <a href="http://lucasmreis.github.io/blog/learning-elm-part-2/">Part 2</a>.</p>
<p>To preview the views and fine tune the CSS, I&#39;ll create the <code>Main.elm</code> file and run Elm Reactor pointing to it:</p>
<pre><code class="hljs">main =
    Html<span class="hljs-selector-class">.App</span><span class="hljs-selector-class">.beginnerProgram</span>
        { model = model
        , view = view
        , update = update
        }


update model =
    model


sampleCh : Character<span class="hljs-selector-class">.Model</span>
sampleCh =
    { name = <span class="hljs-string">"Luke Skywalker"</span>
    }


sampleFilm : Film<span class="hljs-selector-class">.Model</span>
sampleFilm =
    { title = <span class="hljs-string">"A New Hope"</span>
    , episode_id = <span class="hljs-number">4</span>
    }


model =
    ( sampleCh, sampleFilm )


view ( ch, film ) =
    <span class="hljs-selector-tag">div</span> []
        [ Character<span class="hljs-selector-class">.view</span> ch
        , Film<span class="hljs-selector-class">.view</span> film
        ]</code></pre>

<p>That should render a sample component of each. Now it&#39;s time to start modeling our application.</p>
<p><img src="../assets/swsample.png" alt="Sample Character And Film"></p>
<h2 id="the-application-model">The Application Model</h2>
<p>Our spec specifies two &quot;application states&quot;: a character with a list of films, or a film with a list of characters. A natural model for this spec would be:</p>
<pre><code class="hljs"><span class="hljs-comment">-- MODEL</span>
<span class="hljs-comment">-- Aliases added for reading simplicity</span>


<span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">C</span> =
    <span class="hljs-type">Character</span>.<span class="hljs-type">Model</span>


<span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">F</span> =
    <span class="hljs-type">Film</span>.<span class="hljs-type">Model</span>


<span class="hljs-keyword">type</span> <span class="hljs-type">Model</span>
    = <span class="hljs-type">FilmsFromCharacter</span> <span class="hljs-type">C</span> (<span class="hljs-type">List</span> <span class="hljs-type">F</span>)
    | <span class="hljs-type">CharactersFromFilm</span> <span class="hljs-type">F</span> (<span class="hljs-type">List</span> <span class="hljs-type">C</span>)</code></pre>
To build the view, I will once again define a sample model:

<pre><code class="hljs"><span class="hljs-attr">model </span>=<span class="hljs-string">
    FilmsFromCharacter sampleCh
        [ sampleFilm
        , sampleFilm
        , sampleFilm
        ]</span></code></pre>

<p>And then, I&#39;ll use it to define the view, while refreshing Elm Reactor:</p>
<pre><code class="hljs">view model =
    case model of
        FilmsFromCharacter c fs -&gt;
            <span class="hljs-selector-tag">div</span> [ twoColumns ]
                [ Character<span class="hljs-selector-class">.view</span> c
                , <span class="hljs-selector-tag">div</span> [] (List<span class="hljs-selector-class">.map</span> Film<span class="hljs-selector-class">.view</span> fs)
                ]

        CharactersFromFilm f cs -&gt;
            <span class="hljs-selector-tag">div</span> [ twoColumns ]
                [ Film<span class="hljs-selector-class">.view</span> f
                , <span class="hljs-selector-tag">div</span> [] (List<span class="hljs-selector-class">.map</span> Character<span class="hljs-selector-class">.view</span> cs)
                ]


twoColumns =
    style [ ( <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> ) ]</code></pre>

<p>Just change the sample and it works very well!</p>
<p>So, as a next step, I want to make the application retrieve actual information from the API. This is where things are different from <a href="http://lucasmreis.github.io/blog/learning-elm-part-2/">part 2</a>, because now our update function not only deals with the model, it also deals with <em>Commands</em>.</p>
<h2 id="the-command">The Command</h2>
<p>Because this scenario is much more complex, instead of using the  <code>beginnerProgram</code> , we&#39;ll use the <code>program</code> function. It&#39;s a little different:</p>
<pre><code class="hljs">main =
    Html<span class="hljs-selector-class">.App</span><span class="hljs-selector-class">.program</span>
        { init = ( model, Cmd<span class="hljs-selector-class">.none</span> )
        , view = view
        , update = update
        , subscriptions = subscriptions
        }

-- (...)

update msg model =
    ( model, Cmd<span class="hljs-selector-class">.none</span> )

-- (...)

subscriptions x =
    Sub.<span class="hljs-attribute">none</span></code></pre>

<p>So, now instead of only a model, we have <code>init</code>. It is a tuple with a model to be rendered immediately and a command that will fire the update function in the future. Another thing to point out is that the update function also returns this same combination.  Subscriptions are listeners that can also fire the update function.</p>
<p>Our next step is to build     <code>init</code>.  First, the app needs to get an initial character from the API and render it on the screen. Then, it has to render the films corresponding to that character. The http request will be the command, and I need an application state to wait for the request to complete.</p>
<p><em>A Key Takeaway:</em> Elm architecture is designed in such a way that it showed me how I completely missed an important screen in my initial design of the page. At this point, it&#39;s clear to me that I need an <em>initial loading screen</em> :)</p>
<pre><code class="hljs"><span class="hljs-keyword">type</span> Model
    = InitialScreen
    | FilmsFromCharacter C (<span class="hljs-built_in">List</span> F)
    | CharactersFromFilm F (<span class="hljs-built_in">List</span> C)

(<span class="hljs-attr">...</span>)

view model =
    <span class="hljs-keyword">case</span> model of
        InitialScreen -&gt;
            simpleMessage <span class="hljs-string">"Loading amazing characters and films..."</span>

(<span class="hljs-attr">...</span>)

simpleMessage t =
    div <span class="hljs-meta">[</span> simpleMessageStyle <span class="hljs-meta">]</span> <span class="hljs-meta">[</span> text t <span class="hljs-meta">]</span></code></pre>

<p>The elm-http <code>get</code> function receives a &quot;Decoder&quot; and a url. The decoder is the function that will convert the json response to a character model. So it makes sense that it&#39;s inside the Character module, right?</p>
<p>Another thing that we realize at this point is that <em>I&#39;ll have to have the list of the films the character was in!</em> Of course. So let&#39;s change the model to also store the films&#39; urls that&#39;ll be in the character card returned by the API:</p>
<pre><code class="hljs"><span class="hljs-comment">-- Character.elm</span>
<span class="hljs-keyword">import</span> Json.Decode <span class="hljs-keyword">exposing</span> (<span class="hljs-type">Decoder</span>, succeed, string, list, int, (:=))
<span class="hljs-keyword">import</span> Json.Decode.Extra <span class="hljs-keyword">exposing</span> ((|:))

(...)

<span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">Model</span> =
    { name : <span class="hljs-type">String</span>
    , films : <span class="hljs-type">List</span> <span class="hljs-type">String</span>
    }


<span class="hljs-title">characterDecoder</span> : <span class="hljs-type">Decoder</span> <span class="hljs-type">Model</span>
<span class="hljs-title">characterDecoder</span> =
    succeed <span class="hljs-type">Model</span>
        |: (<span class="hljs-string">"name"</span> := string)
        |: (<span class="hljs-string">"films"</span> := list string)</code></pre>

<p>The <code>|:</code> comes from the <code>elm-community/elm-json-extra</code> package, and feels like a better way to parse a json than the standard library.</p>
<p>So now I have the decoder. Let&#39;s go back to Main and implement the <code>getCharacter</code> command for init:</p>
<pre><code class="hljs">import Http

(...)

getCharacter url =
    Http<span class="hljs-selector-class">.get</span> Character<span class="hljs-selector-class">.characterDecoder</span> url</code></pre>

<p>As soon as we define the <code>init</code> as <code>init = ( InitialScreen, getCharacter &quot;http://swapi.co/api/people/1/&quot; )</code> we&#39;ll receive the following message from the compiler:</p>
<pre><code class="hljs">The argument to <span class="hljs-keyword">function</span> <span class="hljs-title">`program`</span> <span class="hljs-keyword">is</span> causing a mismatch. - <span class="hljs-keyword">Function</span> <span class="hljs-title">`program`</span> <span class="hljs-keyword">is</span> expecting the argument to be:

    { init : ( <span class="hljs-type">Model</span>, Cmd a )

(...)

But it <span class="hljs-keyword">is</span>:

    { init : ( <span class="hljs-type">Model</span>, Platform.<span class="hljs-keyword">Task</span> Http.Error Character.Model )

(...)</code></pre>

<p>That means <code>getCharacter</code> is not returning a command, it&#39;s returning a <code>Task</code>. A task is actually a <em>representation</em> of an action that has not happened, and may or may not fail. To run the task, we need to feed it to the <code>Task.perform</code> function:</p>
<pre><code class="hljs">getCharacter url =
    url
        <span class="hljs-string">|&gt; Http.get Character.characterDecoder</span>
        <span class="hljs-string">|&gt; Task.perform FetchFail LoadFilms</span></code></pre>

<p>Now the task will run, and it&#39;s going to return a <code>Msg</code> of type <code>FetchFail Http.Error</code> if it fails, or a <code>LoadFilms Character.Model</code> if it succeeds. These two types should be part of the <code>Msg</code> that is sent to the update function:</p>
<pre><code class="hljs"><span class="hljs-keyword">type</span> <span class="hljs-type">Msg
    </span>= LoadFilms C
    | FetchFail Http.Error</code></pre>

<p>We also need to handle those two messages in our update function. Elm architecture, once more, reminds us that we haven&#39;t planned all the possible application states: we need an error state, and a &quot;I have a character and I&#39;m waiting for the films&quot; state:</p>
<pre><code class="hljs"><span class="hljs-keyword">type</span> <span class="hljs-type">Model</span>
    = <span class="hljs-type">InitialScreen</span>
    | <span class="hljs-type">ErrorScreen</span>
    | <span class="hljs-type">WaitingForFilms</span> <span class="hljs-type">C</span>
    | <span class="hljs-type">FilmsFromCharacter</span> <span class="hljs-type">C</span> (<span class="hljs-type">List</span> <span class="hljs-type">F</span>)
    | <span class="hljs-type">CharactersFromFilm</span> <span class="hljs-type">F</span> (<span class="hljs-type">List</span> <span class="hljs-type">C</span>)


<span class="hljs-keyword">type</span> <span class="hljs-type">Msg</span>
    = <span class="hljs-type">LoadFilms</span> <span class="hljs-type">C</span>
    | <span class="hljs-type">FetchFail</span> <span class="hljs-type">Http</span>.<span class="hljs-type">Error</span>


<span class="hljs-title">update</span> msg model =
    <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
        <span class="hljs-type">FetchFail</span> _ -&gt;
            ( <span class="hljs-type">ErrorScreen</span>, <span class="hljs-type">Cmd</span>.none )

        <span class="hljs-type">LoadFilms</span> c -&gt;
            ( <span class="hljs-type">WaitingForFilms</span> c, <span class="hljs-type">Cmd</span>.none )


<span class="hljs-title">view</span> model =
    <span class="hljs-keyword">case</span> model <span class="hljs-keyword">of</span>
        <span class="hljs-type">InitialScreen</span> -&gt;
            simpleMessage <span class="hljs-string">"Loading amazing characters and films..."</span>

        <span class="hljs-type">ErrorScreen</span> -&gt;
            simpleMessage <span class="hljs-string">"Sorry, there was an error. Please try again!"</span>

        <span class="hljs-type">WaitingForFilms</span> c -&gt;
            div [ twoColumns ]
                [ <span class="hljs-type">Character</span>.view c
                , simpleMessage <span class="hljs-string">"Loading Films..."</span>
                ]

(...)</code></pre>

<h2 id="good-tools-nudge-you-in-the-right-direction">Good Tools Nudge You in the Right Direction</h2>
<p>I&#39;d like to express once again how awesome Elm is to have pointed out that alternative application states were needed. I &quot;naively&quot; thought only two screens were needed, and in reality I needed five :)</p>
<p>The concept of a tool &quot;nudging&quot; you to better practices was first introduced to me in a Rich Hickey, inventor of Clojure, video (any video of him is well worth your time!).</p>
<p>This also led me to conclude that Javascript is always nudging us in the <em>wrong</em> direction. Rich Hickey, for example, made Clojure so that, if you are in a hurry, you can work with immutable variables. You have to go out of your way to mutate values using that tool, and that&#39;s good, because mutations are a big source of unnecessary complexity.</p>
<p>Compare that to Javascript: it&#39;s always easier to mutate everything, change variables outside the function scope, write functions that are impure... So that means that you are nudged <em>towards application complexity</em> when using Javascript!</p>
<p>Elm, on the other hand, is always nudging me towards writing good code. I feel not only that I&#39;m writing code in a clean way, as I do with Clojure, but I&#39;m also building <em>the whole application</em> in a clean and complete way. I feel I&#39;m building every view necessary for every state the application will be in, and every error will be properly treated.</p>
<p>That&#39;s an awesome feeling. :)</p>
<h2 id="almost-finishing-our-application-">Almost Finishing Our Application...</h2>
<p>We are almost there! First of all let&#39;s implement the function that, given a character, it gets all the corresponding films.</p>
<p><em>Important:</em> We&#39;ll use the <code>Task.sequence</code> to batch all the tasks, but this is definitely not the best way to do it; these requests could and should be parallel. I invite you to suggest a better way to do it in the comments!</p>
<pre><code class="hljs"><span class="hljs-comment">-- Film.elm</span>

<span class="hljs-keyword">type</span> <span class="hljs-type">alias </span>Model =
    { title : <span class="hljs-type">String</span>
    , episode_id : <span class="hljs-type">Int</span>
    , characters : <span class="hljs-type">List</span> String
    }


filmDecoder : <span class="hljs-type">Decoder</span> Model
filmDecoder =
    succeed Model
        |: (<span class="hljs-string">"title"</span> := string)
        |: (<span class="hljs-string">"episode_id"</span> := int)
        |: (<span class="hljs-string">"characters"</span> := list string)</code></pre>

<pre><code class="hljs"><span class="hljs-comment">-- Main.elm</span>
<span class="hljs-keyword">type</span> <span class="hljs-type">Msg</span>
    = <span class="hljs-type">LoadFilms</span> <span class="hljs-type">C</span>
    | <span class="hljs-type">FetchFail</span> <span class="hljs-type">Http</span>.<span class="hljs-type">Error</span>
    | <span class="hljs-type">ToFilmsFromCharacter</span> <span class="hljs-type">C</span> (<span class="hljs-type">List</span> <span class="hljs-type">F</span>)

<span class="hljs-title">update</span> msg model =
    <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>

(...)

        <span class="hljs-type">LoadFilms</span> c -&gt;
            ( <span class="hljs-type">WaitingForFilms</span> c, getFilmsFromCharacter c )

        <span class="hljs-type">ToFilmsFromCharacter</span> c fs -&gt;
            ( <span class="hljs-type">FilmsFromCharacter</span> c fs, <span class="hljs-type">Cmd</span>.none )

(...)</code></pre>

<p>There&#39;s only one detail missing from our components: they need to produce a message when clicked. I implemented it so each component would send a message with its model, so the update function would be able to use the list of films&#39; or characters&#39; urls:</p>
<pre><code class="hljs">-- Character<span class="hljs-selector-class">.elm</span>
import Html<span class="hljs-selector-class">.Events</span> exposing (onClick)

(...)

view : Model -&gt; Html<span class="hljs-selector-class">.Html</span> Model
view model =
    <span class="hljs-selector-tag">div</span>
        [ onClick model
        , mainStyle
        ]
        [ <span class="hljs-selector-tag">div</span> [ nameStyle ] [ text model<span class="hljs-selector-class">.name</span> ] ]</code></pre>

<p>The type signature leaves it very clear: our view receives a Model, and returns an Html that produces messages of type Model. Good.</p>
<p>Now, when we use those views in our Main view, we need to add information to them in order to produce a valid message. For instance, if we click a character, it will send a message of type <code>Character.Model</code> (or <code>C</code>). But our application will only understand a message of type <code>LoadFilms C</code>. So we need to call the Character view function and <em>map</em> the message it sends with the <code>LoadFilms</code> tag. It&#39;s easier to demonstrate than to explain:</p>
<pre><code class="hljs">msgMap =
    <span class="hljs-type">Html</span>.<span class="hljs-type">App</span>.<span class="hljs-built_in">map</span>

view model =
    <span class="hljs-keyword">case</span> model of

(...)

    <span class="hljs-type">WaitingForFilms</span> <span class="hljs-built_in">c</span> -&gt;
            div [ twoColumns ]
                [ msgMap <span class="hljs-type">LoadFilms</span> (<span class="hljs-type">Character</span>.view <span class="hljs-built_in">c</span>)
                , simpleMessage <span class="hljs-string">"Loading Films..."</span>
                ]

    <span class="hljs-type">FilmsFromCharacter</span> <span class="hljs-built_in">c</span> fs -&gt;
            <span class="hljs-keyword">let</span>
                filmsViews =
                    fs
                        |&gt; <span class="hljs-type">List</span>.<span class="hljs-built_in">map</span> <span class="hljs-type">Film</span>.view
                        |&gt; <span class="hljs-type">List</span>.<span class="hljs-built_in">map</span> (msgMap <span class="hljs-type">LoadCharacters</span>)
            <span class="hljs-keyword">in</span>
                div [ twoColumns ]
                    [ msgMap <span class="hljs-type">LoadFilms</span> (<span class="hljs-type">Character</span>.view <span class="hljs-built_in">c</span>)
                    , div [] filmsViews
                    ]

(...)</code></pre>

<p>From now on, it&#39;s a &quot;complete the puzzle&quot; game. Just fill in the blanks asked by the compiler one by one, and the application will be ready and working.</p>
<h2 id="next-steps">Next Steps</h2>
<p>I can see two clear next steps for the app: making the requests parallel, and using animations for the transitions between the application states. As I said before, any ideas are welcome.</p>
<p><a href="http://lucasmreis.github.io/star-wars-elm/">Here&#39;s the working app</a>!</p>
<p><a href="https://github.com/lucasmreis/learning-elm/tree/master/part-3/app/elm">And here&#39;s the complete code</a>.</p>
<h2 id="conclusions">Conclusions</h2>
<p>Elm is awesome. The fact that the compiler asks you to take care of the union types in a pattern match, makes it very difficult to forget something. Actually, after compiling the code, the application worked perfectly on the first shot. I was looking for reliability, and I found it!</p>
<p>There&#39;s a new component that I was not aware of before, that became clearer with this new exercise: the psychological impact of a strong compiler. Whenever your code is not compilable, solving issues feels like <em>solving puzzles</em>, and actually <em>building something</em>  And, every time it compiles and we refresh the Elm Reactor window, we see <em>something working</em>.</p>
<p>With Javascript I feel like things are always breaking and I have to fi them little by little. Runtime errors generate frustration, and even when we solve them, they still bring thoughts like <em>did I really stop it from breaking? Will it break in production in some unexpected way? Did I really deal with all the possible cases?</em></p>
<p>Of course this is a personal observation, but I felt I should note it in case it resonates with other people facing the same struggles.</p>
<p>So, that was Part 3. Feel free to post any questions you might have!</p>
]]></description>
            <guid isPermaLink="false">Learning Elm, part 3</guid>
            <pubDate>Thu, 09 Jun 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Learning Elm, part 2]]></title>
            <description><![CDATA[<p><em>This is part 2 of a series:</em></p>
<ul>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-2/">Part 1: Understanding The Benefits Of A Simple Architecture</a></li>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-3/">Part 3: Building A Real Application</a></li>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-4/">Part 4: Property Based Testing And Better Modelling</a></li>
</ul>
<p>As I stated in part 1 of this series, I started learning Elm in a quest for more reliability in web front end programming. I implemented an algorithm, a parser, and things went very well.</p>
<p>Now let&#39;s build a simple application with user interaction. I want to see if I can still feel the same &quot;reliability&quot; I felt when I was only implementing a function.</p>
<p>It turns out Elm has a standard way of structuring apps baked into the language, the Elm Architecture. It&#39;s very simple, and has <em>already</em> influenced front end programming as a whole, mainly through the Redux library. We&#39;ll explore a simple version of the architecture in this post.</p>
<h2 id="the-spec">The Spec</h2>
<p>The specifications for our web app are:</p>
<ol>
<li>The user will input an abbreviation of a card</li>
<li>The application will spell out the card and render it</li>
</ol>
<p>We&#39;ll use the parser built in part 1 for that. Let&#39;s start.</p>
<h2 id="the-initial-boilerplate">The Initial Boilerplate</h2>
<p>First of all, of course, we need to install Elm. For a Mac, the cleanest path seems to be <code>brew cask install elm-platform</code>.</p>
<p>Next, running <code>elm package install</code> in the desired directory installs the language core, and creates an <code>elm-package.json</code> file. That file is the equivalent of <code>package.json</code> for the Elm world.</p>
<p>The easiest way to start developing is by editing the code in an editor (I&#39;ve been using <a href="https://github.com/sbrink/vscode-elm">VS Code</a> for Elm and it feels great), and running <code>elm-reactor</code> in the project directory.</p>
<p>Elm Reactor starts a server locally. Opening it in the browser shows a navigation page for the project. By clicking in any file, it compiles and runs the Elm code - super simple!</p>
<p>Now we have everything setup to start building our first Elm app.</p>
<h2 id="the-layout">The Layout</h2>
<p>Let&#39;s start by coding the layout. We will use a &quot;standard&quot; library called <code>elm-html</code>. It uses a virtual-dom technique to render the view, and we declare it as code:</p>
<pre><code class="hljs">module Main exposing (..)

import Html exposing (<span class="hljs-selector-tag">div</span>, <span class="hljs-selector-tag">input</span>, <span class="hljs-selector-tag">p</span>, text)


main =
    <span class="hljs-selector-tag">div</span>
        []
        [ <span class="hljs-selector-tag">input</span> [] []
        , <span class="hljs-selector-tag">p</span> [] [ text <span class="hljs-string">"Seven of Club"</span> ]
        ]</code></pre>

<p>Every Html node is a function of two parameters: attributes and the children nodes. So, the above code produces the following html:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Seven of Club<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>

<p>It takes a little time to get used to it, but it&#39;s actually very simple. We could style it with CSS, but for the sake of learning, let&#39;s do it inside Elm:</p>
<pre><code class="hljs">module Main exposing (..)

import Html exposing (<span class="hljs-selector-tag">div</span>, <span class="hljs-selector-tag">input</span>, <span class="hljs-selector-tag">p</span>, text)
import Html<span class="hljs-selector-class">.Attributes</span> exposing (style, placeholder)


main =
    <span class="hljs-selector-tag">div</span> [ mainStyle ]
        [ <span class="hljs-selector-tag">input</span>
            [ inputStyle
            , placeholder <span class="hljs-string">"Type your card..."</span>
            ]
            []
        , <span class="hljs-selector-tag">p</span> [ cardStyle ] [ text <span class="hljs-string">"Seven of Club"</span> ]
        ]


mainStyle =
    style
        [ ( <span class="hljs-string">"font-family"</span>, <span class="hljs-string">"-apple-system, system, sans-serif"</span> )
        , ( <span class="hljs-string">"margin"</span>, <span class="hljs-string">"10px"</span> )
        , ( <span class="hljs-string">"padding"</span>, <span class="hljs-string">"40px"</span> )
        , ( <span class="hljs-string">"display"</span>, <span class="hljs-string">"flex"</span> )
        , ( <span class="hljs-string">"flex-direction"</span>, <span class="hljs-string">"column"</span> )
        , ( <span class="hljs-string">"align-items"</span>, <span class="hljs-string">"stretch"</span> )
        , ( <span class="hljs-string">"background-color"</span>, <span class="hljs-string">"#fafafa"</span> )
        , ( <span class="hljs-string">"border"</span>, <span class="hljs-string">"lightgray solid 1px"</span> )
        ]


inputStyle =
    style
        [ ( <span class="hljs-string">"border"</span>, <span class="hljs-string">"#fafafa solid"</span> )
        , ( <span class="hljs-string">"border-bottom"</span>, <span class="hljs-string">"lightgray solid 1px"</span> )
        , ( <span class="hljs-string">"font-size"</span>, <span class="hljs-string">"2em"</span> )
        , ( <span class="hljs-string">"color"</span>, <span class="hljs-string">"rgba(0,0,0,0.75)"</span> )
        , ( <span class="hljs-string">"background-color"</span>, <span class="hljs-string">"#fafafa"</span> )
        ]


cardStyle =
    style
        [ ( <span class="hljs-string">"font-size"</span>, <span class="hljs-string">"2em"</span> )
        , ( <span class="hljs-string">"color"</span>, <span class="hljs-string">"rgba(0,0,0,0.75)"</span> )
        ]</code></pre>

<p>That&#39;s our layout. :)</p>
<h2 id="the-elm-architecture">The Elm Architecture</h2>
<p>Now let&#39;s get into how an Elm application is supposed to be structured.</p>
<p>Elm apps use a centralized state pattern, which I&#39;ve <a href="http://lucasmreis.github.io/blog/centralized-state-design-patterns/">written about in this blog</a>. It&#39;s a simple &quot;loop&quot; described as such:</p>
<pre><code class="hljs">Model &gt; <span class="hljs-keyword">View</span> &gt; <span class="hljs-keyword">Update</span> &gt; Model &gt; <span class="hljs-keyword">View</span> &gt; ...</code></pre>

<p>First you describe a model of your app. It is the skeleton, the data you need to render the application.</p>
<p>The view is then a function of the model. It takes the data and renders it.</p>
<p>After rendering, the application &quot;waits&quot; for user interaction or any other event. When that happens, it triggers the update function. The update function is a function that receives the old model and data of the event, and returns a new model. This model is then rendered, and the loop continues.</p>
<p>Elm gives us a function that does all the &quot;plumbing&quot; for us, and it&#39;s called <code>Html.App.program</code>. We&#39;ll use a simpler version of it, because that&#39;s everything we need for our small app, and it&#39;s called <code>beginnerProgram</code>. With it, you only need to define your model, update and view and the program does the heavy work for you:</p>
<pre><code class="hljs"><span class="hljs-attr">main</span> =
    Html.beginnerProgram
        { <span class="hljs-attr">model</span> = init <span class="hljs-string">""</span>
        , <span class="hljs-attr">view</span> = view
        , <span class="hljs-attr">update</span> = update
        }</code></pre>

<p>Now let&#39;s define <code>init</code>,  <code>view</code> and <code>update</code>.</p>
<h2 id="the-model">The Model</h2>
<p>The user interacts through an input. That means we need a String in our model to hold it. We do not need anything else, since the other changing part of our view is simply a function of that String.</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">alias</span></span> Model =
    <span class="hljs-built_in">String</span>


init : <span class="hljs-built_in">String</span> -&gt; Model
init <span class="hljs-keyword">str</span> =
    <span class="hljs-keyword">str</span></code></pre>

<p>That&#39;s all the model we need for our spec, and a function to initialize it.</p>
<h2 id="the-view">The View</h2>
<p>The view will be a function of our model. Let&#39;s use our layout as a starting point:</p>
<pre><code class="hljs">view model =
    div [ mainStyle ]
        [ input
            [ inputStyle
            , placeholder <span class="hljs-string">"Type your card..."</span>
            ]
            []
        , p [ cardStyle ] [ text <span class="hljs-string">"Seven of Club"</span> ]
        ]</code></pre>

<p>So, our view still does not use the model. Remember that we need to render the model string after parsing it, so let&#39;s do it:</p>
<pre><code class="hljs">import CardParser

(...)

view model =
  let
    card =
      CardParser<span class="hljs-selector-class">.spellCard</span> model
  <span class="hljs-keyword">in</span>
    <span class="hljs-selector-tag">div</span>
      [ mainStyle ]
      [ <span class="hljs-selector-tag">input</span>
          [ inputStyle
          , placeholder <span class="hljs-string">"Type your card..."</span>
          ]
          []
      , <span class="hljs-selector-tag">p</span> [ cardStyle ] [ text card ]
      ]</code></pre>

<p>Add a generic update function to the code to see the page rendered:</p>
<pre><code class="hljs"><span class="hljs-keyword">update</span> msg <span class="hljs-keyword">model</span> =
    <span class="hljs-keyword">model</span></code></pre>

<p>And we can see our app working! Change the initial value of the model in the beginnerProgram function and see the difference in the parsed string. Good work! Now let&#39;s make the app respond to some user interaction.</p>
<h2 id="the-update">The Update</h2>
<p>The update function is also simple: as the user types something in the input field, it changes the model. Html.App will make sure our new model is then rendered through the view function.</p>
<p>The update mechanism works through message passing. The view sends messages that are processed by the update function, and then it produces a new model:</p>
<pre><code class="hljs"><span class="hljs-keyword">type</span> <span class="hljs-type">Msg</span>
    = <span class="hljs-type">ChangeText</span> <span class="hljs-type">String</span>


<span class="hljs-title">update</span> : <span class="hljs-type">Msg</span> -&gt; <span class="hljs-type">Model</span> -&gt; <span class="hljs-type">Model</span>
<span class="hljs-title">update</span> msg model =
    <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
        <span class="hljs-type">ChangeText</span> newText -&gt;
            newText</code></pre>

<p>Now we need to send those messages on user input:</p>
<pre><code class="hljs">import Html<span class="hljs-selector-class">.Events</span> exposing (onInput)

(...)

view model =
    let
        card =
            CardParser<span class="hljs-selector-class">.spellCard</span> model
    <span class="hljs-keyword">in</span>
        <span class="hljs-selector-tag">div</span> [ mainStyle ]
            [ <span class="hljs-selector-tag">input</span>
                [ inputStyle
                , placeholder <span class="hljs-string">"Type your card..."</span>
                , onInput ChangeText -- HERE!!!
                ]
                []
            , <span class="hljs-selector-tag">p</span> [ cardStyle ] [ text card ]
            ]</code></pre>

<p>Refresh your Elm Reactor page and play with the input now. That&#39;s it, our work is done!</p>
<h2 id="but-specs-change-">But Specs Change...</h2>
<p>Don&#39;t they always? :)</p>
<p>Our app now needs <em>two inputs</em> that work the same way. The first thing that pops into our head is making a component of our current app, and then showing two of them. Let&#39;s do it.</p>
<p>Let&#39;s first create a new file called <code>ParserComponent.elm</code>, and move all the model, view and update code there. Our Main module will look like:</p>
<pre><code class="hljs"><span class="hljs-keyword">module</span> Main <span class="hljs-keyword">exposing</span> (..)

<span class="hljs-keyword">import</span> Html <span class="hljs-keyword">exposing</span> (beginnerProgram)
<span class="hljs-keyword">import</span> ParserComponent <span class="hljs-keyword">exposing</span> (<span class="hljs-type">Model</span>, <span class="hljs-type">Msg</span>, init, view, update)


<span class="hljs-title">main</span> =
    <span class="hljs-type">Html</span>.beginnerProgram
        { model = <span class="hljs-type">ParserComponent</span>.init <span class="hljs-string">""</span>
        , view = <span class="hljs-type">ParserComponent</span>.view
        , update = <span class="hljs-type">ParserComponent</span>.update
        }</code></pre>

<p>And our app will work the same way. Now, to have two of the same components, let&#39;s define a new model, view and update for our app:</p>
<pre><code class="hljs">type <span class="hljs-built_in">alias</span> Model =
    { firstParser : ParserComponent.Model
    , secondParser : ParserComponent.Model
    }


init <span class="hljs-keyword">first</span> <span class="hljs-keyword">second</span> =
    Model <span class="hljs-keyword">first</span> <span class="hljs-keyword">second</span></code></pre>

<p>First of all, our new model is comprised of two ParserComponents models. Ok. Now how will we update them? We will <em>tag</em> every message that is sent from each component, and then treat each of them in a new update function:</p>
<pre><code class="hljs">type Msg
    = First ParserComponent.Msg
    | Second ParserComponent.Msg

<span class="hljs-keyword">update</span> msg <span class="hljs-keyword">model</span> =
 <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
   <span class="hljs-keyword">First</span> m -&gt;
     { <span class="hljs-keyword">model</span> | firstParser = ParserComponent.update m model.firstParser}

   <span class="hljs-keyword">Second</span> m -&gt;
     { <span class="hljs-keyword">model</span> | secondParser = ParserComponent.update m model.secondParser}</code></pre>

<p>So, now our messages can be sent by the first or second component, and we&#39;ll tag each with <code>First</code> and <code>Second</code>. Then, a <code>First</code> message will update the <code>firstParser</code> portion of our model, and a <code>Second</code> message will update the <code>secondParser</code> portion of our model.</p>
<p>Now let&#39;s see how to actually tag those messages in the new view:</p>
<pre><code class="hljs">view model =
    <span class="hljs-selector-tag">div</span> []
        [ Html<span class="hljs-selector-class">.map</span> First
            (ParserComponent<span class="hljs-selector-class">.view</span> model.firstParser)
        , Html<span class="hljs-selector-class">.map</span> Second
            (ParserComponent<span class="hljs-selector-class">.view</span> model.secondParser)
        ]</code></pre>

<p>By using the <code>Html.map</code> we tag, with the first parameter, every message that is sent by the view rendered in the second parameter.</p>
<p>We are rendering a ParserComponent view with the <code>firstParser</code> portion of the model, and another with the <code>secondParser</code>, and we are tagging all the messages sent by the first with <code>First</code>, and all the messages sent by the second with <code>Second</code>.</p>
<p>Refresh again the Reactor page and there you have it - two independently working parser components.</p>
<h2 id="but-the-specs-can-change-again-">But The Specs Can Change Again...</h2>
<p>To test even more how easy and safe it is to change our Elm code, let&#39;s change our spec once more. Let&#39;s say each component has now to parse a <em>list of cards</em>, separated by comma.</p>
<p>We can achieve that by <em>only changing the view function of the component</em>:</p>
<pre><code class="hljs">sentence <span class="hljs-attr">card</span> =
    p [ cardStyle ] [ text card ]

view <span class="hljs-attr">model</span> =
    <span class="hljs-keyword">let</span>
        <span class="hljs-attr">cards</span> =
            model
                |&gt; String.split <span class="hljs-string">","</span>
                |&gt; List.<span class="hljs-built_in">map</span> String.trim
                |&gt; List.<span class="hljs-built_in">map</span> CardParser.spellCard
    <span class="hljs-keyword">in</span>
        div [ mainStyle ]
            [ input
                [ inputStyle
                , placeholder <span class="hljs-string">"Type your card..."</span>
                , onInput ChangeText
                ]
                []
            , div [] (List.<span class="hljs-built_in">map</span> sentence cards)
            ]</code></pre>

<p>And it just works.</p>
<h2 id="a-comment-on-difficulties">A Comment On Difficulties</h2>
<p>Up until now, I can think of two main difficulties people would find in Elm: the application architecture that it enforces and the syntax itself.</p>
<p>The architecture is simple, but it&#39;s very different from the classic MVC from Angular and Backbone. Lately the trend in Javascript has been React + Flux, so, if you are using Redux or any other similar framework, you should have no problem understanding Elm. If you are used to the classic MVC pattern, things are going to take a little more time to sink in.</p>
<p>The syntax is very restrictive, and this can be frustrating to some developers who are used to imperative programming. But as soon as I started changing code, refactoring, extracting components, and changing specs, I could feel that the &quot;restrictiveness&quot; pays off. I feel that the language forces you to think a little bit more before writing code, and then makes refactoring easier and simpler.</p>
<h2 id="conclusions">Conclusions</h2>
<p>My initial objective when I started learning Elm was investigate ways to have more reliable front end code. Up until now everything is going smoothly, I had no runtime error after the code got compiled, and I have a lot of trust that the code is doing what it&#39;s supposed to do. It&#39;s also still fun!</p>
<p>In part 3 I plan to make a simple application that makes http requests, and check if code is still as simple as it&#39;s now.</p>
<p>By the way, here&#39;s the <a href="https://github.com/lucasmreis/learning-elm">final code</a>.</p>
]]></description>
            <guid isPermaLink="false">Learning Elm, part 2</guid>
            <pubDate>Sat, 21 May 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Learning Elm, part 1]]></title>
            <description><![CDATA[<p><em>This is part 1 of a series:</em></p>
<ul>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-1/">Part 2: Understanding The Benefits Of A Strong Type System</a></li>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-3/">Part 3: Building A Real Application</a></li>
<li><a href="http://lucasmreis.github.io/blog/learning-elm-part-4/">Part 4: Property Based Testing And Better Modelling</a></li>
</ul>
<p>A big concern when working with Javascript is <em>reliability</em>. Reliability in the sense of being completely sure about what a piece of code does, and knowing that changing one part won&#39;t break another part. A key concept is <em>error feedback cycle</em>: how soon can you catch errors in your code?</p>
<p>There are a lot of ways to deal with that. &quot;Linters&quot; and comprehensive tests are a good start, and they are already a reality for most serious projects today. Using functional programming concepts like pure functions can also help a lot by simplifying your tests, and make it easier to reason about your project.</p>
<p>Another trend I see is using <em>types</em>, mostly through TypeScript and Facebook Flow. They claim that, by programming with types, you can have a compiler that helps you get the code right. Not only that, the compiler will catch a lot of errors early in the process, so the error feedback cycle gets much shorter.</p>
<p>So I decided to experiment with a typed language that compiles to Javascript. In a continuum of less to more code reliability (enforced or not by types), I compiled these players:</p>
<ol>
<li>Plain Javascript</li>
<li>Facebook Flow</li>
<li>TypeScript</li>
<li>PureScript</li>
<li>Elm</li>
</ol>
<p>Elm is the most &quot;hardcore typed language&quot; of the list, meaning that you can&#39;t even call Javascript code from Elm and vice-versa - you have to communicate through message passing. On the other hand, Elm would be the language that would provide the most &quot;type benefits&quot; of the list.</p>
<p>That&#39;s why I decided to start my investigations on reliability with Elm. Let&#39;s start by implementing a relatively simple algorithm, and then we&#39;ll move on to more real-life situations.</p>
<h2 id="the-spec">The Spec</h2>
<p>I will write an algorithm that spells out a playing card abbreviation. Some examples:</p>
<pre><code class="hljs"><span class="hljs-string">"3S"</span> -&gt; <span class="hljs-string">"Three of Spade"</span>
<span class="hljs-string">"10H"</span> -&gt; <span class="hljs-string">"Ten of Heart"</span>
<span class="hljs-string">"QC"</span> -&gt; <span class="hljs-string">"Queen of Club"</span>
<span class="hljs-string">"AD"</span> -&gt; <span class="hljs-string">"Ace of Diamonds"</span>
<span class="hljs-string">"3T"</span> -&gt; <span class="hljs-string">"-- unknown card --"</span></code></pre>

<p>I will write the algorithm using the <a href="http://elm-lang.org/examples/hello-html">Try Elm website</a>. Now let&#39;s start!</p>
<h2 id="modelling-with-types">Modelling With Types</h2>
<p>I&#39;ve read a lot about types in Haskell, OCaml and F#, but never had the chance to program anything using that kind of strong type system. I&#39;ve been using dynamic languages (Javascript and Clojure) for the last few years, so it feel a little weird to think of types first.</p>
<p>Disclaimer: I&#39;ll try to be as practical as I can. I&#39;ll try not to say &quot;Monad&quot; like everybody knows what it means, for instance :) An intermediate developer should be ok. If you have any questions, please feel free to ask in the comments.</p>
<p>Back to the problem, I&#39;ve come with the following initial representation of the cards:</p>
<pre><code class="hljs">type Value = Jack |<span class="hljs-string"> Queen </span>|<span class="hljs-string"> King </span>|<span class="hljs-string"> Ace </span>|<span class="hljs-string"> Num Int
type Suit = Club </span>|<span class="hljs-string"> Diamond </span>|<span class="hljs-string"> Spade </span>|<span class="hljs-string"> Heart</span></code></pre>
Both types are *union types*. That means that a Suit can either be a Club, Diamond, Spade or Heart. And a Value can be a Jack, a Queen, a King, an Ace or a Num with an integer. So, a Num 2 or Num 5 is a valid Value.

That seems like a nice model for our problem. Now let's implement the functions that print a card.

## Printing a Card

I'll first print a Suit. It's a no brainer:

<pre><code class="hljs">printSuit <span class="hljs-attr">suit</span> = <span class="hljs-built_in">toString</span> suit</code></pre>

<p>I&#39;m testing it by replacing the following values in the last line:</p>
<pre><code class="hljs"><span class="hljs-keyword">import</span> Html <span class="hljs-keyword">exposing</span> (text)

<span class="hljs-comment">-- code (...)</span>

<span class="hljs-title">main</span> =
  <span class="hljs-type">Spade</span>
    |&gt; printSuit
    |&gt; text</code></pre>

<p>The <code>|&gt;</code> operator chains function calls. In the above line I get Spade, call <code>printSuit</code> with it as a parameter, then get the result of that computation and call the function <code>text</code> with it. It shows &quot;Spade&quot; in the output screen, so it works! :)</p>
<p>To print a Value, calling <code>toString</code> is not enough. I need to handle the <code>Num Int</code> case differently. I&#39;ll use <em>pattern matching</em> to do that:</p>
<pre><code class="hljs">printValue value =
  case value of
    N<span class="hljs-function"><span class="hljs-title">um</span> 2 -&gt;</span>
      <span class="hljs-string">"Two"</span>

    N<span class="hljs-function"><span class="hljs-title">um</span> 3 -&gt;</span>
      <span class="hljs-string">"Three"</span>

    N<span class="hljs-function"><span class="hljs-title">um</span> 4 -&gt;</span>
      <span class="hljs-string">"Four"</span>

    N<span class="hljs-function"><span class="hljs-title">um</span> 5 -&gt;</span>
      <span class="hljs-string">"Five"</span>

    N<span class="hljs-function"><span class="hljs-title">um</span> 6 -&gt;</span>
      <span class="hljs-string">"Six"</span>

    N<span class="hljs-function"><span class="hljs-title">um</span> 7 -&gt;</span>
      <span class="hljs-string">"Seven"</span>

    N<span class="hljs-function"><span class="hljs-title">um</span> 8 -&gt;</span>
      <span class="hljs-string">"Eight"</span>

    N<span class="hljs-function"><span class="hljs-title">um</span> 9 -&gt;</span>
      <span class="hljs-string">"Nine"</span>

    N<span class="hljs-function"><span class="hljs-title">um</span> 10 -&gt;</span>
      <span class="hljs-string">"Ten"</span>

    _ -&gt;
      toString value</code></pre>

<p>A little boring, but I went through every case possible - unless someone enters a number less than 2 or more than 10. I&#39;ll deal with that in the function that actually creates the card.</p>
<p>To print the whole card, I&#39;ll make a function that concatenates a list that consists of: the value string, <code>&quot; of &quot;</code> and the suit string. I&#39;ll represent a card as a tuple <code>(Value, Suit)</code>:</p>
<pre><code class="hljs"><span class="hljs-built_in">print</span>Card (value, suit) =
  [<span class="hljs-built_in">print</span>Value value, <span class="hljs-string">" of "</span>, <span class="hljs-built_in">print</span>Suit suit] |&gt; String.concat

main =
  (Num 10, Spade)
    |&gt; <span class="hljs-built_in">print</span>Card
    |&gt; text

-- Ten of Spade</code></pre>

<p>The code above works, and I can be sure that all the combinations of Value and Suit will print well. That&#39;s really good.</p>
<p>I&#39;ll add another layer of safety and documentation by writing the type signatures of the functions. I catch myself writing &quot;type signatures&quot; as comments even to my Javascript code from time to time, and it helps when dealing with a piece of code months later. I&#39;m starting to believe that having a compiler that ensures that your type signatures are in sync with the implementations can help a lot with maintainability.</p>
<p><code>printCard</code> signature is: <code>printCard : (Value, Suit) -&gt; String</code>, but I think we can be more expressive if it is <code>printCard : Card -&gt; String</code>. That is possible with Elm, by writing a <em>type alias</em>:</p>
<pre><code class="hljs"><span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">Card</span> = (<span class="hljs-type">Value</span>, <span class="hljs-type">Suit</span>)

(...)

<span class="hljs-title">printCard</span> : <span class="hljs-type">Card</span> -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">printCard</span> (value, suit) =
  [printValue value, <span class="hljs-string">" of "</span>, printSuit suit] |&gt; <span class="hljs-type">String</span>.concat

<span class="hljs-title">main</span> =
  (<span class="hljs-type">Num</span> <span class="hljs-number">10</span>, <span class="hljs-type">Spade</span>)
    |&gt; printCard
    |&gt; text

<span class="hljs-comment">-- Ten of Spade</span></code></pre>

<p>So, if I have a valid card, I can print it. Nice. Now let&#39;s parse the original abbreviation string.</p>
<h2 id="parsing-a-suit-and-a-value-from-a-string">Parsing A Suit And A Value From A String</h2>
<p>First I&#39;ll parse the suit. My first take is:</p>
<pre><code class="hljs">parseSuit : Char<span class="hljs-function"> -&gt;</span> Suit
parseSuit char =
  <span class="hljs-keyword">case</span> char <span class="hljs-keyword">of</span>
    <span class="hljs-string">'C'</span><span class="hljs-function"> -&gt;</span> Club
    <span class="hljs-string">'D'</span><span class="hljs-function"> -&gt;</span> Diamond
    <span class="hljs-string">'S'</span><span class="hljs-function"> -&gt;</span> Spade
    <span class="hljs-string">'H'</span><span class="hljs-function"> -&gt;</span> Heart</code></pre>

<p>When I compile it - even before calling this function anywhere - the compiler screams an error. This is the message I get:</p>
<pre><code class="hljs">MISSING PATTERNS
This `<span class="hljs-keyword">case</span>` does <span class="hljs-keyword">not</span> have branches <span class="hljs-keyword">for</span> all possibilities.

<span class="hljs-number">11</span>| <span class="hljs-keyword">case</span> <span class="hljs-keyword">char</span> <span class="hljs-keyword">of</span>
<span class="hljs-number">12</span>| <span class="hljs-string">'C'</span> -&gt; Club
<span class="hljs-number">13</span>| <span class="hljs-string">'D'</span> -&gt; Diamond
<span class="hljs-number">14</span>| <span class="hljs-string">'S'</span> -&gt; Spade
<span class="hljs-number">15</span>| <span class="hljs-string">'H'</span> -&gt; Heart
You need <span class="hljs-built_in">to</span> account <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> following values:

 &lt;values besides <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'H'</span>, <span class="hljs-keyword">and</span> <span class="hljs-string">'S'</span>&gt;

Add <span class="hljs-keyword">a</span> branch <span class="hljs-built_in">to</span> cover this pattern!

If you are seeing this error <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> <span class="hljs-built_in">time</span>, check out these hints:
&lt;<span class="hljs-keyword">https</span>://github.com/elm-lang/elm-compiler/blob/<span class="hljs-number">0.16</span><span class="hljs-number">.0</span>/hints/missing-patterns.md&gt;
The recommendations about wildcard patterns <span class="hljs-keyword">and</span> `Debug.crash` are important!</code></pre>

<p>Oh my god, now that&#39;s an error message! First of all, the subject of the error is already outstanding: I coded that the function receives a Char as a parameter, and I did not handle all the Char cases. That means the compiler is preventing me from having code that behaves unexpectedly. What would be the return value if an <code>&#39;X&#39;</code> was passed? That case needs to be handled.</p>
<p>But, better than that, I really like how <em>didatic</em> the message was. Not only does it give some tips, it gives a link to a page teaching the subject! I&#39;ve read that <a href="https://twitter.com/czaplic?lang=en">Evan Czaplicki</a>, the language designer, is working hard on making the error messages better. Good job!</p>
<p>By reading that link, I learned that the best way to deal with this in this case is by using a Maybe type. Maybe is native to Elm, and represented by:</p>
<pre><code class="hljs"><span class="hljs-keyword">type</span> <span class="hljs-type">Maybe </span>a
  = Just a
  | Nothing</code></pre>

<p>Maybe represents a value that may or may not exist. So I&#39;ll make the assumption that if the Char inputted by the user is not one of the four, the Suit will not exist and will be represented by a Nothing:</p>
<pre><code class="hljs">parseSuit : Char<span class="hljs-function"> -&gt;</span> Maybe Suit
parseSuit s =
  <span class="hljs-keyword">case</span> s <span class="hljs-keyword">of</span>
    <span class="hljs-string">'C'</span><span class="hljs-function"> -&gt;</span> Just Club
    <span class="hljs-string">'D'</span><span class="hljs-function"> -&gt;</span> Just Diamond
    <span class="hljs-string">'S'</span><span class="hljs-function"> -&gt;</span> Just Spade
    <span class="hljs-string">'H'</span><span class="hljs-function"> -&gt;</span> Just Heart
    _<span class="hljs-function"> -&gt;</span> Nothing

main =
  <span class="hljs-string">'C'</span>
    |&gt; parseSuit
    |&gt; toString
    |&gt; text

-- Just Club</code></pre>

<p>The best part of using <em>a maybe</em> is that the functions that deal with the value returned by the parsers <em>will have to deal with the fact that they may not exist</em>. This will be enforced by the compiler, and is one way of making sure we have to explicitly deal with errors or unexpected behaviors in the code. I&#39;ll talk more about that later. Let&#39;s now write the Value parser.</p>
<p>A simple implementation would be:</p>
<pre><code class="hljs"><span class="hljs-title">parseValue</span> : <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Value</span>
<span class="hljs-title">parseValue</span> v =
  <span class="hljs-keyword">case</span> v <span class="hljs-keyword">of</span>
    <span class="hljs-string">"J"</span> -&gt;
      <span class="hljs-type">Just</span> <span class="hljs-type">Jack</span>

    <span class="hljs-string">"Q"</span> -&gt;
      <span class="hljs-type">Just</span> <span class="hljs-type">Queen</span>

    <span class="hljs-string">"K"</span> -&gt;
      <span class="hljs-type">Just</span> <span class="hljs-type">King</span>

    <span class="hljs-string">"A"</span> -&gt;
      <span class="hljs-type">Just</span> <span class="hljs-type">Ace</span>

    _ -&gt;
      <span class="hljs-type">String</span>.toInt v</code></pre>

<p>But the compiler screams that <code>String.toInt</code> does not return a Maybe Value. It returns a Result String Int which is described by <code>type Result error value = Ok value | Err error</code>. Let&#39;s extract this case to a different function so we can manage better <code>toInt</code>:</p>
<pre><code class="hljs"><span class="hljs-title">parseNumValue</span> : <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Value</span>
<span class="hljs-title">parseNumValue</span> v =
  <span class="hljs-keyword">case</span> <span class="hljs-type">String</span>.toInt v <span class="hljs-keyword">of</span>
    <span class="hljs-type">Ok</span> num -&gt;
      <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">2</span> &amp;&amp; num &lt;= <span class="hljs-number">10</span>) <span class="hljs-keyword">then</span>
        <span class="hljs-type">Just</span> (<span class="hljs-type">Num</span> num)
      <span class="hljs-keyword">else</span>
        <span class="hljs-type">Nothing</span>

    <span class="hljs-type">Err</span> _ -&gt;
      <span class="hljs-type">Nothing</span>


<span class="hljs-title">parseValue</span> : <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Value</span>
<span class="hljs-title">parseValue</span> v =
  <span class="hljs-keyword">case</span> v <span class="hljs-keyword">of</span>
    <span class="hljs-string">"J"</span> -&gt;
      <span class="hljs-type">Just</span> <span class="hljs-type">Jack</span>

    <span class="hljs-string">"Q"</span> -&gt;
      <span class="hljs-type">Just</span> <span class="hljs-type">Queen</span>

    <span class="hljs-string">"K"</span> -&gt;
      <span class="hljs-type">Just</span> <span class="hljs-type">King</span>

    <span class="hljs-string">"A"</span> -&gt;
      <span class="hljs-type">Just</span> <span class="hljs-type">Ace</span>

    _ -&gt;
      parseNumValue v

<span class="hljs-title">main</span> =
  <span class="hljs-string">"10"</span>
    |&gt; parseValue
    |&gt; toString
    |&gt; text

<span class="hljs-comment">-- Just (Num 10)</span></code></pre>

<p>This is one of the most interesting parts of the code we are writing. <code>parseNumValue</code> is the function that <em>guarantees</em> that a card will have a minimum value of 2 and a maximum of 10. This together with wrapping it in a Maybe, and using the Card type, is a guarantee that, whenever I have a Card variable, it&#39;s going to be a valid Card. There&#39;s no way to represent an invalid card, or to process an invalid card at some point of the code.</p>
<p>Now we can parse a Value and a Suit. The next step is parsing the whole abbreviation, like <code>&quot;10H&quot;</code> or <code>&quot;KS&quot;</code>.</p>
<h2 id="parsing-an-abbreviation-string">Parsing An Abbreviation String</h2>
<p>We need to separate the abbreviation string into a value string and a suit character. Now this is a fun function:</p>
<pre><code class="hljs">divideCardString : <span class="hljs-built_in">String</span> -&gt; (Maybe <span class="hljs-built_in">String</span>, Maybe Char)
divideCardString str =
  <span class="hljs-keyword">let</span>
    chars = <span class="hljs-built_in">String</span>.toList str

    suit = chars
      |&gt; <span class="hljs-built_in">List</span>.reverse
      |&gt; <span class="hljs-built_in">List</span>.head

    value = chars
      |&gt; <span class="hljs-built_in">List</span>.reverse
      |&gt; <span class="hljs-built_in">List</span>.tail
      |&gt; Maybe.<span class="hljs-built_in">map</span> <span class="hljs-built_in">List</span>.reverse
      |&gt; Maybe.<span class="hljs-built_in">map</span> <span class="hljs-built_in">String</span>.fromList

  <span class="hljs-keyword">in</span>
    (value, suit)

main =
  <span class="hljs-string">"AH"</span>
    |&gt; divideCardString
    |&gt; toString
    |&gt; text

-- (Just <span class="hljs-string">"A"</span>, Just <span class="hljs-string">'H'</span>)</code></pre>

<p>Let&#39;s break it into parts. First, there&#39;s the <code>let</code> keyword. It is used to compute temporary variables that will be returned after the <code>in</code> keyword.</p>
<p>The first variable is <code>chars</code>. It&#39;s the List representation of the input string. It&#39;s inferred as a List of Char.</p>
<p>To compute the next variables, I did not choose the most efficient way, and that can be &quot;homework&quot; for the reader :) <code>suit</code> is the head of the reverse of the list; in other words, it&#39;s the last Char. Note that <code>List.head</code> returns a Maybe, because the list may be empty!</p>
<p><code>value</code> is the rest of the string. It&#39;s the tail of the reverse of the list, reversed again, and transformed in a String again. That&#39;s definitely not performant, but fun :) <code>List.tail</code> returns a Maybe List, so, to apply <code>List.reverse</code> and <code>String.formList</code>, I had to use <code>Maybe.map</code>. Maybe.map is the way to apply a function to the value inside a Maybe.</p>
<p>Now the function that takes this tuple and returns a Maybe Card:</p>
<pre><code class="hljs">parseCardTuple : <span class="hljs-function"><span class="hljs-params">(Maybe String, Maybe Char)</span> -&gt;</span> Maybe Card
parseCardTuple (value, suit) =
  <span class="hljs-keyword">case</span> ( value |&gt; Maybe.andThen parseValue, suit |&gt; Maybe.andThen parseSuit ) <span class="hljs-keyword">of</span>
    <span class="hljs-function"><span class="hljs-params">(Just v, Just s)</span> -&gt;</span>
      Just (v, s)

    _<span class="hljs-function"> -&gt;</span>
      Nothing

main =
  (Just <span class="hljs-string">"7"</span>, Just <span class="hljs-string">'D'</span>)
    |&gt; parseCardTuple
    |&gt; toString
    |&gt; text

-- Just ((Num <span class="hljs-number">7</span>,Diamond))</code></pre>

<p><code>Maybe.andThen</code> is used when using <code>Maybe.map</code> returns a Maybe of a Maybe. <code>andThen</code> is for Maybes what <code>flatten</code> is for Arrays :)</p>
<p>The nice part of this function is that we called functions inside the <code>case of</code> syntax. So, if both parses are successful, I&#39;ll return a Just Card. If anything goes wrong, be it that there was no String to begin with, or one of the parses returned Nothing, our function itself will return Nothing.</p>
<p>Now our algorithm is ready! Let&#39;s glue all the parts together.</p>
<h2 id="the-final-function">The Final function</h2>
<p>The final function is just a composition of the ones we just built:</p>
<pre><code class="hljs">spellCard : <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span>
spellCard <span class="hljs-keyword">str</span> =
  <span class="hljs-keyword">str</span>
    <span class="hljs-params">|&gt; divideCardString
    |</span>&gt; parseCardTuple
    <span class="hljs-params">|&gt; printCard</span></code></pre>

<p>It does not compile. The compiler tells us that <code>parseCardTuple</code> returns a Maybe Card, and <code>printCard</code> was expecting a Card. We already know how to solve it, we just change it to <code>Maybe.map printCard</code>. The problem is that the function would still return a Maybe String, and we want to extract a String from it.</p>
<p>The <code>Maybe</code> module has a function for that: <code>Maybe.withDefault</code>. It accepts a default value and a Maybe. If the Maybe is a Just, it returns the value inside the Just. If it&#39;s a Nothing, it returns the default value. Here is the official implementation of <a href="https://github.com/elm-lang/core/blob/master/src/Maybe.elm#L51"><code>Maybe.withDefault</code></a>:</p>
<pre><code class="hljs"><span class="hljs-title">withDefault</span> : a -&gt; <span class="hljs-type">Maybe</span> a -&gt; a
<span class="hljs-title">withDefault</span> <span class="hljs-keyword">default</span> maybe =
  <span class="hljs-keyword">case</span> maybe <span class="hljs-keyword">of</span>
    <span class="hljs-type">Just</span> value -&gt; value
    <span class="hljs-type">Nothing</span> -&gt; <span class="hljs-keyword">default</span></code></pre>

<p>Using it, our final function is described as:</p>
<pre><code class="hljs">spellCard : <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span>
spellCard <span class="hljs-keyword">str</span> =
  <span class="hljs-keyword">str</span>
    <span class="hljs-params">|&gt; divideCardString
    |</span>&gt; parseCardTuple
    <span class="hljs-params">|&gt; Maybe.map printCard
    |</span>&gt; Maybe.withDefault <span class="hljs-string">"-- unknown card --"</span>


main =
  <span class="hljs-string">"AH"</span>
    <span class="hljs-params">|&gt; spellCard
    |</span>&gt; text

-- Ace of Heart</code></pre>

<p>It&#39;s done!</p>
<h2 id="but-specs-change-">But Specs Change...</h2>
<p>And we have to deal with it. One of the promises of strong type systems is that they make the code much easier and safer to change / refactor. I work daily with a big Javascript application, and I think that&#39;s one of the most painful points now. Changing any part of the code requires a lot of attention, and a lot of faith in the tests. Just changing a function is never the answer, and we have to be extra careful not to insert &quot;hidden bugs&quot; by creating new unexpected cases.</p>
<p>Let&#39;s suppose we want to include the Joker card:</p>
<pre><code class="hljs"><span class="hljs-string">"J"</span> -&gt; <span class="hljs-string">"Joker"</span></code></pre>

<p>The first thing I notice is that our model is not sufficient anymore. A card is not a tuple of value and suit; now we also have a joker. I&#39;m gonna change the <code>Card</code> type, and run the compiler to see what it says:</p>
<pre><code class="hljs"><span class="hljs-keyword">type</span> <span class="hljs-type">Card </span>= OrdinaryCard Value Suit | Joker</code></pre>

<p>The compiler complains that <code>printCard</code> does not print a Card, it prints a tuple. Let&#39;s change it:</p>
<pre><code class="hljs">printCard : <span class="hljs-type">Card</span> -&gt; <span class="hljs-type">String</span>
printCard card =
  case card <span class="hljs-keyword">of</span>
    <span class="hljs-type">OrdinaryCard</span> <span class="hljs-keyword">value</span> suit -&gt;
      [printValue <span class="hljs-keyword">value</span>, <span class="hljs-string">" of "</span>, printSuit suit] |&gt; <span class="hljs-type">String</span>.concat

  <span class="hljs-type">Joker</span> -&gt;
    <span class="hljs-string">"Joker"</span></code></pre>

<p>The other error the compiler caught was that <code>parseCardTuple</code> does not return a Card. Now it&#39;s time to pause a little and think about the parsers.</p>
<p>The Joker abbreviation is only a <code>&quot;J&quot;</code>, so it does not make sense to call <code>divideCardString</code> with it! If I have a <code>&quot;J&quot;</code>, I should return a Just Joker. To do that, I&#39;m gonna implement a new function:</p>
<pre><code class="hljs">parseCardString : <span class="hljs-built_in">String</span> -&gt; Maybe Card
parseCardString <span class="hljs-keyword">str</span> =
  case <span class="hljs-keyword">str</span> of
    <span class="hljs-string">"J"</span> -&gt;
      Just Joker

    _ -&gt;
      <span class="hljs-keyword">str</span>
        <span class="hljs-params">|&gt; divideCardString
        |</span>&gt; parseCardTuple</code></pre>

<p>It handles the case <code>&quot;J&quot;</code> separately, and calls our previous function if it&#39;s not a Joker. Now we only have to change <code>parseCardTuple</code> to return an OrdinaryCard instead of the tuple in case of success:</p>
<pre><code class="hljs">parseCardTuple : <span class="hljs-function"><span class="hljs-params">(Maybe String, Maybe Char)</span> -&gt;</span> Maybe Card
parseCardTuple (value, suit) =
  <span class="hljs-keyword">case</span> ( value |&gt; Maybe.andThen parseValue, suit |&gt; Maybe.andThen parseSuit ) <span class="hljs-keyword">of</span>
    <span class="hljs-function"><span class="hljs-params">(Just v, Just s)</span> -&gt;</span>
      Just (OrdinaryCard v s) -- <span class="hljs-keyword">not</span> a tuple

  _<span class="hljs-function"> -&gt;</span>
    Nothing</code></pre>

<p>And change <code>spellCard</code>:</p>
<pre><code class="hljs">spellCard : <span class="hljs-keyword">String</span> -&gt; <span class="hljs-keyword">String</span>
spellCard <span class="hljs-built_in">str</span> =
  <span class="hljs-built_in">str</span>
    |&gt; parseCardString
    |&gt; Maybe.<span class="hljs-built_in">map</span> printCard
    |&gt; Maybe.withDefault <span class="hljs-string">"-- unknown card --"</span>

main =
  <span class="hljs-string">"J"</span>
    |&gt; spellCard
    |&gt; <span class="hljs-built_in">text</span>

-- Joker</code></pre>

<p>That was very easy, and I really liked the compiler&#39;s help.</p>
<h2 id="first-impressions-of-elm">First Impressions Of Elm</h2>
<p>It&#39;s a simple algorithm, and it&#39;s just a pure function. I still can&#39;t tell if a big web application Elm codebase will feel the same way, so let&#39;s all take these conclusions with a grain of salt - it&#39;s just a first impression.</p>
<p>First: the code really feels <em>reliable</em>. Even though I do not have any unit tests, I&#39;m sure it works as expected, with no errors or difficult-to-spot runtime exceptions. In a more serious setting, I would write three or four unit tests and that&#39;s it. Reliability is probably the number one factor that&#39;s making me research other front end languages, and Elm&#39;s strong type system seems to be a clean path towards that.</p>
<p>Second: the code feels <em>maintainable</em>. I may have spent a little more time implementing the first version of the function than I would with Javascript. But I found that implementing the new spec was very easy and direct, maintaining the reliability feeling I had when I started coding the function.</p>
<p>Third: it was <em>fun</em>. Fun is sometimes overlooked when talking about technologies, but it should not be. Not only does it help keep the engineers engaged, it&#39;s usually a good signal that we are dealing with a smart and productive tool. No one finds using a dumb and clumsy tool fun, am I right? :)</p>
<h2 id="next-steps">Next Steps</h2>
<p>I really liked this first contact with Elm, and I&#39;m going to continue investigating it.</p>
<p>As a next step, I will implement a web app that uses our function. I&#39;ll have to deal with Elm&#39;s tooling outside the online REPL, and I&#39;ll have to deal with asynchronous events from user interaction.</p>
<p>Then I&#39;ll implement a web app that communicates with a server. I&#39;, curious to see how easy it&#39;ll be to write &quot;impure&quot; code in Elm.</p>
<p>If you have had any experiences with Elm, good or bad, feel free to post it in the comments section!</p>
<h2 id="the-final-code">The Final Code</h2>
<p>You can copy and paste the following code to the online REPL and play a little bit with Elm:</p>
<pre><code class="hljs">import Html exposing (text)
import <span class="hljs-built_in">String</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Value</span></span> = Jack <span class="hljs-params">| Queen |</span> King <span class="hljs-params">| Ace |</span> Num Int
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Suit</span></span> = Club <span class="hljs-params">| Diamond |</span> Spade <span class="hljs-params">| Heart
<span class="hljs-keyword">type</span> Card = OrdinaryCard Value Suit |</span> Joker


parseSuit : Char -&gt; Maybe Suit
parseSuit s =
  case s of
    <span class="hljs-string">'C'</span> -&gt; Just Club
    <span class="hljs-string">'D'</span> -&gt; Just Diamond
    <span class="hljs-string">'S'</span> -&gt; Just Spade
    <span class="hljs-string">'H'</span> -&gt; Just Heart
    _ -&gt; Nothing


parseNumValue : <span class="hljs-built_in">String</span> -&gt; Maybe Value
parseNumValue v =
  case <span class="hljs-built_in">String</span>.toInt v of
    <span class="hljs-literal">Ok</span> num -&gt;
      <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">2</span> &amp;&amp; num &lt;= <span class="hljs-number">10</span>) then
        Just (Num num)
      <span class="hljs-keyword">else</span>
        Nothing

    <span class="hljs-literal">Err</span> _ -&gt;
      Nothing


parseValue : <span class="hljs-built_in">String</span> -&gt; Maybe Value
parseValue v =
  case v of
    <span class="hljs-string">"J"</span> -&gt;
      Just Jack

    <span class="hljs-string">"Q"</span> -&gt;
      Just Queen

    <span class="hljs-string">"K"</span> -&gt;
      Just King

    <span class="hljs-string">"A"</span> -&gt;
      Just Ace

    _ -&gt;
      parseNumValue v


divideCardString : <span class="hljs-built_in">String</span> -&gt; (Maybe <span class="hljs-built_in">String</span>, Maybe Char)
divideCardString <span class="hljs-keyword">str</span> =
  <span class="hljs-keyword">let</span>
    chars = <span class="hljs-built_in">String</span>.toList <span class="hljs-keyword">str</span>

    suit = chars
      <span class="hljs-params">|&gt; List.reverse
      |</span>&gt; List.head

    value = chars
      <span class="hljs-params">|&gt; List.reverse
      |</span>&gt; List.tail
      <span class="hljs-params">|&gt; Maybe.map List.reverse
      |</span>&gt; Maybe.map <span class="hljs-built_in">String</span>.fromList

  <span class="hljs-keyword">in</span>
    (value, suit)


parseCardTuple : (Maybe <span class="hljs-built_in">String</span>, Maybe Char) -&gt; Maybe Card
parseCardTuple (value, suit) =
  case (value `Maybe.andThen` parseValue, suit `Maybe.andThen` parseSuit) of
    (Just v, Just s) -&gt;
      Just (OrdinaryCard v s) -- not a tuple

    _ -&gt;
      Nothing


parseCardString : <span class="hljs-built_in">String</span> -&gt; Maybe Card
parseCardString <span class="hljs-keyword">str</span> =
  case <span class="hljs-keyword">str</span> of
    <span class="hljs-string">"J"</span> -&gt;
      Just Joker

    _ -&gt;
      <span class="hljs-keyword">str</span>
        <span class="hljs-params">|&gt; divideCardString
        |</span>&gt; parseCardTuple


printSuit : Suit -&gt; <span class="hljs-built_in">String</span>
printSuit suit = toString suit


printValue : Value -&gt; <span class="hljs-built_in">String</span>
printValue value =
  case value of
    Num <span class="hljs-number">2</span> -&gt;
      <span class="hljs-string">"Two"</span>

    Num <span class="hljs-number">3</span> -&gt;
      <span class="hljs-string">"Three"</span>

    Num <span class="hljs-number">4</span> -&gt;
      <span class="hljs-string">"Four"</span>

    Num <span class="hljs-number">5</span> -&gt;
      <span class="hljs-string">"Five"</span>

    Num <span class="hljs-number">6</span> -&gt;
      <span class="hljs-string">"Six"</span>

    Num <span class="hljs-number">7</span> -&gt;
      <span class="hljs-string">"Seven"</span>

    Num <span class="hljs-number">8</span> -&gt;
      <span class="hljs-string">"Eight"</span>

    Num <span class="hljs-number">9</span> -&gt;
      <span class="hljs-string">"Nine"</span>

    Num <span class="hljs-number">10</span> -&gt;
      <span class="hljs-string">"Ten"</span>

    _ -&gt;
      toString value


printCard : Card -&gt; <span class="hljs-built_in">String</span>
printCard card =
  case card of
    OrdinaryCard value suit -&gt;
      [printValue value, <span class="hljs-string">" of "</span>, printSuit suit] <span class="hljs-params">|&gt; String.concat

  Joker -&gt;
    "Joker"


spellCard : String -&gt; String
spellCard <span class="hljs-keyword">str</span> =
  <span class="hljs-keyword">str</span>
    |</span>&gt; parseCardString
    <span class="hljs-params">|&gt; Maybe.map printCard
    |</span>&gt; Maybe.withDefault <span class="hljs-string">"-- unknown card --"</span>


main =
  <span class="hljs-string">"J"</span>
    <span class="hljs-params">|&gt; spellCard
    |</span>&gt; text</code></pre>]]></description>
            <guid isPermaLink="false">Learning Elm, part 1</guid>
            <pubDate>Fri, 22 Apr 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Should We Leave Javascript In Front End Programming?]]></title>
            <description><![CDATA[<p>I recently &quot;inherited&quot; a Javascript project at work. It was only &quot;a medium-sized React app&quot;, so we all thought it would be easy to get it up and running, and for us to start being productive - even though the application&#39;s only author was not there to help.</p>
<p>But unfortunately, it was not easy.  It took a couple of hours for the build to work, and a couple of days until I could make any production-ready changes. The difficulties I encountered in this process made me think about the technology choices we have to make in programming.</p>
<p>For instance, I always thought I knew the answer to this question: <em>Should we implement the next front end project in Javascript?</em></p>
<h2 id="my-original-answer">My Original Answer</h2>
<p><strong>Yes.</strong> I believed a hundred percent that, even though there were some really interesting language choices on the radar, we should choose Javascript. Simply because <em>that&#39;s what every developer in the market knows</em>, and <em>there&#39;s already a lot of libraries / frameworks that I can choose from</em>. Summing up, the main reason is <em>familiarity</em>, both with the syntax and the tools.</p>
<p>And that&#39;s what seems to have changed in front end web programming.</p>
<h2 id="javascript-is-not-one-language-anymore">Javascript Is Not One Language Anymore</h2>
<p>First of all, let me explain what I mean by &quot;Javascript is not one language anymore&quot;. I work on a really big front end project that still uses ES5 for most of the code, Angular 1.x as the framework, and Ramda as the main util library. Here is an example of a common piece of code:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> onPress = pCompose(
  pCatch(MetricService.logEvent(<span class="hljs-string">'payment:error'</span>)),
  MetricService.logEvent(<span class="hljs-string">'payment:success'</span>),
  StateService.change(<span class="hljs-string">'payment'</span>),
  prop(<span class="hljs-string">'data'</span>),
  $http,
  PaymentApiService.requestObj,
  MetricService.logEvent(<span class="hljs-string">'payment:submit'</span>));</code></pre>

<p>This is a good ES5 / Ramda / Angular piece of code. (<code>pCompose</code> and <code>pCatch</code> are not from Ramda library, but they are pretty self explanatory :) ).</p>
<p>That piece of code written today could look like:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> onPress = <span class="hljs-keyword">async</span> id =&gt; {
  MetricService.logEvent(<span class="hljs-string">'payment:submit'</span>, id)
  <span class="hljs-keyword">const</span> cartReq = PaymentApiService.requestObj(id)
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> { data } = <span class="hljs-keyword">await</span> axios(cartReq)
    StateService.change(<span class="hljs-string">'payment'</span>, data)
    MetricService.logEvent(<span class="hljs-string">'payment:success'</span>, data)
  } <span class="hljs-keyword">catch</span> (err) {
    MetricService.logEvent(<span class="hljs-string">'payment:error'</span>, err)
  }
}</code></pre>

<p>Which is also a perfectly good ES7 piece of code. And it&#39;s completely different, in a lot of aspects.</p>
<p>Some examples of differences in Javascript code: ES5 callbacks are very different from ES6 promises that are very different from ES7 async functions. &quot;For&quot; loops are very different from Lodash code, that is different from Ramda or Trine code too. Mutable objects, ImmutableJS, ES7 object spread operator... The list goes on.</p>
<p>So, no two projects I&#39;ve ever encountered were alike in those terms. They are always some chosen combination of practices and technologies, usually with very different styles mixed in because of external dependencies.</p>
<p>We can conclude that Javascript projects tend to be fundamentally different from each other, and tend to be messy as they grow.</p>
<h2 id="new-technologies-are-better">New Technologies Are Better</h2>
<p>ES6 and ES7 are bringing some really good features to the language. But to use them in a production environment, we will have to rely on &quot;transpiling&quot; tools like Babel. This is bringing <em>Javascript development</em> itself closer to <em>other front end languages development</em>. And there are <a href="https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js">a lot of those</a>.</p>
<p>The thing is, these other languages do a lot of things better than Javascript. For example, TypeScript adds a thin layer of types that can save a lot of headaches when your code base gets larger. ClojureScript has some very simple and performant wrappers around React, that work well with channels and goroutines for async work. Elm&#39;s cleverly designed compiler almost guarantees no runtime error will happen.  </p>
<p>With this information in mind, we can ask <em>the question</em> one more time: should we implement the next front end project in Javascript?</p>
<h2 id="opportunity-cost">Opportunity Cost</h2>
<p>The way this question should <em>always</em> be answered is with an opportunity cost analysis. In our case, it could be divided in three steps:</p>
<p><strong>1. Which problems in the code base would I like to solve?</strong></p>
<p>We need to understand our application&#39;s needs. Does it deal with a lot of async work? Is it heavy on user interaction? Does it need to run on very different platforms?</p>
<p><strong>2. Are there tools that will help me with those problems better than Javascript?</strong></p>
<p>The next step is trying to find solutions to these problems, and tools that implement those solutions. Powerful type systems, flexible async patterns, performant rendering, these are all important solutions that should be considered. Make a list of languages / tools that could help each problem.</p>
<p><strong>3. What are the costs of using these tools in relation to using the most up-to-date Javascript?</strong></p>
<p>What is the learning curve? How active is the community? Does it have a big ecosystem? How about native Javascript interop?</p>
<p>The answers to these questions define how costly the adoption of technology will be. An example: although ClojureScript has a decent sized community and ecosystem, these are nothing compared to Javascript, so there&#39;s an opportunity cost in choosing this tool.</p>
<p>And that&#39;s where the analysis enters: we have to weigh the benefits, and see if they outweigh the costs in relation to using Javascript, always basing your analysis on the most up-to-date Javascript version, which means you&#39;ll have to have a &quot;transpiling&quot; build phase, and learn some new concepts anyway.</p>
<p>Sometimes we would prefer small changes - like starting to use TypeScript. Changing from Babel to TypeScript compiler is a small cost, and that can bring a project to a higher level.</p>
<p>Sometimes small changes can only bring us so far, and a bigger learning curve cost of, let&#39;s say, refactoring to Elm, can lead to so much improvement to the final code that the time invested is worth it.</p>
<p>With this in mind, is it still the case that we should always use Javascript for a front end web project?</p>
<h2 id="my-new-answer">My New Answer</h2>
<p><strong>Probably yes.</strong> And I think with a little time the answer will shift to a more certain &quot;no&quot;.  :)</p>
<p>Today (even though this is changing) Javascript is still the &quot;simple way to start doing something&quot; tool. We all have browsers that can understand Javascript, and they have awesome debugging tools. Adding a build tool and using Babel is still simpler than most front end language development workflows.</p>
<p>An important observation: if we want to develop for mobile, React Native is the best &quot;non-native&quot; choice. So it makes sense that, if we want to reuse code or even knowledge in mobile projects, Javascript is the chosen tool.</p>
<p>But this is changing fast. I really believe that in about a year or two, Javascript&#39;s only strength will be the ecosystem. Tools like <a href="https://github.com/bhauman/lein-figwheel">figwheel</a> for ClojureScript, and <a href="https://github.com/elm-lang/elm-reactor">elm-reactor</a> for Elm are already considered superior to native Javascript dev tools.</p>
<p>Having worked with Clojure before, I&#39;ve already felt the benefits of using a superior language to solve a problem. I plan to start doing small projects in different languages this year, and write about them on this blog. I would really like to here about other developers experiences with compile-to-js languages, so feel free to post it in the comments!</p>
]]></description>
            <guid isPermaLink="false">Should We Leave Javascript In Front End Programming?</guid>
            <pubDate>Tue, 22 Mar 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Centralized State Design Patterns]]></title>
            <description><![CDATA[<p>Front end programming is difficult. We are still figuring out how to best deal with it, and the quantity of frameworks and libraries that appear and disappear every week is one of the consequences.</p>
<p>At some point, Facebook launched the <a href="https://facebook.github.io/react/">React</a> framework, which seemed to have &quot;solved&quot; the rendering part of front end programming. We&#39;re all getting used to React&#39;s syntax and virtual DOM algorithm, and it seems like a good pattern, from both performance and productivity perspectives.</p>
<p>But we&#39;re still a little bit lost when it comes to managing the information being rendered. At first everyone was using React with the MV-something patterns available in Angular or Backbone. Then Facebook itself started talking about Flux and its unidirectional approach, and we started to see a lot of Flux-inspired frameworks being released.</p>
<p>At the same time, in the &quot;parallel world&quot; of <a href="https://github.com/clojure/clojurescript">ClojureScript</a>, something very interesting was happening. The first big React wrapper for ClojureScript was <a href="https://github.com/omcljs/om">Om</a>, and it featured an intriguing <em>centralized state</em> concept.</p>
<p>It was new for me, and the first thing I and a lot of people thought was, <em>but isn&#39;t anything global really bad? Especially global state???</em> Now, months later, the centralized state concept is proving itself very powerful and simple, especially with libraries such as <a href="https://github.com/Yomguithereal/baobab">Baobab</a>, and, in particluar, <a href="http://rackt.org/redux/">Redux</a> becoming the new standard. (<a href="https://github.com/moreartyjs/moreartyjs">Morearty</a> seems to have been the first, but didn&#39;t gain as much traction as the others).</p>
<p>In the last year I&#39;ve studied and implemented projects with some of these frameworks, and even implemented a centralized state from scratch a couple of times. In this post, I will talk about the two design patterns you&#39;ll probably come across when working with a centralized state.</p>
<h2 id="update-listeners">Update Listeners</h2>
<p>I call the first design pattern the <em>Update Listeners</em> pattern. This pattern is used by the <a href="https://reagent-project.github.io/">Reagent</a> framework, and by <a href="https://github.com/Yomguithereal/baobab">Baobab</a> in the javascript world. I&#39;ve <a href="http://lucasmreis.github.io/blog/a-more-functional-approach-to-angular/">written about this before</a>, and it&#39;s the pattern I use in my daily work.</p>
<p>The application state resides in a single tree object. Different UI components can <em>listen</em> to updates on different nodes of the tree, and the component is re-rendered every time that node is updated.</p>
<p><img src="../assets/update-listeners.jpg" alt="Update Listeners Illustration"></p>
<p><strong>PROS:</strong> The main benefit of this pattern is that once the listeners are setup, the components are rendered automatically when the state is updated. That means that the UI is always reflecting the current state.</p>
<p>In terms of architecture, it&#39;s also a very interesting pattern because it makes it very clear which information from the state is being used in each visual component of the application.</p>
<p>Another <em>pro</em> is that the parent component does not need to have all the information that the child component needs to be rendered. This means that if I have a &quot;post&quot; component with &quot;comments&quot; child components, I only need to pass the comments&#39; IDs to each component. They themselves will gather the necessary information to be rendered using the listeners.</p>
<p><strong>CONS:</strong> Because of the code for the listeners, the components make assumptions about the how the state object works, and how the information itself is structured.</p>
<p>The <a href="https://github.com/Yomguithereal/baobab-react">baobab-react</a> project illustrates some of the ways that components can properly listen to changes in the main tree, and you can see how the components become dependent on the implementation of the application state object.</p>
<p>Because of this, the code of the components is not very generic, nor is it reusable, and the code of the application as a whole gets very tied to the library or framework used to handle the state.</p>
<h2 id="manual-render">Manual Render</h2>
<p>This pattern is used by the <a href="https://github.com/levand/quiescent">Quiescent</a> framework, and I also used it when I wrote about <a href="http://lucasmreis.github.io/blog/using-csp-as-application-architecture/">CSP as an application architecture</a>.</p>
<p>The application state resides in a simple data structure, usually a javascript object. The whole UI is a function that accepts this state object as a parameter and renders it. The developer calls the function &quot;manually&quot;; in other words, the UI does <em>not</em> react to changes in the application state.</p>
<p><img src="../assets/manual-render.jpg" alt="Manual Render Illustration"></p>
<p><strong>PROS:</strong> The first immediate benefit is that the majority of your components will be <em>stateless</em>. That means they will be easier to reason about, and it&#39;s going to be easier to reuse them in different contexts and even different applications.</p>
<p>Also, having more control over when rendering takes place can make rendering itself more effective and performant. A common way of dealing with this is taking advantage of <code>requestAnimationFrame</code> so there are no unecessary calls to <code>React.render</code> (as I have done <a href="http://lucasmreis.github.io/blog/using-csp-as-application-architecture/">here</a>).</p>
<p><strong>CONS:</strong> One con of working with stateless components is that you have to pass every single piece of information and every callback to the components, every time you use them. This can lead to more confusing code than simple <code>&lt;UserProfile id={userId} /&gt;</code>.</p>
<p>Not only that, if a stateless component needs a different piece of data, let&#39;s say the user&#39;s profile picture url, <em>the container component will have to pass this new piece of data</em>. Sometimes this can lead to multiple components needing to change because of one small change in a child component.</p>
<p>Another common and important problem is, now that rendering is manual, we could forget to fire the render function, which would put our UI out of sync with the application state.</p>
<h2 id="conclusions">Conclusions</h2>
<p>First question is: which one is better? From my personal experience, the <em>Update Listeners</em> pattern really saved our lives once :) We had a big Angular application, with state distributed all over the code, and every new feature added a lot of complexity to it. Now it&#39;s much simpler and easier to both add new features and debug the code.</p>
<p>On the other hand, we&#39;re thinking of rewriting/refactoring four other applications. React is being considered as the view framework, and we want components to be as shareable as possible. So, all the components receive data and callbacks as props, and make no assumptions on how the application is handling state. For this situation, the <em>Manual Render</em> seems like a better approach.</p>
<p>It&#39;s the usual but true conclusion: both design patterns have strengths and weaknesses, and each will work well depending on the situation.</p>
<h2 id="last-thoughts">Last Thoughts</h2>
<p>Not all state may belong to the centralized state tree. Animation state, for instance, seems to be better stored locally, in a React component&#39;s <code>state</code>. I&#39;m still trying to figure out how to better deal with these situations, and where they would fit in these patterns.</p>
<p>This categorization is a work in progress. If you have seen centralized state being used in a different way, or have any other &quot;pros&quot; and &quot;cons&quot;, please feel free to share! Any disagreement with the &quot;pros&quot; and &quot;cons&quot; listed here? I would love to hear from you! :)</p>
]]></description>
            <guid isPermaLink="false">Centralized State Design Patterns</guid>
            <pubDate>Wed, 13 Jan 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[ES6 Destructuring Improves Readability]]></title>
            <description><![CDATA[<p>Destructuring is one of the most powerful new features of javascript. It makes it easier to write more concise code, without compromising readability. This week I figured out that destructuring is also very good for documenting functions in javascript, and I want to share this thought with you.</p>
<p>For those not familiar with destructuring, I suggest <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Mozilla website</a> as a good starting point.</p>
<p>The situation is: you are reading code written by another developer (and I include in this grouping any code that you yourself wrote more than one month ago). Suddenly, there&#39;s this function call:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> cart = getCart(cartId, <span class="hljs-number">3</span>);</code></pre>

<p>It seems like it&#39;s a simple function that &quot;gets&quot; the cart with the id <code>cartId</code>. Awesome. But one detail creeps you out: what does the <code>3</code> mean? It could literally be anything. There&#39;s no clue in the function call as to what it means,and you&#39;ll have to open another file with the function declaration to find out.</p>
<p>One way to remedy this situation is accepting a <em>config object</em> as a parameter of the function:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> cart = getCart({cartId: cartId, retries: <span class="hljs-number">3</span>});</code></pre>

<p>And now we understand that our function gets a cart and retries three times if an error occurs.</p>
<p>But now let&#39;s take a look at the function declaration:</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCart</span>(<span class="hljs-params">config</span>) </span>{
  <span class="hljs-comment">// ...</span>
}</code></pre>

<p>When we look at this declaration, we have no clue as to what parameters the function actually receives. We have to look inside the function code to see which properties of <code>config</code> are being used, which is not optimal. In the recent past, the best way to deal with this was declaring variables in the beginning of the function, which is very verbose:</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCart</span>(<span class="hljs-params">config</span>) </span>{
  <span class="hljs-keyword">const</span> cartId = config.cartId;
  <span class="hljs-keyword">const</span> retries = config.retries;
  <span class="hljs-comment">// ...</span>
}</code></pre>

<p>So there were two situations: using a usual list of parameters, which compromised the readability of function <em>calls</em>, and using a <code>config</code> object, which compromised the readability of function <em>declarations</em>.</p>
<p>You see where this is going, right? By using destructuring, we can use an object as a parameter, without these problems:</p>
<pre><code class="hljs js"><span class="hljs-comment">// declaration</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCart</span>(<span class="hljs-params">{cartId, retries}</span>) </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// call</span>
<span class="hljs-keyword">const</span> cart = getCart({cartId: cartId, retries: <span class="hljs-number">3</span>});</code></pre>

<p>It may seem like a minor issue, but it saves a lot of time in the long run! You look at the function declaration and you know which parameters it expects. You look at a function call and you understand what the values being passed mean.</p>
<p>A nice situation where destructuring becomes a very useful documentation tool is React. After version <code>v0.14</code>, stateless components were introduced. They are simple components, declared as functions. An example would be:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> LoginForm = ({
  username,
  password,
  onForgetPassword,
  onSubmit}) =&gt;
    <span class="hljs-comment">//...</span></code></pre>

<p>Smooth, isn&#39;t it? :)</p>
]]></description>
            <guid isPermaLink="false">ES6 Destructuring Improves Readability</guid>
            <pubDate>Tue, 15 Dec 2015 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Using CSP As Application Architecture]]></title>
            <description><![CDATA[<p>Since I started studying and working on a Clojure project, I&#39;ve been using the <code>core.async</code> library. It&#39;s a really simple and powerful way of dealing with concurrency, which is also used in the Go language. It&#39;s an implementation of <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">Communicating Sequential Processes</a>, and now with ES6 generators we can use it in Javascript too! In this post, I&#39;ll be using <a href="https://github.com/ubolonton/js-csp">js-csp</a>.  Check out my <a href="../quick-introduction-to-csp-in-javascript/">Introduction to CSP in Javascript</a> - it can be considered &quot;Part 1&quot; of this post.</p>
<p>When I came across <a href="https://github.com/levand/quiescent">Quiescent&#39;s</a> <a href="https://github.com/levand/todomvc/tree/gh-pages/architecture-examples/quiescent">TodoMVC implementation</a>, I saw the power of CSP as a front end application framework <em>itself</em>. This post describes an expanded version of the architecture of that TodoMVC app.</p>
<h2 id="the-architecture">The Architecture</h2>
<p>The application has an object called <strong>state</strong>. The state holds the information needed to render the screen. </p>
<p>There&#39;s a <strong>render process</strong>, that triggers a React render (or whatever view framework you want to use) whenever a new state object is put into the <strong>render channel</strong>.</p>
<p>There are <strong>update processes</strong>, that transform state according to the data put into the <strong>update channels</strong>. After transforming the state, the update processes put the new state in the render channel.</p>
<p>There are <strong>complex actions processes</strong>, that are asynchronous processes that can trigger multiple update processes. It usually involves communication with the server, or any action that takes time to complete.</p>
<p>It&#39;s that simple. Those are the basic processes in the framework. Of course, it is possible to run more processes, like a router or websocket process, but let&#39;s start with the basic ones.</p>
<h2 id="application-config">Application Config</h2>
<p>First of all let&#39;s create the application config object. An example would be:</p>
<pre><code class="hljs js"><span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> {chan, go, take, put, putAsync, buffers} <span class="hljs-keyword">from</span> <span class="hljs-string">'js-csp'</span>;

<span class="hljs-keyword">const</span> loadApp = () =&gt; ({
  state: {
    words: [<span class="hljs-string">'first'</span>, <span class="hljs-string">'second'</span>, <span class="hljs-string">'last'</span>],
    current: <span class="hljs-number">0</span>,
    loading: <span class="hljs-literal">false</span>
  },
  updates: {
    channels: {
      view: chan(),
      add: chan(),
      loading: chan()
    },
    consumers: {
      view: Updates.view,
      add: Updates.add,
      loading: Updates.loading
    }
  },
  complexActions: {
    channels: {
      dbInsert: chan()
    },
    consumers: {
      dbInsert: ComplexActions.dbInsert
    }
  },
  renderCh: chan()
});</code></pre>

<p>And our <code>start</code> function:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> start = () =&gt; {
  <span class="hljs-keyword">let</span> app = loadApp();
  <span class="hljs-built_in">window</span>.app = app <span class="hljs-comment">// for debugging</span>
};

start();</code></pre>

<p>The config object has the <code>state</code>, the render channel <code>renderCh</code>, and the <code>updates</code> and <code>complexActions</code> channels and consumers. I&#39;m going to explain those later.</p>
<p>The <code>start</code> function loads the config, and will start all the processes. I like to put the loaded app in the <code>window</code> object, so I can play with it in the browser console, very much like Clojure&#39;s command line.</p>
<p>Get your build flow running (I like to use <a href="../npm-is-an-amazing-build-tool/">npm as a build tool</a>) and let&#39;s dive into the update processes.</p>
<h2 id="updates">Updates</h2>
<p>Let&#39;s pick one functionality in our app: adding a new word to the <code>state.words</code> list. First, let&#39;s implement the function that receives the old state and the word to add, and then returns the new state with the word added:</p>
<pre><code class="hljs js"><span class="hljs-comment">// updates.js</span>

<span class="hljs-comment">// util functions</span>
<span class="hljs-keyword">const</span> clone = obj =&gt; <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj)); <span class="hljs-comment">// naive but cool!</span>

<span class="hljs-keyword">const</span> assoc = (obj, prop, value) =&gt; {
  <span class="hljs-keyword">const</span> cl = clone(obj);
  cl[prop] = value;
  <span class="hljs-keyword">return</span> cl;
};

<span class="hljs-comment">// update function</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> loading = (state, loadingState) =&gt;
  assoc(state, <span class="hljs-string">'loading'</span>, loadingState);</code></pre>

<p>Every update function will receive two parameters: the state and the data used in the transformation.  Then it will return a new state. Since it&#39;s a pure function, <em>it&#39;s very simple to unit test</em>.</p>
<p>Now let&#39;s write a function to initiate a process that takes data from the <code>updates.channels.loading</code> channel, and transforms <code>state</code>:</p>
<pre><code class="hljs js"><span class="hljs-comment">// index.js</span>

<span class="hljs-keyword">const</span> initLoadingUpdate = app =&gt; {
  <span class="hljs-keyword">const</span> updateFn = app.updates.consumers.loading;
  <span class="hljs-keyword">const</span> ch = app.updates.channels.loading;
  go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// the process will go on forever</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-comment">// the process pauses waiting for a</span>
      <span class="hljs-comment">// value to be put in the channel</span>
      <span class="hljs-keyword">const</span> value = <span class="hljs-keyword">yield</span> take(ch);

      <span class="hljs-comment">// logging</span>
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`On update channel [ loading ] received value [ <span class="hljs-subst">${JSON.stringify(value)}</span> ]`</span>);

      <span class="hljs-comment">// updates the state</span>
      app.state = updateFn(app.state, value);
    }
  });
};</code></pre>

<p>And we can call it in the <code>start</code> function:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> start = () =&gt; {
  <span class="hljs-keyword">let</span> app = loadApp();
  <span class="hljs-built_in">window</span>.app = app <span class="hljs-comment">// for debugging</span>

  initLoadingUpdate(app);
};

start();

<span class="hljs-comment">// for debugging</span>
<span class="hljs-built_in">window</span>.csp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'js-csp'</span>);</code></pre>

<p>Let&#39;s test it in the browser. Write in the console:</p>
<pre><code class="hljs js">&gt; app.state.loading
&lt; <span class="hljs-literal">false</span>

&gt; csp.putAsync(app.updates.channels.loading, <span class="hljs-literal">true</span>)
&lt; On update channel [ loading ] received value [ <span class="hljs-literal">true</span> ]

&gt; app.state.loading
&lt; <span class="hljs-literal">true</span></code></pre>

<p>It works! :)</p>
<p>But we&#39;ll have many update processes. In this application we have three: <code>view</code>, <code>add</code> and <code>loading</code>. The first changes the word being shown in the screen (by changing <code>state.current</code>), and the second adds a new word. First, the functions:</p>
<pre><code class="hljs js"><span class="hljs-comment">// update.js</span>

<span class="hljs-comment">// util function</span>
<span class="hljs-keyword">const</span> append = (array, value) =&gt; {
  <span class="hljs-keyword">const</span> cl = clone(array);
  cl.push(value);
  <span class="hljs-keyword">return</span> cl;
};

<span class="hljs-comment">// update functions</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> view = (state, direction) =&gt; {
  <span class="hljs-keyword">const</span> nextCurrent = direction === <span class="hljs-string">'next'</span> ?
    <span class="hljs-built_in">Math</span>.min(state.current + <span class="hljs-number">1</span>, state.words.length - <span class="hljs-number">1</span>) :
    <span class="hljs-built_in">Math</span>.max(state.current - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);

  <span class="hljs-keyword">return</span> assoc(state, <span class="hljs-string">'current'</span>, nextCurrent);
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> add = (state, newWord) =&gt;
  assoc(state, <span class="hljs-string">'words'</span>, append(state.words, newWord));</code></pre>

<p>And let&#39;s change <code>initLoadingUpdate</code> to <code>initUpdates</code>, which loads a process for each update:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> initUpdates = app =&gt; {
  <span class="hljs-built_in">Object</span>.keys(app.updates.consumers).forEach(k =&gt; {
    <span class="hljs-keyword">const</span> updateFn = app.updates.consumers[k];
    <span class="hljs-keyword">const</span> ch = app.updates.channels[k];
    go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">const</span> value = <span class="hljs-keyword">yield</span> take(ch);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`On update channel [ <span class="hljs-subst">${k}</span> ] received value [ <span class="hljs-subst">${JSON.stringify(value)}</span> ]`</span>);
        app.state = updateFn(app.state, value);
      }
    });
  });
};

<span class="hljs-keyword">const</span> start = () =&gt; {
  <span class="hljs-keyword">let</span> app = loadApp();
  <span class="hljs-built_in">window</span>.app = app; <span class="hljs-comment">// for debugging and testing</span>

  initUpdates(app);
};</code></pre>

<p>In the console, use <code>csp.putAsync</code> to put data into channels and check the transformations being done in <code>app.state</code>!</p>
<h2 id="complex-actions">Complex Actions</h2>
<p>Sometimes one action cannot be translated in a simple update function. Take, for example, an action that inserts data into a db through a web server. It will set loading to true, make the request, update the state, and set loading to false. </p>
<p>These are what I&#39;m calling <em>complex actions</em>: functions that call more than one update over a period of time. They also receive two parameters: the update channels and the data required for the action.</p>
<p>For instance, let&#39;s think of the complex action that changes the nickname of person with a given person ID:</p>
<pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> changeNickname = (updateChannels, {personId, newNickname}) =&gt; {
  go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// do stuff and put in update channels</span>
  });
};</code></pre>

<p>For now, let&#39;s implement a &quot;fake&quot; complex action:</p>
<pre><code class="hljs js"><span class="hljs-comment">// complexActions.js</span>
<span class="hljs-keyword">import</span> {go, put, timeout} <span class="hljs-keyword">from</span> <span class="hljs-string">'js-csp'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> dbInsert = (updateChannels, newWord) =&gt; {
  go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">yield</span> put(updateChannels.loading, <span class="hljs-literal">true</span>);

    <span class="hljs-comment">// do something costly</span>
    <span class="hljs-keyword">yield</span> timeout(<span class="hljs-number">1000</span>);
    <span class="hljs-keyword">yield</span> put(updateChannels.add, newWord);

    <span class="hljs-keyword">yield</span> put(updateChannels.loading, <span class="hljs-literal">false</span>);
  });
};</code></pre>

<p>It&#39;s not as simple to unit test a complex action, but it&#39;s not complicated either. You just create the update channels and check the values passed to them. </p>
<p>And now let&#39;s take a look at the <code>initComplexActions</code>, which is very similar to <code>initUpdates</code>:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> initComplexActions = app =&gt; {
  <span class="hljs-built_in">Object</span>.keys(app.complexActions.consumers).forEach(k =&gt; {
    <span class="hljs-keyword">const</span> complexActionFn = app.complexActions.consumers[k];
    <span class="hljs-keyword">const</span> ch = app.complexActions.channels[k];
    go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">const</span> value = <span class="hljs-keyword">yield</span> take(ch);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`On complex action channel [ <span class="hljs-subst">${k}</span> ] received value [ <span class="hljs-subst">${JSON.stringify(value)}</span> ]`</span>);
        complexActionFn(app.updates.channels, value);
      }
    });
  });
};

<span class="hljs-keyword">const</span> start = () =&gt; {
  <span class="hljs-keyword">let</span> app = loadApp();
  <span class="hljs-built_in">window</span>.app = app;

  initUpdates(app);
  initComplexActions(app);
};</code></pre>

<p>Now go to the browser console and type:</p>
<pre><code class="hljs js">&gt; csp.putAsync(app.complexActions.channels.dbInsert, <span class="hljs-string">'another'</span>)
&lt; On complex action channel [ dbInsert ] received value [ <span class="hljs-string">"another"</span> ]
&lt; On update channel [ loading ] received value [ <span class="hljs-literal">true</span> ]
<span class="hljs-comment">// after 1000 miliseconds...</span>
&lt; On update channel [ add ] received value [ <span class="hljs-string">"another"</span> ]
&lt; On update channel [ loading ] received value [ <span class="hljs-literal">false</span> ]

&gt; app.state.words
&lt; [<span class="hljs-string">"first"</span>, <span class="hljs-string">"second"</span>, <span class="hljs-string">"last"</span>, <span class="hljs-string">"another"</span>]</code></pre>

<p>And that&#39;s exactly what we wanted. </p>
<h2 id="rendering">Rendering</h2>
<p>Rendering process works as follows:</p>
<ol>
<li>When a state is received in the <code>app.renderCh</code> channel, it triggers the rendering function. In our case it will be React, but it could be any other view framework.</li>
<li>The process will be &quot;busy&quot; until the next animation frame. That means it will not trigger the rendering function if a new state is received and rendering is taking place.</li>
<li>If a new state is put in the channel, and there&#39;s already a state waiting to be rendered, the older state will be discarded, and only the new state will be rendered. </li>
</ol>
<p>Let&#39;s start with number 3. That logic is ready for us in the <code>js-csp</code> library (and in <code>core async</code> too). Change the definition of <code>app.renderCh</code> to:</p>
<pre><code class="hljs js">renderCh: chan(buffers.sliding(<span class="hljs-number">1</span>))</code></pre>

<p>This means that the channel will hold 1 value at a time, and, if another value is put in the channel, the last one will be discarded and the new value will be available. This is the <em>sliding strategy</em>.</p>
<p>Now, to the render process:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> initRender = (app, element) =&gt; {
  <span class="hljs-comment">// render initial state</span>
  putAsync(app.renderCh, app.state);

  go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">const</span> state = <span class="hljs-keyword">yield</span> take(app.renderCh);

      <span class="hljs-comment">// little trick to "synchronize" async functions,</span>
      <span class="hljs-comment">// explained below</span>
      <span class="hljs-keyword">const</span> finishRender = chan();

      <span class="hljs-comment">// render passing state and channels, so</span>
      <span class="hljs-comment">// the user can trigger updates and </span>
      <span class="hljs-comment">// complex actions from the interface</span>
      React.render(

        <span class="hljs-comment">// main component</span>
        &lt;Main
          appState = {app.state}
          updateChannels = {app.updates.channels}
          complexActionsChannels = {app.complexActions.channels} /&gt;,

        <span class="hljs-comment">// DOM element to mount</span>
        element,

        <span class="hljs-comment">// callback to rendering, explained below</span>
        () =&gt; <span class="hljs-built_in">window</span>.requestAnimationFrame(() =&gt; putAsync(finishRender, {})));
      <span class="hljs-comment">// waits for a value in the finishRender channel</span>
      <span class="hljs-keyword">yield</span> take(finishRender);
    }
  });
};</code></pre>

<p>The first thing the process does is to take a value from the render channel. Then, the <code>finishRender</code> channel is created. This is a trick so the process wait for the <code>React.render</code> and <code>window.requestAnimationFrame</code> functions to continue.</p>
<p>Both functions are async, and don&#39;t block the main thread when called. That means that right after <code>React.render</code> is called, the expression <code>yield take(finishRender);</code> will be evaluated. That way the process will be paused until any value is put in the <code>finishRender</code> channel.</p>
<p><code>React.render</code> accepts a callback, and then calls <code>window.requestAnimationFrame</code>. This function waits for the next browser rendering frame and calls another callback.</p>
<p>Whenever the render is started, it waits for the next animation frame to get a new state to render. This way we make sure no unnecessary renders are triggered! Cool, isn&#39;t it?</p>
<p>A little modification is needed in the <code>initUpdates</code> process: the new state should be put in the render channel:</p>
<pre><code class="hljs js"><span class="hljs-comment">// ...</span>
app.state = updateFn(app.state, value);
<span class="hljs-keyword">yield</span> put(app.renderCh, app.state);
<span class="hljs-comment">// ...</span></code></pre>

<p>We start <code>initRender</code> by calling it in the <code>start</code> function:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> start = () =&gt; {
  <span class="hljs-keyword">let</span> app = loadApp();
  <span class="hljs-built_in">window</span>.app = app;

  initUpdates(app);
  initComplexActions(app);
  initRender(app, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'main'</span>));
};</code></pre>

<p>Go to the console and write the following command to add a thousand new words, and see how efficiently it&#39;s rendered:</p>
<pre><code class="hljs js">&gt; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) 
  { csp.putAsync(app.updates.channels.add, <span class="hljs-string">'word'</span> + i); }</code></pre>

<h2 id="the-finished-application">The Finished Application</h2>
<p>The code for the final application can be seen <a href="https://github.com/lucasmreis/csp-architecture/tree/master/src">here</a>, and it can be seen running <a href="http://lucasmreis.github.io/csp-architecture/#">here</a>. Be sure to open the console, inspect the <code>app</code> object, and play with the channels!</p>
<h2 id="conclusion">Conclusion</h2>
<p>CSP is a simple, powerful and time-tested way of dealing with asynchronous programming. Using it as an application framework is very rewarding. The architecture is robust, and seems to scale well. I&#39;m certainly going to use it in other projects, and I encourage everyone to try it!</p>
<h2 id="next-steps">Next Steps</h2>
<p>I&#39;d like to battle test the framework within a bigger project, to really get a sense of how it will behave. </p>
<p>Most client-side application demands could be translated as an update or complex action, at least the ones triggered by the user. But some could be implemented as ever running processes, initiated in the <code>start</code> function. For instance, a simple router could be written as:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> initHistory = app =&gt; {
  <span class="hljs-comment">// a nav channel could handle</span>
  <span class="hljs-comment">// the state transformations</span>
  <span class="hljs-comment">// caused by changing the route.</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// hash changes =&gt; nav channel</span>
  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'hashchange'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> screen = <span class="hljs-built_in">window</span>.location.hash.slice(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">const</span> current = get(app.state, <span class="hljs-string">'screen'</span>);
    <span class="hljs-keyword">if</span> (screen !== current) {
      putAsync(app.updates.channels.nav, screen);
    }
  });
}</code></pre>

<p>I would also like to experiment this way with web sockets.</p>
<p>If any of you want to exchange some ideas about using CSP as a framework with javascript, or any other flavor of front end programming, feel free to email me at <a href="mailto:lucasmreis@gmail.com">lucasmreis@gmail.com</a>.</p>
]]></description>
            <guid isPermaLink="false">Using CSP As Application Architecture</guid>
            <pubDate>Sat, 03 Oct 2015 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Quick Introduction To CSP In Javascript]]></title>
            <description><![CDATA[<p><em>What is CSP?</em> In practice, it&#39;s a way of writing concurrent code. The language Go uses it natively, Clojure has core.async which achieves it by using macros, and now we can use it in Javascript because of generators, which were included in ES6.</p>
<p><em>Why should I bother?</em> Because it&#39;s very powerful, efficient and simple. What more do you want? :)</p>
<p><em>Ok, let&#39;s do it. How do I start using it?</em> We will use <a href="https://github.com/ubolonton/js-csp">js-csp</a>, and we will need need generators, which are only included in ES6.  That means you&#39;ll have to use Node 4 or superior, or transpile your browser code with <a href="https://babeljs.io/">babel</a> (or any other transpile tool that supports generators).</p>
<p>Enough talking, let&#39;s go to the examples!</p>
<h2 id="example-1-the-process">Example 1: The Process</h2>
<p>A process is the first concept we&#39;re gonna learn. It runs code. And it&#39;s as simple as that. :)</p>
<p>This is the syntax to start a process: just pass a generator as a parameter to the <code>go</code> function. </p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> {go} <span class="hljs-keyword">from</span> <span class="hljs-string">'js-csp'</span>;

go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'something!'</span>);
});

<span class="hljs-comment">// terminal output:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// =&gt; something!</span></code></pre>

<h2 id="example-2-the-process-can-pause">Example 2: The Process Can Pause</h2>
<p>By using the <code>yield</code> keyword, you can pause a process, freeing the main thread:</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> {go, timeout} <span class="hljs-keyword">from</span> <span class="hljs-string">'js-csp'</span>;

go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> timeout(<span class="hljs-number">1000</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'something else after 1 second!'</span>);
});

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'something!'</span>);

<span class="hljs-comment">// terminal output:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// =&gt; something!</span>
<span class="hljs-comment">// =&gt; something else after 1 second!</span></code></pre>

<h2 id="example-3-processes-wait-for-values-in-channels">Example 3: Processes Wait For Values In Channels</h2>
<p>The channels are the second and last concept we&#39;re gonna learn. They are queues, and whenever process calls <code>take</code> on a channel, it pauses until a value is <code>put</code> into that channel. </p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> {go, chan, take, putAsync} <span class="hljs-keyword">from</span> <span class="hljs-string">'js-csp'</span>;

<span class="hljs-keyword">let</span> ch = chan();

go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> received = <span class="hljs-keyword">yield</span> take(ch);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'RECEIVED:'</span>, received);
});

<span class="hljs-keyword">const</span> text = <span class="hljs-string">'something'</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'SENDING:'</span>, text);

<span class="hljs-comment">// use putAsync to put a value in a</span>
<span class="hljs-comment">// channel from outside a process</span>
putAsync(ch, text);

<span class="hljs-comment">// terminal output:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// =&gt; SENDING: something</span>
<span class="hljs-comment">// =&gt; RECEIVED: something</span></code></pre>

<h2 id="example-4-processes-communicate-through-channels">Example 4: Processes Communicate Through Channels</h2>
<p>On the other side, processes that <code>put</code> a value on a channel also pause until some other process uses <code>take</code>. </p>
<p>This example is a little bit more complex, try to follow the flow of the main thread, and check it with the terminal output!</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> {go, chan, take, put} <span class="hljs-keyword">from</span> <span class="hljs-string">'js-csp'</span>;

<span class="hljs-keyword">let</span> chA = chan();
<span class="hljs-keyword">let</span> chB = chan();

<span class="hljs-comment">// Process A</span>
go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> receivedFirst = <span class="hljs-keyword">yield</span> take(chA);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'A &gt; RECEIVED:'</span>, receivedFirst);

  <span class="hljs-keyword">const</span> sending = <span class="hljs-string">'cat'</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'A &gt; SENDING:'</span>, sending);
  <span class="hljs-keyword">yield</span> put(chB, sending);

  <span class="hljs-keyword">const</span> receivedSecond = <span class="hljs-keyword">yield</span> take(chA);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'A &gt; RECEIVED:'</span>, receivedSecond);
});

<span class="hljs-comment">// Process B</span>
go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> sendingFirst = <span class="hljs-string">'dog'</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'B &gt; SENDING:'</span>, sendingFirst);
  <span class="hljs-keyword">yield</span> put(chA, sendingFirst);

  <span class="hljs-keyword">const</span> received = <span class="hljs-keyword">yield</span> take(chB);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'B &gt; RECEIVED:'</span>, received);

  <span class="hljs-keyword">const</span> sendingSecond = <span class="hljs-string">'another dog'</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'B &gt; SENDING:'</span>, sendingSecond);
  <span class="hljs-keyword">yield</span> put(chA, sendingSecond);
});

<span class="hljs-comment">// terminal output:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// =&gt; B &gt; SENDING: dog</span>
<span class="hljs-comment">// =&gt; A &gt; RECEIVED: dog</span>
<span class="hljs-comment">// =&gt; A &gt; SENDING: cat</span>
<span class="hljs-comment">// =&gt; B &gt; RECEIVED: cat</span>
<span class="hljs-comment">// =&gt; B &gt; SENDING: another dog</span>
<span class="hljs-comment">// =&gt; A &gt; RECEIVED: another dog</span></code></pre>

<h2 id="example-5-channel-are-queues">Example 5: Channel Are Queues</h2>
<p>Because channels are queues, when a process takes from a channel, the value will not be available for other processes to take. One process puts, one process takes. </p>
<p>In the example below you can check that the second process will never print <code>B &gt; RECEIVED: dog</code>, because the value was already taken by the first process.</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> {go, chan, take, put} <span class="hljs-keyword">from</span> <span class="hljs-string">'js-csp'</span>;

<span class="hljs-keyword">let</span> ch = chan();

go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> text = <span class="hljs-keyword">yield</span> take(ch);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'A &gt; RECEIVED:'</span>, text);
});

go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> text = <span class="hljs-keyword">yield</span> take(ch);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'B &gt; RECEIVED:'</span>, text);
});

go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> text = <span class="hljs-string">'dog'</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'C &gt; SENDING:'</span>, text);
  <span class="hljs-keyword">yield</span> put(ch, text);
});

<span class="hljs-comment">// terminal output:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// =&gt; C &gt; SENDING: dog</span>
<span class="hljs-comment">// =&gt; A &gt; RECEIVED: dog</span></code></pre>

<h2 id="example-6-buffered-channels-don-t-block-on-put">Example 6: Buffered Channels Don&#39;t Block On Put</h2>
<p>A channel can be buffered, which means that, for a given number of puts, a <code>put</code> will not make the process pause. </p>
<p>In the next example, even though no one called <code>take</code>, the first two puts will not block the process. But the channel has a buffer of size 2, so the third put will block the process, until someone takes from it.</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> {go, chan, put, buffers} <span class="hljs-keyword">from</span> <span class="hljs-string">'js-csp'</span>;

<span class="hljs-keyword">let</span> ch = chan(buffers.fixed(<span class="hljs-number">2</span>));

go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> put(ch, <span class="hljs-string">'value A'</span>);
  <span class="hljs-keyword">yield</span> put(ch, <span class="hljs-string">'value B'</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I should print!'</span>);
  <span class="hljs-keyword">yield</span> put(ch, <span class="hljs-string">'value C'</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I should not print!'</span>);
});

<span class="hljs-comment">// terminal output:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// =&gt; I should print!</span></code></pre>

<h2 id="example-7-dropping-and-sliding-buffers">Example 7: Dropping And Sliding Buffers</h2>
<p>Apart from the fixed buffer, which blocks after N puts, we have the dropping and sliding buffers too.</p>
<p>The dropping buffer can hold up to N values. Any additional values that are put into a dropping buffer will be discarded.</p>
<p>The sliding buffer can also hold up to N values. But, as opposed to the dropping buffer, when a new value is put into the sliding buffer, the first value put is dropped, and the buffer holds the new value.</p>
<p>In the example below, <code>value B</code> and <code>value C</code> get dropped in the dropping channel, because it was holding <code>value A</code>. On the second process, as soon as <code>value B</code> is put in the channel, <code>value A</code> is dropped. And as soon as <code>value C</code> is put in the channel, <code>value B</code> is dropped.</p>
<p>Because of the way they work, dropping and sliding buffers never block!</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> droppingCh = chan(buffers.dropping(<span class="hljs-number">1</span>));
<span class="hljs-keyword">let</span> slidingCh  = chan(buffers.sliding(<span class="hljs-number">1</span>));

go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> put(droppingCh, <span class="hljs-string">'value A'</span>);
  <span class="hljs-keyword">yield</span> put(droppingCh, <span class="hljs-string">'value B'</span>);
  <span class="hljs-keyword">yield</span> put(droppingCh, <span class="hljs-string">'value C'</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'DROPPING:'</span>, <span class="hljs-keyword">yield</span> take(droppingCh));
});

go(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> put(slidingCh, <span class="hljs-string">'value A'</span>);
  <span class="hljs-keyword">yield</span> put(slidingCh, <span class="hljs-string">'value B'</span>);
  <span class="hljs-keyword">yield</span> put(slidingCh, <span class="hljs-string">'value C'</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'SLIDING:'</span>, <span class="hljs-keyword">yield</span> take(slidingCh));
});

<span class="hljs-comment">// terminal output:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// =&gt; DROPPING: value A</span>
<span class="hljs-comment">// =&gt; SLIDING: value C</span></code></pre>

<h2 id="conclusion">Conclusion</h2>
<p>After using CSP for a while, coding asynchronous code with callback or promises seems jurassic. I&#39;m hopeful that with ES6 generators, CSP will become the standard in Javascript, as it is with Go and is starting to be with Clojure.</p>
<h2 id="next-steps">Next Steps</h2>
<p>Two other models also seem very interesting, and they could be considered more high level than CSP: <em>Functional Reactive Programming</em> and <em>Actors</em>, as they are used in Reactive Extensions and Erlang, respectively. I will definetely cover these these in future blog posts.</p>
<p>I also believe that CSP could be an amazing <em>front end framework</em>.  To read more, check out my blog post <a href="../using-csp-as-application-architecture/"><em>Using CSP as Application Architecture</em></a>.</p>
]]></description>
            <guid isPermaLink="false">Quick Introduction To CSP In Javascript</guid>
            <pubDate>Fri, 25 Sep 2015 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[NPM is an amazing build tool]]></title>
            <description><![CDATA[<p>I really like the &quot;build first approach&quot; to development, in which we automate common tasks and simplify workflow as quickly as possible. We lose a few minutes setting up the build tool, but save hours with the automation and have quicker feedback for errors and problems. No one argues with that these days.</p>
<p>I read a really good book on the &quot;build first approach&quot; applied to javascript, <a href="http://www.manning.com/bevacqua/">Javascript Application Design</a>, which was published in January 2015. It describes good practices for building javascript applications, and illustrate the task automations with Grunt.</p>
<p>But we know the javascript world, and now, in August 2015, Grunt is old enough to be in a museum. &quot;Gulp is the new thing, let&#39;s use it!&quot; Well, I&#39;ve worked with both, and I agree that the Gulp approach seems more sensible. But this time I want to talk about a third approach I&#39;ve come across: using <em>NPM itself</em> as the build tool. I&#39;ve found that it solves 90% of my project&#39;s build issues, and it&#39;s suitable for most projects we&#39;ll get involved with.</p>
<h2 id="npm-scripts-tasks">Npm Scripts = Tasks</h2>
<p>The <code>package.json</code> file has a <code>scripts</code> key, and that&#39;s where the tasks are registered. Each task is simply a command that will be run. For instance, let&#39;s suppose Mocha is being used as the testing framework, with <a href="https://babeljs.io/">Babel</a> transpiler. To use it, we run the command in the terminal:</p>
<pre><code class="hljs"><span class="hljs-comment">$</span> <span class="hljs-comment">npm</span> <span class="hljs-comment">install</span> <span class="hljs-literal">-</span><span class="hljs-comment">g</span> <span class="hljs-comment">mocha</span>
<span class="hljs-comment">$</span> <span class="hljs-comment">mocha</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">recursive</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">compilers</span> <span class="hljs-comment">js:babel/register</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">reporter</span> <span class="hljs-comment">spec</span></code></pre>

<p>You&#39;ll have to install Mocha globally, and run this complex command everytime you want to run the tests. If we use npm scripts, that&#39;s how we would do it: first, edit the <code>package.json</code> file:</p>
<pre><code class="hljs javascript"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"test"</span>: <span class="hljs-string">"mocha --recursive --compilers js:babel/register --reporter spec"</span>
}</code></pre>

<p>And then we use it simply by runnig the command <code>npm test</code> in the terminal.</p>
<p>There&#39;s a bonus for using the npm scripts: the packages do not have to be installed globally to be used in a script! That means that you only have to install Mocha by running <code>npm install --save-dev mocha</code>, and the <code>npm test</code> above will run. I find this is really good, since no global installing is needed, and every package used ends up listed in the <code>package.json</code>.</p>
<h2 id="organizing-the-project">Organizing The Project</h2>
<p>I like to organize my project with three folders: <code>src</code>, <code>test</code> and <code>dist</code>. The tests are all in <code>test</code>, and the source code in <code>src</code> gets compiled to <code>dist</code>. We already have the <code>npm test</code> task registered, let&#39;s register the task to compile javascript, using <a href="http://browserify.org/">Browserify</a>:</p>
<pre><code class="hljs javascript"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"js"</span>: <span class="hljs-string">"browserify src/scripts/index.js -t babelify --outfile dist/app.js"</span>
}</code></pre>

<p>Which we use by running:</p>
<pre><code class="hljs">$ npm <span class="hljs-built_in">run</span> js</code></pre>

<p><strong>Important:</strong> the <code>test</code> and <code>start</code> are &quot;default&quot; scripts, and can be called directly with <code>npm test</code> and <code>npm start</code>. The other scripts we are going to write need to be called with <code>npm run</code>.</p>
<p>You can also call simple commands in scripts. For instance, sometimes we only need to copy files to <code>dist</code> folder:</p>
<pre><code class="hljs javascript"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"html"</span>:   <span class="hljs-string">"cp src/index.html dist/"</span>,
  <span class="hljs-string">"assets"</span>: <span class="hljs-string">"cp -R src/assets/ dist/assets/"</span>
}</code></pre>

<p>You can also run npm scripts inside npm scripts! Let&#39;s create a first version of a complete <code>build</code> script, using the <code>js</code>, <code>html</code> and <code>assets</code> scripts:</p>
<pre><code class="hljs javascript"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"build"</span>: <span class="hljs-string">"npm run js &amp;&amp; npm run html &amp;&amp; npm run assets"</span>
}</code></pre>

<p>Simple and direct! :)</p>
<h2 id="serving-static-files">Serving Static Files</h2>
<p>I like to use the default script <code>npm start</code> to start a local server and serve the static files&quot;</p>
<pre><code class="hljs javascript"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"start"</span>: <span class="hljs-string">"cd dist &amp;&amp; httpserver"</span>
}</code></pre>

<p>The <a href="https://www.npmjs.com/package/httpserver">httpserver</a> package is super simple: fire it, and it starts serving the files in the current directory. By using the script, we do not need to enter and exit the <code>dist</code> directory, and we do not need to install <code>httpserver</code> globally!</p>
<h2 id="what-about-watching-files-">What About Watching Files?</h2>
<p>A crucial part of a good build workflow is minimizing the time between editing and serving the files. That results in quick feedback, and errors can be spotted earlier. </p>
<p>A lot of the packages we use to build our project already have support for listening to changes on source files. Let me illustrate it with the package <a href="https://github.com/sass/node-sass">node-sass</a>, which I&#39;ve been using to compile Sass files to CSS:</p>
<pre><code class="hljs javascript"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"css"</span>:       <span class="hljs-string">"node-sass src/styles/ -o dist/"</span>,
  <span class="hljs-string">"css:watch"</span>: <span class="hljs-string">"node-sass -w src/styles/ -o dist/"</span>
}</code></pre>

<p>If a terminal command is being used, or there&#39;s no watch capabilities in the library used, one can use one of many watching packages available in npm. I&#39;ve been using <a href="https://github.com/Qard/onchange">onchange</a>:</p>
<pre><code class="hljs javascript"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"html"</span>:         <span class="hljs-string">"cp src/index.html dist/"</span>,
  <span class="hljs-string">"html:watch"</span>:   <span class="hljs-string">"onchange 'src/*.html' -v -- npm run html"</span>,
  <span class="hljs-string">"assets"</span>:       <span class="hljs-string">"cp -R src/assets/ dist/assets/"</span>,
  <span class="hljs-string">"assets:watch"</span>: <span class="hljs-string">"onchange 'src/assets/*.*' -v -- npm run assets"</span>,
}</code></pre>

<p>After having all the <code>:watch</code> versions of the scripts, we can write our <code>build:watch</code> script. We could call all the scripts with <code>&amp;&amp;</code>, just like we did in <code>build</code>, but let&#39;s do something different this time: let&#39;s run the tasks in parallel! I&#39;ll use <a href="https://github.com/keithamus/parallelshell">parallelshell</a>:</p>
<pre><code class="hljs javascript"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"build:watch"</span>: <span class="hljs-string">"parallelshell 'npm run js:watch' 'npm run css:watch' 'npm run html:watch' 'npm run assets:watch'"</span>
}</code></pre>

<p>And there we have it: watching and compiling all the files, in parallel.</p>
<h2 id="conclusions">Conclusions</h2>
<p>I personally like the approach of developing small building blocks, and I enjoy the fact that each script is a terminal command. I found these characteristics make npm scripts direct, easy and simple.</p>
<p>These commands alse are definitely more perennial than Grunt and Gulp programming style. This makes npm builds mre robust to technology changes than the other two frameworks.</p>
<p>Even if you do not use it to build, npm scripts can make our job easier when dealing with complex terminal commands. In our example, if we want to deploy our application to Github Pages, we need to push the <code>dist</code> directory as a root to the <code>gh-pages</code> branch. It&#39;s a complex git command, and we can automate it this way:</p>
<pre><code class="hljs javascript"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"deploy"</span>: <span class="hljs-string">"git subtree push --prefix dist origin gh-pages"</span>
}</code></pre>

<p>And that&#39;s it: a new tool to make our development life easier. </p>
]]></description>
            <guid isPermaLink="false">NPM is an amazing build tool</guid>
            <pubDate>Sat, 22 Aug 2015 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Immutable Data Structures and Javascript]]></title>
            <description><![CDATA[<p>One of the most difficult - perhaps <em>the</em> most difficult - issue in a complex front end application is state handling. I&#39;ve written before about storing <a href="http://lucasmreis.github.io/blog/a-more-functional-approach-to-angular/">all application state</a> in a <a href="http://lucasmreis.github.io/blog/a-more-functional-approach-to-angular-with-baobab/">single, centralized object</a>, and now I&#39;ll write about using <em>immutable data structures</em>.</p>
<p>I found that working with immutable data structures has actually made implementation <em>much simpler</em>! How can a limitation make something more powerful, you may be asking yourself? Follow me and I&#39;ll explain.</p>
<p>##Why did I try this immutable thing</p>
<p>I&#39;ve been watching a lot of Rich Hickey videos lately, and everything this guy says makes a lot of sense. According to Hickey, an immutable collection is not only an &quot;array that cannot be modified&quot;, but it is an <em>array that can be treated as a value</em>.</p>
<p>When we have two Numbers or two Strings, and we want to know if they are equal, we simply ask &quot;are they equal?&quot; by using the <code>===</code> operator. That&#39;s it - <code>2</code> always equals <code>2</code>, and if <code>a = 2</code> and <code>b = 2</code> we can say for sure that <code>a === b</code>. The same would be true for other values like <code>&#39;this string&#39; === &#39;this string&#39;</code>.</p>
<p>But, if we have two arrays or objects, <code>===</code> does not work the same way. It works by comparing references, so <code>[1, 2, 3] === [1, 2, 3]</code> is false, because they are actually <em>two different collections that happen to have the same values</em>.</p>
<p>When working with immutable collections and objects, they are compared just like values. If they have the same elements, they are the same collection. Simple, isn&#39;t it? :)</p>
<p>This is possible due to smart algorithms and data structure implementation made by libraries like <a href="http://swannodette.github.io/mori/">Mori</a> and <a href="https://facebook.github.io/immutable-js/">Immutable.js</a>. I will not go into detail here, but here&#39;s what we need to know regarding these data structures:</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> Mori <span class="hljs-keyword">from</span> <span class="hljs-string">'mori'</span>;

<span class="hljs-comment">// a vector is an example of</span>
<span class="hljs-comment">// immutable data structure</span>
<span class="hljs-keyword">const</span> a = mori.vector(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);

<span class="hljs-comment">// conj appends a value to the</span>
<span class="hljs-comment">// end of a vector, and returns</span>
<span class="hljs-comment">// a new vector</span>
<span class="hljs-keyword">const</span> b = mori.conj(a, <span class="hljs-number">4</span>);

mori.equals(b, mori.vector(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))
<span class="hljs-comment">// =&gt; true</span>

<span class="hljs-comment">// cool feature: the original vector is preserved</span>
<span class="hljs-comment">//   (that's why they are also called</span>
<span class="hljs-comment">//   persistent data structures)</span>
mori.equals(a, mori.vector(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))
<span class="hljs-comment">// =&gt; true</span></code></pre>

<p><strong>Question 1.</strong> Are the objects cloned every time I apply a transformation? <strong>No.</strong> And that&#39;s a key part of the reason why the  immutable data structures&#39; performance is almost the same as their mutable counterparts. These libraries are implemented so that a transformed object <em>shares as much memory as possible</em> with the original object. (<a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1">more details here</a>)</p>
<p><strong>Question 2.</strong> Does that mean that storing transformed versions of objects use less memory? <strong>Yes!</strong> If we have an one million elements conventional array that occupies 1GB of memory, clone it, append an element, and save both versions, we&#39;ll use 2GB of memory. If we use an immutable vector and <code>conj</code>, storing both versions will not occupy much more space than storing only one vectors.</p>
<p>Pause a little bit to think about this last property of immutable objects, and think of how much awesomeness this &quot;limitation&quot; could bring to your code. :)</p>
<p>##Back to application state</p>
<p>The application will only consist of two lists, Foos and Bars. The user can add a new Foo or a new Bar using the app inputs. Foos and Bars are unique.</p>
<p>Let&#39;s do it step by step:</p>
<ul>
<li>The application state will be represented by a vector of hashmaps. The last hasmap will be the current state:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// appState.js</span>
<span class="hljs-keyword">const</span> initialValue = hashMap(
  <span class="hljs-string">'foos'</span>, set([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]),
  <span class="hljs-string">'bars'</span>, set([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]));

<span class="hljs-comment">// sets are unordered lists that have</span>
<span class="hljs-comment">// unique elements</span>

<span class="hljs-keyword">let</span> history = vector(initialValue);

<span class="hljs-comment">// get current state</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> currentState = () =&gt; peek(history);</code></pre>

<ul>
<li>To react to changes in the state, we register listeners. They consist of two functions: <code>listenTo</code>, which specifies a part/transformation of the state that will be listened to, and a <code>callback</code> to run if the state changes:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// appState.js</span>
<span class="hljs-keyword">let</span> listeners = vector();

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> listen = (listenTo, callback) =&gt; {
  listeners = conj(listeners, hashMap(
    <span class="hljs-string">'listenTo'</span>, listenTo,
    <span class="hljs-string">'callback'</span>, callback
  ));
};</code></pre>

<p>Example of a <code>listen</code> call:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> prop = key =&gt; o =&gt; Mori.get(o, key);
listen(prop(<span class="hljs-string">'bars'</span>), renderSomething);</code></pre>

<p>This means that every time the property <code>bars</code> change, the function <code>renderSomething</code> will be run with <code>bars</code> as argument.</p>
<ul>
<li>To change state, one calls the update function. It changes the state and calls all listeners if their new <code>listenTo</code> result are different from the previous state:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// appState.js</span>

<span class="hljs-comment">// callListener is called by the update</span>
<span class="hljs-comment">// function for each listener registered, with</span>
<span class="hljs-comment">// the previous and the new state value:</span>
<span class="hljs-keyword">const</span> callListener =
  (previousState, newState) =&gt; listener =&gt; {

    <span class="hljs-keyword">const</span> listenTo =
    get(listener, <span class="hljs-string">'listenTo'</span>);

  <span class="hljs-keyword">const</span> previousListenTo =
    listenTo(previousState);

  <span class="hljs-keyword">const</span> newListenTo =
    listenTo(newState);

    <span class="hljs-comment">// if state does not change for</span>
    <span class="hljs-comment">// listener, nothing happens.</span>
    <span class="hljs-comment">// Remember 'equals' is super cheap! :)</span>
  <span class="hljs-keyword">if</span> (!equals(
    previousListenTo, newListenTo)) {
        get(listener, <span class="hljs-string">'callback'</span>)(newListenTo);
  }
  };

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> update = fn =&gt; {
  <span class="hljs-keyword">const</span> previousState = peek(history);

  <span class="hljs-comment">// calculate new state</span>
  <span class="hljs-keyword">const</span> newState = fn(previousState);

  <span class="hljs-keyword">if</span> (!equals(previousState, newState)) {
    <span class="hljs-comment">// add new state to history.</span>
    <span class="hljs-comment">// Remember our data structures</span>
    <span class="hljs-comment">// are persistent, and share</span>
    <span class="hljs-comment">// memory space! :)</span>
    history = conj(history, newState);

    <span class="hljs-comment">// fire listener callbacks</span>
    each(listeners, callListener(previousState, newState));
  }
};</code></pre>

<ul>
<li>Good bonus: undo!</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// appState.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> undo = () =&gt; {
  <span class="hljs-keyword">if</span> (count(history) &gt; <span class="hljs-number">1</span>) {

    <span class="hljs-keyword">const</span> previousState =
      peek(history);

    history =
      subvec(history, <span class="hljs-number">0</span>, count(history) - <span class="hljs-number">1</span>);

    <span class="hljs-keyword">const</span> newState =
      peek(history);

    each(listeners,
      callListener(previousState, newState));
  }
}</code></pre>

<ul>
<li>Views can be rendered by functions that take the state value as input. These render functions can also be used as callbacks:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// render.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> renderList = elem =&gt; seq =&gt;
  elem.innerHTML =
    reduce(makeLi, <span class="hljs-string">'&lt;ul&gt;'</span>, seq) + <span class="hljs-string">'&lt;/ul&gt;'</span>;

<span class="hljs-comment">// index.js</span>

<span class="hljs-comment">// starts by rendering initial state:</span>
<span class="hljs-keyword">const</span> initialState =
  currentState();

renderList
  (foosElement)
  (get(initialState, <span class="hljs-string">'foos'</span>));

<span class="hljs-comment">// renders again on state change:</span>
listen(prop(<span class="hljs-string">'foos'</span>),
  renderList(foosElement));</code></pre>

<ul>
<li>User interactions will call the <code>update</code> function to change state. The argument passed is a function that will transform the current state. Let&#39;s call those transformations commands:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// command.js</span>
<span class="hljs-keyword">const</span> conjItem = item =&gt; coll =&gt;
  conj(coll, item);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> addFoo = foo =&gt; state =&gt;
  updateIn(state, [<span class="hljs-string">'foos'</span>], conjItem(foo));

<span class="hljs-comment">// index.js</span>

<span class="hljs-comment">// input</span>
<span class="hljs-keyword">let</span> newFooElement =
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'new-foo'</span>);

<span class="hljs-comment">// button</span>
<span class="hljs-keyword">let</span> addFooElement =
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'add-foo'</span>);

addFooElement.onclick = () =&gt;
  update(addFoo(newFooElement.value));</code></pre>

<p>And that&#39;s it!</p>
<p>The architecture is really simple, let&#39;s recap it:</p>
<ul>
<li>The application state is represented by an immutable object.</li>
<li>The views are rendered according to the state object.</li>
<li>Listeners with callbacks are registered. Changes in state cause callbacks to be fired.</li>
<li>State is changed by calling the update function.</li>
<li>User interactions or any other event can call the update function.</li>
</ul>
<p>##And what did we gain by using immutable data structures?</p>
<p>My first impression was: it&#39;s simple. After getting used to the Mori functions, it is very straightforward to manipulate the data structures. And the fact that Mori handles memory and performance very well makes the code very direct too.</p>
<p>Immutable persistent data structures make comparison very cheap, and it proved to be very important to the update function. Memory sharing is also an amazing feature that practically gave &quot;undo&quot; for free.</p>
<p>So, in the end immutable data structures made it easy, explicit and performant to implement application state as series of values.</p>
<p>##Next steps</p>
<p>I chose Mori because it&#39;s an interface for clojurescript native data structures. <a href="http://clojure.org/">Clojure</a> is an amazing language, and I&#39;m starting to study and experiment with it now.</p>
<p>Staying in javascript, it would also be interesting to get a look at <a href="https://facebook.github.io/immutable-js/">immutable.js</a>. It&#39;s maintained by facebook, and seems to play very well with React.</p>
]]></description>
            <guid isPermaLink="false">Immutable Data Structures and Javascript</guid>
            <pubDate>Sat, 04 Jul 2015 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Solve All Bugs Or Implement New Features?]]></title>
            <description><![CDATA[<p>Most projects have moments in which they have new features to implement and, at the same time, bugs to solve. A choice has to be made on whether to focus more time on solving those bugs and making sure they don&#39;t appear again - let&#39;s call this option <em>quality</em> - or implementing new features - <em>scope</em>.</p>
<p>A lot of arguments have been made in favor of quality. One of my favorites is an argument presented by <a href="http://www.joelonsoftware.com/articles/fog0000000043.html">Joel Spolsky in this already classic text</a>.</p>
<p>In this post I&#39;ll make the argument that, <em>even from business and financial</em> points of view, <em>focus on raising quality should always come a before focus on implementing new features</em>.</p>
<h2 id="the-concepts">The concepts</h2>
<p>First of all, let me explain better what I mean when I talk about quality and scope. Let&#39;s say there&#39;s a demand for X new features to be implemented in a given period and we know there are currently Y open bugs. One could say:</p>
<p><em>&quot;We are going to implement all X features and solve as many bugs as we can.&quot;</em></p>
<p>Or you could say:</p>
<p><em>&quot;We are going to solve all Y bugs in their root causes, and we&#39;ll implement as many features as we can.&quot;</em></p>
<p>See the difference? It&#39;s a matter of explicitly stating what your priorities are. In the first example, we&#39;ll make sure everything we implement is well tested and well designed, but some bugs will not be considered due to time constraints.  In most cases, bugs will be listed in a spreadsheet or on a board with a &quot;priority&quot; property, and the business will choose which bugs should be solved  per sprint, based on a &quot;financial&quot; analysis (which I&#39;ll talk about in the next section).</p>
<p>In the second case, a team will focus all of its energy on, at least, investigating every bug that appears. Whenever there&#39;s a decision not to solve a bug right away, it&#39;s because the developers diagnosed that the bug is not a manifestation of something that would stop the business, or incur a big loss.</p>
<p>Those are what I&#39;m calling in this post &quot;a focus on scope&quot; and &quot;a focus on quality&quot;, respectively.</p>
<h2 id="losses-due-to-lack-of-quality-and-scope">Losses due to lack of quality and scope</h2>
<p>One of the main criteria needed in order to choose between focusing on solving a bug or implementing a new feature is an analysis of the financial loss that the business will incur by <em>not</em> doing these things.</p>
<p>It&#39;s impossible to know for sure the loss a business could have in the future, so we&#39;ll need to estimate it. And to do the estimation we&#39;ll need to deal with uncertainty. My point is that the uncertainty of a loss due to not solving a bug is <em>qualitatively different</em> from the uncertainty of a loss due to not implementing a new feature.</p>
<p>To explain this difference, I&#39;ll briefly present two concepts introduced by author Nassim Taleb in his book <a href="http://www.amazon.com/Black-Swan-Improbable-Robustness-Fragility/dp/081297381X/">Black Swan</a>. I suggest this book to anyone interested in having their mind turned inside out. :)</p>
<h2 id="mediocristan-and-extremistan">Mediocristan and Extremistan</h2>
<p>Taleb argues that uncertainties can &quot;come from two places&quot;. The first place is Mediocristan: observations do not vary very much, or vary in a somewhat predictable way. An example of an Mediocristan uncertainty is &quot;the average height of a random group of a hundred people&quot;. After you measure five or six groups, you would have a very nice idea of what other averages will be. Even if one person in the group is the tallest man on Earth!</p>
<p>Then there is Extremistan, a place where one observation can be very, very different from the others, which makes predictions very difficult, sometimes even impossible. An example is &quot;the average net worth of a random group of a hundred people&quot;. Every group will have a very different average.  We could have a run of thirty, or even fifty groups with a very similar average, and then suddenly Bill Gates is in a group and &quot;BAM&quot;.</p>
<p>So, here&#39;s my first claim:</p>
<p><em>Losses due to not implementing a new feature belong in Mediocristan.</em></p>
<p>A new feature is something that in the past did not exist in your business (duh). That means that not having a new feature, in the majority of cases, will not cause a big loss. Or at least it will not make the losses you already have any bigger.</p>
<p>Let&#39;s consider for example an e-commerce business that wants their users to be able to pay with a new payment option, let&#39;s say Bitcoins. It could be difficult to estimate how much the company would <em>make</em>, but it&#39;s relatively easy to see that there won&#39;t be a big loss if the Bitcoin feature is not implemented. Current users are buying with current payment options and will continue doing so even without a Bitcoin option.</p>
<p>And that leads to my second claim:</p>
<p><em>Losses due to not solving a bug belong in Extremistan.</em></p>
<p>Every bug, no matter how small, can be the tip of the iceberg to a much deeper problem. That&#39;s why it&#39;s so difficult to estimate the effort needed to solve a bug. And deep problems can <em>stop a business in it&#39;s tracks</em>.</p>
<p>A bug in the error feedback of a credit card form could explain the drop in conversion rates. Also, that bug could be a manifestation of a much deeper problem with server side validation, which, in turn, could start to appear in other forms.</p>
<p>Some errors can be solved quickly by &quot;patching&quot; them. But that means that errors could reoccur if someone touches the code, or uses those same modules elsewhere. A lot of times, a more complex refactoring has to be done carefully, and must be fully backed by unit, integration and end to end tests. With these tests, we can diminish the chance of a bug creeping back up on you.</p>
<h2 id="but-is-the-whole-team-always-going-to-be-working-on-bugs-">But is the whole team always going to be working on bugs?</h2>
<p>What about all the new features that we need to implement??? When will that happen?</p>
<p>By solving every bug at its root cause, we diminish the chances of new bugs appearing. That means that in the not-so-long-term, almost everybody in the team will be focusing on implementing new features. The project gains traction, and will deliver a <em>larger scope</em> with a <em>higher quality</em>. And that&#39;s what everyone wants, isn&#39;t it?</p>
<p>I&#39;m not saying that all bugs have to be solved right away. I&#39;m saying that all bugs should be <em>investigated</em>, and the developers should diagnose whether or not the root cause could give rise to other new, more dangerous problems.</p>
<h2 id="a-script-for-dealing-with-a-bug">A script for dealing with a bug</h2>
<p>Every time a new bug is reported, and comes to the developers to be solved, ideally we should follow the following steps:</p>
<ol>
<li><p>Investigate the root cause of the problem. Ideally this should be done in pairs, with at least one of the developers having already worked on that part of the code. That would make things quicker.</p>
</li>
<li><p>Choose whether or not to solve the bug right away. The answer to this question should be &quot;yes&quot; in most cases.</p>
</li>
<li><p>Write tests to reproduce the bug. Unit tests preferably, but don&#39;t be afraid to write new integration and/or end to end tests, if needed. By creating new tests, we try to guarantee that if anything brings the bug back, it will be caught by tests before going to production.</p>
</li>
<li><p>Solve the root cause as well as you can.</p>
</li>
</ol>
<p>This approach is not new. It&#39;s actually one of the main components of Toyota&#39;s &quot;Lean Manufacturing&quot; revolution, called <a href="https://en.wikipedia.org/wiki/Autonomation">Jidoka</a>.</p>
<h2 id="summing-up">Summing up</h2>
<p>Losses due to not implementing a new feature are much more predictable than losses due to bugs not being solved. Every bug is a potential business-stopper. And that&#39;s why we should always give quality a higher priority than scope: to keep our businesses alive.</p>
]]></description>
            <guid isPermaLink="false">Solve All Bugs Or Implement New Features?</guid>
            <pubDate>Wed, 27 May 2015 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Spreadsheets Are An Awesome Functional Programming Tool]]></title>
            <description><![CDATA[<p>I worked for three years as a Risk Management Consultant.   That, as you can imagine, meant I spent a lot of time working with spreadsheets.
For the most part, Excel was the main spreadsheet platform that was used by the businesses that I interacted with.</p>
<p>I remember reading somewhere &quot;spreadsheets are functional programming!&quot;, but for some reason I was never very interested in going further until I watched <a href="https://www.youtube.com/watch?v=0CKru5d4GPk">Felienne Hermans&#39; talk on Strange Loop 2004</a>, where she implements selection sort with a spreadsheet and, believe it or not, even showed an implementation of a Turing machine with spreadsheets!</p>
<p>In general, every cell of a spreadsheet is either a <em>value</em> or a <em>pure function that takes other cells as inputs</em>. If we restrict it to only that, we can say that a spreadsheet is a platform for functional programming. In this post, I&#39;ll describe my experimentation with a Google Spreadsheet to model user interactions and state handling.</p>
<h2 id="state-handling-when-there-are-no-mutable-variables">State handling when there are no mutable variables</h2>
<p>If we only use pure functions to build our programs, we can benefit from a lot of cool things like modularity, lazy evaluation, and so on. It is relatively easy if we are implementing a mathematical model, or a compiler, for instance. They have well defined inputs and outputs, but things start getting more complex if we have a program that runs for a period of time, and reacts to user interaction. Is it possible to maintain purity in such a scenario?</p>
<p>The standard way of dealing with it is by mutating objects according to user interactions. It can be done in a lot of ways, and in my main project we are <a href="../a-more-functional-approach-to-angular/">keeping all state in a single object, and reacting to changes in it</a>. We find it much more manageable than the standard object oriented way, which deals with a lot of &quot;models&quot; that keep hidden internal local state.</p>
<p>This time I&#39;m gonna try to handle state by using <em>streams</em>. That means that I&#39;ll model user interactions <em>and</em> application state as streams of information.</p>
<h2 id="state-and-interaction-as-functions-of-time">State and interaction as functions of time</h2>
<p>So, let&#39;s start with a basic spec: the user inserts a string, and we have an application state that reacts to it by replicating this input. Let&#39;s call it Foo:</p>
<pre><code class="hljs">t = given moment <span class="hljs-keyword">in</span> time

<span class="hljs-keyword">user</span>Foo(t) = <span class="hljs-keyword">user</span> string input <span class="hljs-keyword">in</span> t

<span class="hljs-keyword">state</span>Foo(t) = foo <span class="hljs-keyword">state</span> <span class="hljs-keyword">in</span> t</code></pre>

<p>So, what I&#39;m doing here is <em>thinking of both interactions and application state as functions of time</em>. Let&#39;s detail more <code>stateFoo</code>:</p>
<pre><code class="hljs">stateFoo(<span class="hljs-name">t</span>) = f(<span class="hljs-name">userFoo</span>(<span class="hljs-name">t</span>))</code></pre>

<p>In this case, the application state will depend only on the current user interaction. To keep it really simple, let&#39;s define:</p>
<pre><code class="hljs"><span class="hljs-keyword">state</span>Foo(t) = <span class="hljs-keyword">user</span>Foo(t)</code></pre>

<p>And now let&#39;s implement it in a spreadsheet!</p>
<h2 id="modelling-time-in-a-spreadsheet">Modelling time in a spreadsheet</h2>
<p>Back in my consultant days, I was dealing with a lot of <a href="http://en.wikipedia.org/wiki/Time_series">time series analyses</a>, and the way we were dealing with time was simple: one line for every event. Let&#39;s start with sixteen &quot;time samples&quot; and some user interactions:</p>
<p><img src="../assets/userFoo.png" alt="Time and UserFoo(t)"></p>
<p>That means that on time <code>t = 2</code> the user submitted the input &quot;aaa&quot;, when <code>t = 4</code> the user submitted the input &quot;bbb&quot; and so on.</p>
<p><code>stateFoo</code> can be implemented then as a new column:</p>
<p><img src="../assets/stateFoo.png" alt="Simple stateFoo(t)"></p>
<p>That function (&quot;formula&quot; in spreadsheet) is repeated for every line, so every cell in the <code>stateFoo</code> column equals the corresponding cell from the same line in the <code>userFoo</code> column.</p>
<p>That was really simple and easy! Now let&#39;s implement a more interesting spec. Let the application state be the <em>last</em> Foo that was input by the user. Now, <code>stateFoo</code> does not only depend on <code>userFoo</code>, but it also depends on the past value of <code>stateFoo</code> itself!</p>
<pre><code class="hljs"><span class="hljs-keyword">state</span>Foo(t) = f(
  <span class="hljs-keyword">user</span>Foo(t),
  <span class="hljs-keyword">state</span>Foo(t - <span class="hljs-number">1</span>))

<span class="hljs-keyword">state</span>Foo(t) =
  if (<span class="hljs-keyword">user</span>Foo(t) is blank)
    return <span class="hljs-keyword">state</span>Foo(t - <span class="hljs-number">1</span>)
  else
    return <span class="hljs-keyword">user</span>Foo(t)</code></pre>

<p>So, if the user inputs something, <code>stateFoo</code> changes. If the user does not input anything, <code>stateFoo</code> repeats its last value. We can see it in the spreadsheet:</p>
<p><img src="../assets/stateFoo2.png" alt="stateFoo(t) with memory"></p>
<p>Now state looks more like the state we usually have in applications. Let&#39;s bring one more complexity: let the state carry <em>all previous values</em>.
I want the state to be a string that&#39;s the concatenation of every past user input, joined by <code>&quot;;&quot;</code>. A good start would be:</p>
<p><img src="../assets/stateFoo3.png" alt="Naive complex stateFoo(t)"></p>
<p>We can see the problem: as soon as the user inputs the first string, the state becomes <code>; aaa</code>. That error propagates to all future states. There are a lot of ways to solve this issue, but I&#39;ll use the one that I think is the simplest: I&#39;ll implement a new column that concatenates <code>&quot;;&quot;</code> to every past state, unless it is empty. So, if we have to concatenate a new input, we concatenate to this value:</p>
<p><img src="../assets/stateFoo4.png" alt="Temp column for complex stateFoo(t)"></p>
<p><img src="../assets/stateFoo5.png" alt="Final column for complex stateFoo(t)"></p>
<p>And there we have it; a state that reflects the whole application history.</p>
<h2 id="interaction-between-streams">Interaction between streams</h2>
<p>Let&#39;s recap: a stream is a function of time; given time = <code>t</code>, a stream would have the value <code>f(t)</code>. We are modelling user input as streams. Application state would then be transformations of user input streams.</p>
<p>One nice property of streams is that they can also be transformations of other streams, and past values of themselves. Let&#39;s illustrate this with another application state: the Bars.</p>
<p>The Bars work the same way as the Foos, but with one additional spec: the user can only add a new Bar after the Foo <code>requiredFoo</code> is input:</p>
<pre><code class="hljs"><span class="hljs-keyword">state</span>Bar(t) = f(
  <span class="hljs-keyword">user</span>Bar(t),
  <span class="hljs-keyword">state</span>Bar(t - <span class="hljs-number">1</span>),
  <span class="hljs-keyword">state</span>Foo(t));</code></pre>

<p>Back to our spreadsheet, let&#39;s implement the user interactions streams again:</p>
<p><img src="../assets/stateBar.png" alt="userBar(t)"></p>
<p>The interaction between Foos and Bars will be done with the <code>hasRequiredFoo</code> stream:</p>
<pre><code class="hljs">hasRequiredFoo(t) =
  <span class="hljs-keyword">state</span>Foo(t) contains <span class="hljs-string">"requiredFoo"</span></code></pre>

<p>For simplicity, let&#39;s assume <code>contains</code> means &quot;has substring <code>&quot;requiredFoo&quot;</code>&quot;:</p>
<p><img src="../assets/stateBar2.png" alt="hasRequiredFoo(t)"></p>
<p>And <code>stateBar</code> logic would be:</p>
<pre><code class="hljs"><span class="hljs-keyword">state</span>Foo(t) =
  if (<span class="hljs-keyword">user</span>Bar(t) is blank or
      not hasRequiredFoo(t))
    return <span class="hljs-keyword">state</span>Bar(t - <span class="hljs-number">1</span>)
  else
    return concat(
      <span class="hljs-keyword">user</span>Bar(t),
      <span class="hljs-keyword">state</span>Bar(t - <span class="hljs-number">1</span>))</code></pre>

<p><img src="../assets/stateBar3.png" alt="stateBar(t)">
<em>(in the above image, the &quot;C&quot; column refers to userBar)</em></p>
<p>And it&#39;s ready! :)</p>
<p>Now just the inputs and application state streams:</p>
<p><img src="../assets/finalStates.png" alt="Final inputs and states"></p>
<h2 id="conclusions">Conclusions</h2>
<p>I found this experiment very helpful and even entertaining! Now I understand what &quot;spreadsheets are functional programming!&quot; means, and I agree with it. Actually, I think spreadsheets could be a nice learning environment to start &quot;thinking functionally&quot;. It certainly helped me learn the &quot;state as streams&quot; concept.</p>
<p>Everybody interested in the subject should watch <a href="https://www.youtube.com/watch?v=0CKru5d4GPk">Felienne Hermans&#39; talk on Strange Loop 2004</a>. That was her PhD research subject, and she brings spreadsheet programming to a whole new level.</p>
<h2 id="next-steps">Next Steps</h2>
<p>The next obvious step for me is implement the &quot;state as streams&quot; concept using javascript. There are libraries that claim to help with this, like <a href="http://reactivex.io/">RxJS</a>, <a href="https://baconjs.github.io/">BaconJS</a> and the more recent <a href="https://github.com/paldepind/flyd">Flyd</a>. I&#39;ve also been reading about a beta framework based on RxJS and <a href="https://github.com/Matt-Esch/virtual-dom">virtual-dom</a> called <a href="https://github.com/staltz/cycle">CycleJS</a>, which looks promising.</p>
<p>The link to the complete spreadsheet used in this post is <a href="http://goo.gl/i1g3uP">here</a>.</p>
]]></description>
            <guid isPermaLink="false">Spreadsheets Are An Awesome Functional Programming Tool</guid>
            <pubDate>Sat, 02 May 2015 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Pointfree Javascript]]></title>
            <description><![CDATA[<p>Javascript is really a very flexible language. It has functional and object oriented characteristics, and it allows for programming in a lot of different styles. In this post I will present what is called <em>pointfree</em> style programming, and I will go through some common scenarios to demonstrate its benefits.</p>
<h2 id="one-step-back">One Step Back</h2>
<p>First, let me show the standard imperative way to extract information from an array - the for loop:</p>
<pre><code class="hljs js"><span class="hljs-comment">// imperative style</span>
<span class="hljs-keyword">var</span> getAdminEmails = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">users</span>) </span>{
  <span class="hljs-keyword">var</span> emails = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; users.length; i++) {
    <span class="hljs-keyword">if</span> (users[i].role === <span class="hljs-string">'admin'</span>) {
      emails.push(users[i].email);
    }
  }
  <span class="hljs-keyword">return</span> emails;
}</code></pre>

<p>What does this function do? Let&#39;s analyze it. I have an empty array. Then I go through every user. If a user&#39;s role is equal to <code>&#39;admin&#39;</code>, we add it&#39;s email to the array. Then we return that array.</p>
<p>I&#39;ve just described the function&#39;s code, but it&#39;s still not very clear what it <em>does</em>. A much clearer way to say it would be: <em>it returns all the emails of the users with admin role</em>.</p>
<p>Let&#39;s rewrite the function in a functional style, using javascript&#39;s own <code>filter</code> and <code>map</code> functions (I&#39;m using ES6 syntax here - gotta love those arrow functions!):</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> getAdminEmails = users =&gt;
    users
      .filter(u =&gt; u.role === <span class="hljs-string">'admin'</span>)
      .map(u =&gt; u.email);</code></pre>

<p>Analyzing this function is easier: we get the users, separate only the admins, and then get the emails. The first strong point of this style is that <em>the code of the function is closer to the description of what the function does</em>. This makes it easier to understand and reason about it, and to look into a new piece of code and understanding quickly what is supposed to happen.</p>
<p>Filters and maps go through an array&#39;s elements, just like the for loop, but they have specific purposes: returning subsets and transforming elements, respectively. In contrast, anything can happen inside a for loop. That means that every time you bump into a for loop code, you have to investigate more to understand if a subset will be returned or not, if an element will be transformed, if values will be aggregated, or any combination of those outcomes.</p>
<p>When you use filters and maps, you have a quicker understanding of the function, and you can deepen that understanding little by little as you need to. I know <code>getAdminEmails</code> returns an array, since it has a filter and a map. On a second look, one sees that it first filters the users, then transforms them. One can now investigate <em>just the filter</em> to understand which elements are going to be transformed. And then one can investigate what happens during the transformation itself.</p>
<h2 id="composability">Composability</h2>
<p>What I find very interesting in the functional version is that I could understand it piece by piece, in different layers. I&#39;ll try to make it even more clear now, and produce some reusable functions along the way!</p>
<p>Let&#39;s start by trying to write the code as close as possible to what the function does. We want to transform a filtered list, so let&#39;s start by composing those two pieces:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> getAdminEmails = compose(
  getTheEmailsOf,
  onlyTheAdminRoleUsers);</code></pre>

<p><code>compose</code> is a function that take two functions as parameters, and run one after the other:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> compose = (f, g) =&gt; x =&gt; f(g(x));</code></pre>

<p>Now let&#39;s go to the two functions that are going to be composed. <code>getEmailsOf</code> is a function that transforms a list by returning the <code>email</code> property. &quot;Transforming a list&quot; is what map does. And getting a property from an object sounds like a very common task, so let&#39;s implement <code>map</code> from a different angle and <code>prop</code>:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> prop = p =&gt; x =&gt; x[p];

<span class="hljs-keyword">var</span> map = f =&gt; list =&gt;
  list.map(f);

<span class="hljs-comment">// which lead to:</span>
<span class="hljs-keyword">var</span> getTheEmailsOf = map(prop(<span class="hljs-string">'email'</span>));</code></pre>

<p><code>onlyTheAdminRoleUsers</code> is a filter. The test to decide which elements will be returned involves testing if a property is equal to some value:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> propEq = v =&gt; p =&gt; obj =&gt;
  prop(p)(obj) === v;

<span class="hljs-keyword">var</span> filter = f =&gt; list =&gt;
  list.filter(f);

<span class="hljs-keyword">var</span> onlyTheAdminRoleUsers =
  filter(propEq(<span class="hljs-string">'admin'</span>)(<span class="hljs-string">'role'</span>));</code></pre>

<p>And the function&#39;s final version:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> getAdminEmails = compose(
  map(
    prop(<span class="hljs-string">'email'</span>)),
  filter(
    propEq(<span class="hljs-string">'admin'</span>)(<span class="hljs-string">'role'</span>)));</code></pre>

<p>That is what is called <em>point-free programming</em>, or <em>tacit programming</em>. What is most amazing about this version is that it is <em>entirely composed of other smaller, generic and reusable functions</em>! These functions will not only will help you with your next functions, but they will help you understanding quicker <em>any</em> function. After you know what <code>prop</code> does, it becomes faster to understand <code>prop(&#39;something&#39;)</code> than <code>obj =&gt; obj.something</code>, and we don&#39;t need to go into the &quot;stress&quot; of having to choose a name for the temporary <code>obj</code> variable! :)</p>
<p>Note: most of these smaller functions are generic and useful enough so that we could use them in almost every project. <a href="http://ramdajs.com/">Ramda</a> is a library that has exactly that: a bunch of really small and generic functions.</p>
<h2 id="another-example">Another Example</h2>
<p>I&#39;ll finish with another common situation:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> calculateTotalPromotions = cart =&gt;
  getPromotions(cart.products[<span class="hljs-number">0</span>])
    .then(calculateTotal);</code></pre>

<p>We can understand it quickly because of familiarity, but the code flow is all over the place. Here&#39;s what it does: <em>it calculates the total of the promotions of the first product of the cart</em>. Look at the order of this last sentence, and compare the order of the code above with the following function:</p>
<pre><code class="hljs js"><span class="hljs-comment">// composeP is a compose that accepts Promises</span>
<span class="hljs-keyword">var</span> calculateTotalPromotions = composeP(
  calculateTotal,
  getPromotions,
  head, <span class="hljs-comment">// head returns first element</span>
  prop(<span class="hljs-string">'products'</span>));</code></pre>

<p>Read the code, understand what is going to happen. Much simpler! :)</p>
<h2 id="conclusions">Conclusions</h2>
<p>Pointfree programming is all about modularizing functions through composition. You use smaller, generic, well defined and well tested functions to build the functions you need. Inside a <code>compose</code> or <code>composeP</code>, one function is called, then the other, and that&#39;s how it goes, no matter if the function has 17 lines or 3. It works the same way, and <em>code complexity does not increase</em>.</p>
<p>We also don&#39;t have to worry about temporary variables, which makes it easier to understand code and harder to introduce bugs. Also, it&#39;s easier to understand and test smaller parts of the code, which makes it more reliable.</p>
<p>Of course it&#39;s not a silver bullet, and a lot of times I end up with a function that is not fully pointfree. I find its main weakness occurs when the function has more than one parameter; very often it leads to having some non pointfree code. But, that said, my personal experience is that the pointfree part of the code is much more robust and errors are identified earlier in the development phase. Bugs are almost never found in the pointfree code! :)</p>
<h2 id="further-reading">Further Reading</h2>
<p>The first place I heard about this programming style was in Frontend Masters <a href="https://frontendmasters.com/courses/functional-javascript/">Hardcore Functional Javascript</a>. It&#39;s definitely worth the price.</p>
<p><a href="https://jsleao.wordpress.com/">jsanchesleao</a> also wrote an interesting post about <a href="https://jsleao.wordpress.com/2015/02/22/curry-and-compose-why-you-should-be-using-something-like-ramda-in-your-code/">why you should be using something like ramda in your code</a>.</p>
]]></description>
            <guid isPermaLink="false">Pointfree Javascript</guid>
            <pubDate>Fri, 20 Mar 2015 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[A More Functional Approach to Angular, with Baobab]]></title>
            <description><![CDATA[<p>In my <a href="../a-more-functional-approach-to-angular/">last post</a> I described a simple way to deal with state in an Angular application. I didn&#39;t detail the actual <code>AppStateService</code> implementation, and was about to do it in a &quot;part 2&quot;.  I was about to do just that when I came across <a href="https://github.com/Yomguithereal/baobab">Baobab</a>, a framework-agnostic library that actually implements the idea of a centralized state. In this post I&#39;ll recap a little bit on why the concept of a centralized state is important, then I&#39;ll present the Baobab library, and finally I&#39;ll describe an adaptation of my last post&#39;s sample app which uses a centralized state.</p>
<h2 id="why-is-having-a-central-state-important-">Why is having a central state important?</h2>
<p>A <em>state</em> can be thought as a &quot;picture&quot;, or the &quot;value&quot;, of something in a certain point in time. I&#39;ll call <em>central state</em> the value of your <em>whole application</em> at a certain point in time. So, as your application changes, every little part of that change will be stored in this central place.</p>
<p>Having present and past states stored in a single place makes it easier to implement new features in an application, and change old ones. It also makes it easier to make sense of what&#39;s going on in your application at any given moment. As I said in the <a href="../a-more-functional-approach-to-angular/">previously mentioned post</a>:</p>
<blockquote>
<p>As the project grows, the complexity seems to grow at a higher rate, and it becomes more and more difficult to answer the simple question <em>what is happening to my application right now?</em> Or the even more important <em>what was happening when that crazy error occurred?</em></p>
</blockquote>
<h2 id="presenting-baobab">Presenting Baobab</h2>
<p>In Baobab, the central state is created by passing a regular object to the constructor:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// if using node or browserify:</span>
<span class="hljs-keyword">var</span> Baobab = <span class="hljs-built_in">require</span>(<span class="hljs-string">'baobab'</span>);

<span class="hljs-keyword">var</span> appState = <span class="hljs-keyword">new</span> Baobab({
  cart: {
    products: []
  },
  paymentOptions: []
});</code></pre>

<p>One can refer to any part of the tree with the <code>select</code> function:</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> cartCursor = appState.select(<span class="hljs-string">'cart'</span>);
<span class="hljs-keyword">var</span> productsCursor = appState.select(<span class="hljs-string">'cart'</span>, <span class="hljs-string">'products'</span>);</code></pre>

<p><code>select</code> returns a <em>cursor</em>. The first thing you can do with a cursor is <em>extracting its value</em>:</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> currentCart = cartCursor.get();
<span class="hljs-comment">// =&gt; currentCart = { products: [] }</span>
<span class="hljs-keyword">var</span> currentProducts = productsCursor.get();
<span class="hljs-comment">// =&gt; currentProducts = []</span></code></pre>

<p>You can also <em>update its value</em>, and <em>listen to updates</em>:</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> cartCursor = appState.select(<span class="hljs-string">'cart'</span>);
<span class="hljs-keyword">var</span> productsCursor = appState.select(<span class="hljs-string">'cart'</span>, <span class="hljs-string">'products'</span>);
<span class="hljs-keyword">var</span> paymentOptionsCursor = appState.select(<span class="hljs-string">'paymentOptions'</span>);

cartCursor.on(<span class="hljs-string">'update'</span>, someCallback);
productsCursor.on(<span class="hljs-string">'update'</span>, anotherCallback);
paymentOptionsCursor.on(<span class="hljs-string">'update'</span>, yetAnotherCallback);

productCursor.push({ id: <span class="hljs-number">123</span> });
<span class="hljs-comment">// only someCallback and anotherCallback will be called</span></code></pre>

<p>So, what&#39;s so great about all that? First, the &quot;listening&quot; part of your application does not need to know anything about the &quot;changing&quot; part. You just listen to updates to the tree, and act on it. Also, if you have a view that only needs to know about the products, just listen to updates on the products. No need to listen to the whole tree.</p>
<h2 id="a-sample-app">A sample app</h2>
<p>Now let&#39;s use Baobab in a sample application. In the sample, we&#39;ll have two arrays: Foos and Bars. Both will hold strings. To add a weird spec to the mix, the user should not be able to add any Bar unless Foos has the string <code>&#39;requiredFoo&#39;</code>. Let&#39;s implement it piece by piece, starting with the central state:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// app.js</span>
angular.module(<span class="hljs-string">'simpleStateApp'</span>, []);

<span class="hljs-comment">// services/appState.js</span>
angular.module(<span class="hljs-string">'simpleStateApp'</span>)
  .factory(<span class="hljs-string">'AppState'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">var</span> initial = {
    foos: [],
    bars: []
  };
  <span class="hljs-keyword">var</span> state = <span class="hljs-keyword">new</span> Baobab(initial);

  <span class="hljs-keyword">return</span> state;</code></pre>

<p>Simple and elegant. Don&#39;t we like it when that happens? :) Now let&#39;s implement <code>ReadOnlyCtrl</code>, a controller that only reads the central state values:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// controllers/readOnlyController.js</span>
angular.module(<span class="hljs-string">'simpleStateApp'</span>)
  .controller(<span class="hljs-string">'ReadOnlyCtrl'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">AppState</span>) </span>{

  <span class="hljs-keyword">var</span> state = AppState.get();

  <span class="hljs-keyword">var</span> foosCursor = AppState.select(<span class="hljs-string">'foos'</span>);
  <span class="hljs-keyword">var</span> barsCursor = AppState.select(<span class="hljs-string">'bars'</span>);

  foosCursor.on(<span class="hljs-string">'update'</span>,
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ state.foos = foosCursor.get(); });

  barsCursor.on(<span class="hljs-string">'update'</span>,
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ state.bars = barsCursor.get(); });

  <span class="hljs-comment">// exposes to view</span>
  <span class="hljs-keyword">this</span>.state = state;
});</code></pre>

<p><code>state</code> will be rendered in the view like any other variable:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ng-controller</span>=<span class="hljs-string">"ReadOnlyCtrl as c"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Read Only Controller<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Foos:
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">ng-repeat</span>=<span class="hljs-string">"foo in c.state.foos"</span>&gt;</span>{{ foo }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Bars:
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">ng-repeat</span>=<span class="hljs-string">"bar in c.state.bars"</span>&gt;</span>{{ bar }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>

<p>That was easy! Now let&#39;s implement a controller that changes the central state:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// controllers/fooController.js</span>
angular.module(<span class="hljs-string">'simpleStateApp'</span>)
  .controller(<span class="hljs-string">'FooCtrl'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">AppState</span>) </span>{

  <span class="hljs-keyword">var</span> foosCursor = AppState.select(<span class="hljs-string">'foos'</span>);

  <span class="hljs-keyword">var</span> state = {
    foos: foosCursor.get()
  };

  <span class="hljs-comment">// the inputs in the view will refer to</span>
  <span class="hljs-comment">// this variable</span>
  <span class="hljs-keyword">var</span> form = {
    newFoo: <span class="hljs-string">''</span>
  };

  foosCursor.on(<span class="hljs-string">'update'</span>,
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ state.foos = foosCursor.get() });

  <span class="hljs-keyword">var</span> addFoo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">form</span>) </span>{
    foosCursor.push(form.newFoo);
  };

  <span class="hljs-keyword">this</span>.state = state;
  <span class="hljs-keyword">this</span>.form = form;

  <span class="hljs-keyword">this</span>.addFoo = addFoo;
});</code></pre>

<p>Note the <code>form</code> variable. It holds the temporary values of the HTML inputs. The <code>addFoo</code> function receives this as the parameter, and changes the value of the tree. We&#39;ll call <code>addFoo</code> with a button <code>ng-click</code>, but that&#39;s a design decision. It could also be done with the input <code>ng-change</code>, for instance. Let&#39;s see the view code:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ng-controller</span>=<span class="hljs-string">"FooCtrl as c"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>"Foo" form<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
    New Foo: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">ng-model</span>=<span class="hljs-string">"c.form.newFoo"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">ng-click</span>=<span class="hljs-string">"c.addFoo(c.form)"</span>&gt;</span>Add Foo<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>

<p><code>BarCtrl</code> has more features: <code>cannotAddBar</code>, the function that that we used to implement the weird spec, and <code>clearState</code>, the function that clears central state:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// controllers/barController.js</span>
angular.module(<span class="hljs-string">'simpleStateApp'</span>)
  .controller(<span class="hljs-string">'BarCtrl'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">AppState</span>) </span>{

  <span class="hljs-keyword">var</span> foosCursor = AppState.select(<span class="hljs-string">'foos'</span>);
  <span class="hljs-keyword">var</span> barsCursor = AppState.select(<span class="hljs-string">'bars'</span>);

  <span class="hljs-keyword">var</span> state = AppState.get();
  <span class="hljs-keyword">var</span> form = {
    newBar: <span class="hljs-string">''</span>
  };

  foosCursor.on(<span class="hljs-string">'update'</span>,
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ state.foos = foosCursor.get(); });
  barsCursor.on(<span class="hljs-string">'update'</span>,
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ state.bars = barsCursor.get(); });

  <span class="hljs-keyword">var</span> addBar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">form</span>) </span>{
    barsCursor.push(form.newBar);
  };

  <span class="hljs-keyword">var</span> cannotAddBar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state</span>) </span>{
    <span class="hljs-keyword">return</span> state.foos.indexOf(<span class="hljs-string">'requiredFoo'</span>) === <span class="hljs-number">-1</span>;
  };

  <span class="hljs-keyword">var</span> clearState = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    foosCursor.edit([]);
    barsCursor.edit([]);
  };

  <span class="hljs-keyword">this</span>.state = state;
  <span class="hljs-keyword">this</span>.form = form;

  <span class="hljs-keyword">this</span>.addBar = addBar;
  <span class="hljs-keyword">this</span>.cannotAddBar = cannotAddBar;
  <span class="hljs-keyword">this</span>.clearState = clearState;
  <span class="hljs-keyword">this</span>.undo = undo;
});</code></pre>

<p>With the view:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ng-controller</span>=<span class="hljs-string">"BarCtrl as c"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Second "Bar" form<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
      New Bar: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">ng-model</span>=<span class="hljs-string">"c.form.newBar"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">ng-click</span>=<span class="hljs-string">"c.addBar(c.form)"</span>
              <span class="hljs-attr">ng-disabled</span>=<span class="hljs-string">"c.cannotAddBar(c.state)"</span>&gt;</span>
        Add Bar
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
      Click <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">""</span> <span class="hljs-attr">ng-click</span>=<span class="hljs-string">"c.clearState()"</span>&gt;</span>here to clear the State<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.
    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>

<p>And that&#39;s it! But wait, there&#39;s a little problem we need to deal with. The views do not update as soon as the central state is updated. This happens because Angular&#39;s change detection mechanism is not triggered by an update to the central state. We can fix this by putting the following piece of code inside <code>AppState</code>:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// services/appState.js</span>
state.on(<span class="hljs-string">'update'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    $rootScope.$apply();
  }, <span class="hljs-number">0</span>);
});</code></pre>

<p>And our application will run smoothly!</p>
<h2 id="adding-features">Adding features</h2>
<p>Because everything that  changes is stored in one place, we can easily plug new functionalities by interacting with the central state. That&#39;s when this architecture shines.</p>
<p>Let&#39;s suppose we want to save our state in the local storage, so that every time the user goes back to it, the last state will be loaded.</p>
<p>The idea is to load the saved state when starting the app, and save it after every change. Let&#39;s first implement a <code>save</code> and a <code>load</code> function in a service:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// services/storageService.js</span>
angular.module(<span class="hljs-string">'simpleStateApp'</span>)
  .factory(<span class="hljs-string">'StorageService'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">var</span> save = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop, items</span>) </span>{
    <span class="hljs-built_in">window</span>.localStorage.setItem(
      <span class="hljs-string">'baobab-app-'</span> + prop,
      <span class="hljs-built_in">JSON</span>.stringify(items));
    <span class="hljs-keyword">return</span> items;
  };

  <span class="hljs-keyword">var</span> load = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop, defaultValue</span>) </span>{
    <span class="hljs-keyword">var</span> items = <span class="hljs-built_in">JSON</span>.parse(
      <span class="hljs-built_in">window</span>.localStorage.getItem(
        <span class="hljs-string">'baobab-app-'</span> + prop));
    <span class="hljs-keyword">return</span> items ? items : defaultValue;
  };

  <span class="hljs-keyword">return</span> {
    save: save,
    load: load
  };
});</code></pre>

<p>Now let&#39;s change <code>AppState</code> to load local storage on startup:</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> initial = {
  foos: [],
  bars: []
};
<span class="hljs-keyword">var</span> state = <span class="hljs-keyword">new</span> Baobab(
  StorageService.load(<span class="hljs-string">'baobab'</span>, initial),
);</code></pre>

<p>And let&#39;s use a <code>.run</code> to save the state on every update:</p>
<pre><code class="hljs javascript">angular.module(<span class="hljs-string">'simpleStateApp'</span>, [])
  .run(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">StorageService, AppState</span>) </span>{
    AppState.on(<span class="hljs-string">'update'</span>,
      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        StorageService.save(<span class="hljs-string">'baobab'</span>, AppState.get());
      });
  });</code></pre>

<p>And the new feature is added. It shines, doesn&#39;t it? :)</p>
<h2 id="one-little-baobab-bonus">One Little Baobab Bonus</h2>
<p>Baobab works very well, and still gives us a free important and amazing bonus: undo. We just have to first pass a config to the constructor:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// services/appState.js</span>
<span class="hljs-keyword">var</span> state = <span class="hljs-keyword">new</span> Baobab(
  StorageService.load(<span class="hljs-string">'baobab'</span>, initial),
  {
    maxHistory: <span class="hljs-number">10</span>
  }
);</code></pre>

<p>And implement the <code>undo</code> function on the controller:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// controllers/barController.js</span>
<span class="hljs-keyword">var</span> undo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (AppState.hasHistory()) {
    AppState.undo();
  }
};</code></pre>

<p>And our undo is done.</p>
<h2 id="conclusions">Conclusions</h2>
<p>That was a lot for one post! But I hope I could show some benefits of having a centralized state application architecture. It&#39;s all about having the ability to add new features and change old ones with ease, and, as was said before, being able to answer the really important question <em>what is happening in my application right now?</em></p>
<h2 id="next-steps">Next Steps</h2>
<p>Javascript is going through a big change now with ES6, and Angular 2 is on its way. I&#39;m looking forward to see how to implement a centralized state using these tools.</p>
<p>React is a great framework, that&#39;s gaining a lot of traction. I knew about Baobab through <a href="http://christianalfoni.github.io/">Christian Alfoni</a>&#39;s amazing blog, and he wrote a post on <a href="http://christianalfoni.github.io/javascript/2015/02/06/plant-a-baobab-tree-in-your-flux-application.html">how to use it with React</a>.</p>
<p>There&#39;s a new project experimenting with Baobab and Angular, <a href="https://github.com/christianalfoni/baobab-angular">baobab-angular</a>. I&#39;m definitely going to have a look at it.</p>
<p>On another note, I will also implement the app in a <em>point-free functional</em> style. I try to write my functions point-free whenever I can; it&#39;s also a way to bring simplicity to the function level. More details in an upcoming post!</p>
<p>The example presented in this post has a <a href="http://lucasmreis.github.io/baobabStateApp/">live demo here</a>. Complete source code can be found <a href="https://github.com/lucasmreis/baobabStateApp">here</a>.</p>
]]></description>
            <guid isPermaLink="false">A More Functional Approach to Angular, with Baobab</guid>
            <pubDate>Tue, 10 Mar 2015 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[A More Functional Approach to Angular]]></title>
            <description><![CDATA[<p>We all know the story: a project is started with all the current best practices and an elegant architecture. Everything is beautiful - until it is not anymore. As the project grows, the complexity seems to grow at a higher rate, and it becomes more and more difficult to answer the simple question <em>what is happening to my application right now?</em> Or the even more important <em>what was happening when that crazy error occurred?</em> In this post, I propose a solution to this problem.</p>
<p>One day I was googling ways to deal with this type of complexity, and I came across the talk <a href="http://www.infoq.com/presentations/Simple-Made-Easy">Simple Made Easy</a> by Rich Hickey and the paper <a href="https://github.com/papers-we-love/papers-we-love/tree/master/design/out-of-the-tar-pit.pdf">Out of the Tar Pit</a>, by Ben Moseley and Peter Marks. This material changed the way I think about programming, and every time I come back to them, I learn a little bit more.</p>
<p>I can see now that most of that complexity was coming from the way I was storing and dealing with the <em>state</em> of my application. It was all over the place. I was getting information from the APIs and storing them in the services themselves. It wasn&#39;t clear who was reading that information, who was transforming it, or who was writing it. A lot of debugging was needed to understand what was happening at any point in time, and it was really difficult to write tests for everything.</p>
<h2 id="the-solution">The Solution</h2>
<p>In order to solve this problem, I took a more <em>functional</em> approach by avoiding mutation as much possible and only changing variables in a few controlled places. In addition, to take it a step further, I stored <em>all the application state in a single place</em> (some React frameworks work this way, like <a href="https://github.com/omcljs/om">Om</a> and <a href="https://github.com/moreartyjs/moreartyjs">Morearty</a>).</p>
<p>The architecture is simple: all the state will be in one factory. Other services will consist of pure functions. The controllers will listen and/or change the state. And that&#39;s it! Let me explain it more, and illustrate with an example.</p>
<p>Remark: the solution will be illustrated in Angular, but it could, with little work, be implemented in other frameworks (or even vanilla JS for that matter).</p>
<p>The state will be stored in the <code>AppStateService</code> service. It has two methods: <code>listen</code> and  <code>change</code>. <code>listen</code> is used to observe one part of the state. Every time the <code>change</code> method is called, the listeners will be updated.</p>
<p>The controllers will have a <code>state</code> variable exposed to the views, which will be listening to <code>AppStateService</code>. It&#39;s important the that variable remain <em>immutable</em>; let&#39;s remember that <code>AppStateService</code> should only be mutated via the <code>change</code> method:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// INSIDE CONTROLLER</span>

<span class="hljs-comment">// local variable to store the state values</span>
<span class="hljs-keyword">var</span> state = {};

<span class="hljs-comment">// every time AppStateService changes,</span>
<span class="hljs-comment">// local state will change too:</span>
AppStateService.listen(<span class="hljs-string">'somePart'</span>,
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{ state.somePart = s; });
<span class="hljs-comment">// =&gt; state = { somePart: null }</span>

<span class="hljs-comment">// change AppStateService:</span>
AppStateService.change(<span class="hljs-string">'somePart'</span>, <span class="hljs-string">'someValue'</span>);
<span class="hljs-comment">// =&gt; state = { somePart: 'someValue' }</span></code></pre>

<p>The <code>state</code> variable should be exposed to the views, together with pure functions to transform it:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// using "Controller As" syntax</span>
<span class="hljs-keyword">this</span>.state = state;
<span class="hljs-keyword">this</span>.summary = SomeService.summary;</code></pre>

<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ng-controller</span>=<span class="hljs-string">"SomeController as ctrl"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Some Part: {{ ctrl.state.somePart }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Summary: {{ ctrl.summary(ctrl.state) }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>

<p>If the view has any input, the controller will have another variable called <code>form</code>, to take advantadge of Angular&#39;s two-way binding:</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> form = { newFoo: <span class="hljs-string">'initial value'</span> };
<span class="hljs-keyword">this</span>.form = form;</code></pre>

<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
  New Foo: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">ng-model</span>=<span class="hljs-string">"c.form.newFoo"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>

<p>Now let&#39;s take this Foo example a little further, and start changing the State.</p>
<h2 id="a-more-complete-example">A More Complete Example</h2>
<p>Let <code>AppStateService</code> hold a <code>foos</code> array. We want a view with an input and a button that, when pressed, add a new Foo to <code>foos</code>:</p>
<pre><code class="hljs javascript">angular.module(<span class="hljs-string">'simpleStateApp'</span>)
  .controller(<span class="hljs-string">'FooCtrl'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">AppStateService</span>) </span>{

  <span class="hljs-keyword">var</span> state = {};
  <span class="hljs-keyword">var</span> form = {
    newFoo: <span class="hljs-string">''</span>
  };

  AppStateService.listen(<span class="hljs-string">'foos'</span>,
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f</span>) </span>{ state.foos = f; });

  <span class="hljs-comment">// changeFoos is a function that</span>
  <span class="hljs-comment">// only affects the foos property</span>
  <span class="hljs-keyword">var</span> changeFoos = AppStateService.change(<span class="hljs-string">'foos'</span>);

  <span class="hljs-keyword">var</span> addFoo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state, form</span>) </span>{
    <span class="hljs-comment">// using Ramda library</span>
    <span class="hljs-keyword">var</span> newFoos =
      R.append(form.newFoo, state.foos);
    changeFoos(newFoos);
  };

  <span class="hljs-comment">// exposed to the view:</span>
  <span class="hljs-keyword">this</span>.state = state;
  <span class="hljs-keyword">this</span>.form = form;

  <span class="hljs-keyword">this</span>.addFoo = addFoo;
});</code></pre>

<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ng-controller</span>=<span class="hljs-string">"FooCtrl as c"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>"Foo" form<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
    New Foo: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">ng-model</span>=<span class="hljs-string">"c.form.newFoo"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">ng-click</span>=<span class="hljs-string">"c.addFoo(c.state, c.form)"</span>&gt;</span>
      Add Foo
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>

<p>So, now we have an <code>addFoo</code> function. It changes the state by appending <code>form.newFoo</code> to the <code>foos</code> array. The best part is: every part of the application listening to the <code>foos</code> array will be updated once the <code>changeFoos</code> function is called!</p>
<p>I setup a small project illustrating that idea <a href="https://github.com/lucasmreis/simpleStateApp">on Github</a>. It illustrates well the benefits of using this approach:</p>
<ol>
<li>There&#39;s a &quot;read only&quot; controller, listening to both <code>foos</code> and <code>bars</code> arrays from <code>AppStateService</code>;</li>
<li>There&#39;s a Foo controller;</li>
<li>There&#39;s a Bar controller being used in <em>two</em> different views;</li>
<li>The Bar controller also listens to <code>foos</code>, and the user can only add a Bar after a Foo named <code>requiredFoo</code> is created (I call this the &quot;weird spec&quot; :) ). This is used to illustrate how different controllers can interplay in intricate ways through the State;</li>
<li>The application also listens to changes in state and save them on local storage.</li>
</ol>
<h2 id="conclusions">Conclusions</h2>
<p>So, what have we gained from this architecture? In one word, <em>simplicity</em>. The entire application becomes more easily understandable. It&#39;s simple to reason about the whole application. Everything that changes with time is confined to <code>AppStateService</code>. You know exactly who changes and who listens to each part of it.</p>
<p>In the example posted, I also implemented the method <code>AppStateService.get()</code>, that returns the whole state object. Inject it into the console, and you have an incredible debugging tool. This answers the question we ask at the beginning of this post: <em>what is happening to my application right now?</em></p>
<h2 id="next-steps">Next Steps</h2>
<p>This solution works really well for my current project, but, of course, I&#39;m sure it could be improved. I would appreciate any input!</p>
<p>One feature I would love to see implemented: whenever a big problem happens, an error event would be sent to the server with the State object, so the developers can see exactly where the user was when the error ocurred. That would be awesome.</p>
<p>Here&#39;s the <a href="https://github.com/lucasmreis/simpleStateApp">working demo</a>.</p>
<p><strong>Update 2015-03-10</strong>: I illustrate again this idea in the <a href="../a-more-functional-approach-to-angular-with-baobab">next post</a>, this time using the Baobab library. Check it out, it even has <em>undo</em>! :)</p>
]]></description>
            <guid isPermaLink="false">A More Functional Approach to Angular</guid>
            <pubDate>Sun, 22 Feb 2015 00:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>