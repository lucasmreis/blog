<!DOCTYPE html>
<html>
  <head>
    <title>Immutable Data Structures and Javascript | Lucas Reis' Blog</title>
    <link rel="stylesheet" href="../styles/reset.css" type="text/css">
    <link rel="stylesheet" href="../styles/style.css" type="text/css">
    <link rel="stylesheet" href="../styles/highlight.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Libre+Baskerville:400,700,400italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Lato:300,900' rel='stylesheet' type='text/css'>
    <link href="../rss.xml" rel="alternate" type="application/rss+xml" title="Lucas Reis' Blog">

    <link rel="apple-touch-icon-precomposed" sizes="57x57" href="../assets/favicon/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/favicon/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/favicon/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/favicon/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon-precomposed" sizes="60x60" href="../assets/favicon/apple-touch-icon-60x60.png" />
    <link rel="apple-touch-icon-precomposed" sizes="120x120" href="../assets/favicon/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon-precomposed" sizes="76x76" href="../assets/favicon/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../assets/favicon/apple-touch-icon-152x152.png" />
    <link rel="icon" type="image/png" href="../assets/favicon/favicon-196x196.png" sizes="196x196" />
    <link rel="icon" type="image/png" href="../assets/favicon/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/png" href="../assets/favicon/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="../assets/favicon/favicon-16x16.png" sizes="16x16" />
    <link rel="icon" type="image/png" href="../assets/favicon/favicon-128.png" sizes="128x128" />
    <meta name="application-name" content="Lucas Reis' Blog"/>
    <meta name="msapplication-TileColor" content="#FFFFFF" />
    <meta name="msapplication-TileImage" content="../assets/favicon/mstile-144x144.png" />
    <meta name="msapplication-square70x70logo" content="../assets/favicon/mstile-70x70.png" />
    <meta name="msapplication-square150x150logo" content="../assets/favicon/mstile-150x150.png" />
    <meta name="msapplication-wide310x150logo" content="../assets/favicon/mstile-310x150.png" />
    <meta name="msapplication-square310x310logo" content="../assets/favicon/mstile-310x310.png" />

  </head>
  <body>
    <div id="container">
      <header>
        <ul>
          <li class="active"><a href="../contents/">Blog</a></li>
          <li><a href="../">About</a></li>
        </ul>
      </header>
      <div id="main-text">
            <h1>Immutable Data Structures and Javascript</h1>
        <div class="lead">Using Mori to bring simplicity to state handling</div>
        <p>One of the most difficult - perhaps <em>the</em> most difficult - issue in a complex front end application is state handling. I&#39;ve written before about storing <a href="http://lucasmreis.github.io/blog/a-more-functional-approach-to-angular/">all application state</a> in a <a href="http://lucasmreis.github.io/blog/a-more-functional-approach-to-angular-with-baobab/">single, centralized object</a>, and now I&#39;ll write about using <em>immutable data structures</em>.</p>
<p>I found that working with immutable data structures has actually made implementation <em>much simpler</em>! How can a limitation make something more powerful, you may be asking yourself? Follow me and I&#39;ll explain.</p>
<p>##Why did I try this immutable thing</p>
<p>I&#39;ve been watching a lot of Rich Hickey videos lately, and everything this guy says makes a lot of sense. According to Hickey, an immutable collection is not only an &quot;array that cannot be modified&quot;, but it is an <em>array that can be treated as a value</em>.</p>
<p>When we have two Numbers or two Strings, and we want to know if they are equal, we simply ask &quot;are they equal?&quot; by using the <code>===</code> operator. That&#39;s it - <code>2</code> always equals <code>2</code>, and if <code>a = 2</code> and <code>b = 2</code> we can say for sure that <code>a === b</code>. The same would be true for other values like <code>&#39;this string&#39; === &#39;this string&#39;</code>.</p>
<p>But, if we have two arrays or objects, <code>===</code> does not work the same way. It works by comparing references, so <code>[1, 2, 3] === [1, 2, 3]</code> is false, because they are actually <em>two different collections that happen to have the same values</em>.</p>
<p>When working with immutable collections and objects, they are compared just like values. If they have the same elements, they are the same collection. Simple, isn&#39;t it? :)</p>
<p>This is possible due to smart algorithms and data structure implementation made by libraries like <a href="http://swannodette.github.io/mori/">Mori</a> and <a href="https://facebook.github.io/immutable-js/">Immutable.js</a>. I will not go into detail here, but here&#39;s what we need to know regarding these data structures:</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> Mori <span class="hljs-keyword">from</span> <span class="hljs-string">'mori'</span>;

<span class="hljs-comment">// a vector is an example of</span>
<span class="hljs-comment">// immutable data structure</span>
<span class="hljs-keyword">const</span> a = mori.vector(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);

<span class="hljs-comment">// conj appends a value to the</span>
<span class="hljs-comment">// end of a vector, and returns</span>
<span class="hljs-comment">// a new vector</span>
<span class="hljs-keyword">const</span> b = mori.conj(a, <span class="hljs-number">4</span>);

mori.equals(b, mori.vector(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))
<span class="hljs-comment">// =&gt; true</span>

<span class="hljs-comment">// cool feature: the original vector is preserved</span>
<span class="hljs-comment">//   (that's why they are also called</span>
<span class="hljs-comment">//   persistent data structures)</span>
mori.equals(a, mori.vector(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))
<span class="hljs-comment">// =&gt; true</span></code></pre>

<p><strong>Question 1.</strong> Are the objects cloned every time I apply a transformation? <strong>No.</strong> And that&#39;s a key part of the reason why the  immutable data structures&#39; performance is almost the same as their mutable counterparts. These libraries are implemented so that a transformed object <em>shares as much memory as possible</em> with the original object. (<a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1">more details here</a>)</p>
<p><strong>Question 2.</strong> Does that mean that storing transformed versions of objects use less memory? <strong>Yes!</strong> If we have an one million elements conventional array that occupies 1GB of memory, clone it, append an element, and save both versions, we&#39;ll use 2GB of memory. If we use an immutable vector and <code>conj</code>, storing both versions will not occupy much more space than storing only one vectors.</p>
<p>Pause a little bit to think about this last property of immutable objects, and think of how much awesomeness this &quot;limitation&quot; could bring to your code. :)</p>
<p>##Back to application state</p>
<p>The application will only consist of two lists, Foos and Bars. The user can add a new Foo or a new Bar using the app inputs. Foos and Bars are unique.</p>
<p>Let&#39;s do it step by step:</p>
<ul>
<li>The application state will be represented by a vector of hashmaps. The last hasmap will be the current state:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// appState.js</span>
<span class="hljs-keyword">const</span> initialValue = hashMap(
  <span class="hljs-string">'foos'</span>, set([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]),
  <span class="hljs-string">'bars'</span>, set([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]));

<span class="hljs-comment">// sets are unordered lists that have</span>
<span class="hljs-comment">// unique elements</span>

<span class="hljs-keyword">let</span> history = vector(initialValue);

<span class="hljs-comment">// get current state</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> currentState = () =&gt; peek(history);</code></pre>

<ul>
<li>To react to changes in the state, we register listeners. They consist of two functions: <code>listenTo</code>, which specifies a part/transformation of the state that will be listened to, and a <code>callback</code> to run if the state changes:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// appState.js</span>
<span class="hljs-keyword">let</span> listeners = vector();

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> listen = (listenTo, callback) =&gt; {
  listeners = conj(listeners, hashMap(
    <span class="hljs-string">'listenTo'</span>, listenTo,
    <span class="hljs-string">'callback'</span>, callback
  ));
};</code></pre>

<p>Example of a <code>listen</code> call:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> prop = key =&gt; o =&gt; Mori.get(o, key);
listen(prop(<span class="hljs-string">'bars'</span>), renderSomething);</code></pre>

<p>This means that every time the property <code>bars</code> change, the function <code>renderSomething</code> will be run with <code>bars</code> as argument.</p>
<ul>
<li>To change state, one calls the update function. It changes the state and calls all listeners if their new <code>listenTo</code> result are different from the previous state:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// appState.js</span>

<span class="hljs-comment">// callListener is called by the update</span>
<span class="hljs-comment">// function for each listener registered, with</span>
<span class="hljs-comment">// the previous and the new state value:</span>
<span class="hljs-keyword">const</span> callListener =
  (previousState, newState) =&gt; listener =&gt; {

    <span class="hljs-keyword">const</span> listenTo =
    get(listener, <span class="hljs-string">'listenTo'</span>);

  <span class="hljs-keyword">const</span> previousListenTo =
    listenTo(previousState);

  <span class="hljs-keyword">const</span> newListenTo =
    listenTo(newState);

    <span class="hljs-comment">// if state does not change for</span>
    <span class="hljs-comment">// listener, nothing happens.</span>
    <span class="hljs-comment">// Remember 'equals' is super cheap! :)</span>
  <span class="hljs-keyword">if</span> (!equals(
    previousListenTo, newListenTo)) {
        get(listener, <span class="hljs-string">'callback'</span>)(newListenTo);
  }
  };

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> update = fn =&gt; {
  <span class="hljs-keyword">const</span> previousState = peek(history);

  <span class="hljs-comment">// calculate new state</span>
  <span class="hljs-keyword">const</span> newState = fn(previousState);

  <span class="hljs-keyword">if</span> (!equals(previousState, newState)) {
    <span class="hljs-comment">// add new state to history.</span>
    <span class="hljs-comment">// Remember our data structures</span>
    <span class="hljs-comment">// are persistent, and share</span>
    <span class="hljs-comment">// memory space! :)</span>
    history = conj(history, newState);

    <span class="hljs-comment">// fire listener callbacks</span>
    each(listeners, callListener(previousState, newState));
  }
};</code></pre>

<ul>
<li>Good bonus: undo!</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// appState.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> undo = () =&gt; {
  <span class="hljs-keyword">if</span> (count(history) &gt; <span class="hljs-number">1</span>) {

    <span class="hljs-keyword">const</span> previousState =
      peek(history);

    history =
      subvec(history, <span class="hljs-number">0</span>, count(history) - <span class="hljs-number">1</span>);

    <span class="hljs-keyword">const</span> newState =
      peek(history);

    each(listeners,
      callListener(previousState, newState));
  }
}</code></pre>

<ul>
<li>Views can be rendered by functions that take the state value as input. These render functions can also be used as callbacks:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// render.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> renderList = elem =&gt; seq =&gt;
  elem.innerHTML =
    reduce(makeLi, <span class="hljs-string">'&lt;ul&gt;'</span>, seq) + <span class="hljs-string">'&lt;/ul&gt;'</span>;

<span class="hljs-comment">// index.js</span>

<span class="hljs-comment">// starts by rendering initial state:</span>
<span class="hljs-keyword">const</span> initialState =
  currentState();

renderList
  (foosElement)
  (get(initialState, <span class="hljs-string">'foos'</span>));

<span class="hljs-comment">// renders again on state change:</span>
listen(prop(<span class="hljs-string">'foos'</span>),
  renderList(foosElement));</code></pre>

<ul>
<li>User interactions will call the <code>update</code> function to change state. The argument passed is a function that will transform the current state. Let&#39;s call those transformations commands:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// command.js</span>
<span class="hljs-keyword">const</span> conjItem = item =&gt; coll =&gt;
  conj(coll, item);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> addFoo = foo =&gt; state =&gt;
  updateIn(state, [<span class="hljs-string">'foos'</span>], conjItem(foo));

<span class="hljs-comment">// index.js</span>

<span class="hljs-comment">// input</span>
<span class="hljs-keyword">let</span> newFooElement =
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'new-foo'</span>);

<span class="hljs-comment">// button</span>
<span class="hljs-keyword">let</span> addFooElement =
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'add-foo'</span>);

addFooElement.onclick = () =&gt;
  update(addFoo(newFooElement.value));</code></pre>

<p>And that&#39;s it!</p>
<p>The architecture is really simple, let&#39;s recap it:</p>
<ul>
<li>The application state is represented by an immutable object.</li>
<li>The views are rendered according to the state object.</li>
<li>Listeners with callbacks are registered. Changes in state cause callbacks to be fired.</li>
<li>State is changed by calling the update function.</li>
<li>User interactions or any other event can call the update function.</li>
</ul>
<p>##And what did we gain by using immutable data structures?</p>
<p>My first impression was: it&#39;s simple. After getting used to the Mori functions, it is very straightforward to manipulate the data structures. And the fact that Mori handles memory and performance very well makes the code very direct too.</p>
<p>Immutable persistent data structures make comparison very cheap, and it proved to be very important to the update function. Memory sharing is also an amazing feature that practically gave &quot;undo&quot; for free.</p>
<p>So, in the end immutable data structures made it easy, explicit and performant to implement application state as series of values.</p>
<p>##Next steps</p>
<p>I chose Mori because it&#39;s an interface for clojurescript native data structures. <a href="http://clojure.org/">Clojure</a> is an amazing language, and I&#39;m starting to study and experiment with it now.</p>
<p>Staying in javascript, it would also be interesting to get a look at <a href="https://facebook.github.io/immutable-js/">immutable.js</a>. It&#39;s maintained by facebook, and seems to play very well with React.</p>

        <div class="signature">July 3, 2015.</div>
      </div>

      <!-- DISQUS -->
      <div id="disqus_thread"></div>
      <script type="text/javascript">
          /* * * CONFIGURATION VARIABLES * * */
          var disqus_shortname = 'lucasmreis';
          var disqus_identifier = 'immutable-data-structures-and-javascript';
          var disqus_title = 'Immutable Data Structures and Javascript';

          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

      <footer>
        by Lucas Reis | <a href="https://twitter.com/iamlucasmreis">Twitter</a> | <a href="https://github.com/lucasmreis">GitHub</a> | <a href="https://www.linkedin.com/profile/view?id=133974663">LinkedIn</a>
      </footer>
    </div>

    <!-- GOOGLE ANALYTICS -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-60280937-1', 'auto');
      ga('send', 'pageview');
    </script>

  </body>
</html>